{
  "id": "lesson-49-building-blockchain",
  "title": "Building a Complete Blockchain",
  "description": "Putting it all together: building a functional blockchain from scratch.",
  "content": "# Building a Complete Blockchain\n\nLet's build a complete, functional blockchain that combines all the concepts we've learned!\n\n## Project Structure\n\n```rust\n// Complete blockchain implementation\nuse std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nstruct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    fee: u64,\n    timestamp: u64,\n}\n\nstruct Block {\n    index: u64,\n    timestamp: u64,\n    transactions: Vec<Transaction>,\n    previous_hash: String,\n    hash: String,\n    nonce: u64,\n}\n\nstruct Blockchain {\n    blocks: Vec<Block>,\n    balances: HashMap<String, u64>,\n    pending_transactions: Vec<Transaction>,\n}\n```\n\n## Core Functionality\n\n1. **Genesis Block**: First block in the chain\n2. **Add Transactions**: Add to pending pool\n3. **Mine Block**: Create new block with transactions\n4. **Validate Chain**: Ensure blockchain integrity\n5. **Transfer Funds**: Update balances\n\n## Complete Implementation\n\n```rust\nimpl Blockchain {\n    fn new() -> Self {\n        let mut chain = Blockchain {\n            blocks: Vec::new(),\n            balances: HashMap::new(),\n            pending_transactions: Vec::new(),\n        };\n        \n        // Create genesis block\n        let genesis = Block {\n            index: 0,\n            timestamp: current_timestamp(),\n            transactions: Vec::new(),\n            previous_hash: String::from(\"0\"),\n            hash: String::from(\"genesis\"),\n            nonce: 0,\n        };\n        \n        chain.blocks.push(genesis);\n        chain\n    }\n    \n    fn add_transaction(&mut self, tx: Transaction) -> Result<(), String> {\n        // Validate transaction\n        let balance = self.balances.get(&tx.from).copied().unwrap_or(0);\n        if balance < tx.amount + tx.fee {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        self.pending_transactions.push(tx);\n        Ok(())\n    }\n    \n    fn mine_block(&mut self, difficulty: usize) -> Result<(), String> {\n        if self.pending_transactions.is_empty() {\n            return Err(String::from(\"No transactions to mine\"));\n        }\n        \n        // Take transactions from pool\n        let transactions: Vec<Transaction> = self.pending_transactions.drain(..).collect();\n        \n        // Create block\n        let previous_block = self.blocks.last().unwrap();\n        let mut block = Block {\n            index: previous_block.index + 1,\n            timestamp: current_timestamp(),\n            transactions,\n            previous_hash: previous_block.hash.clone(),\n            hash: String::new(),\n            nonce: 0,\n        };\n        \n        // Mine block (simplified)\n        block.hash = format!(\"block_hash_{}\", block.index);\n        \n        // Update balances\n        for tx in &block.transactions {\n            *self.balances.entry(tx.from.clone()).or_insert(0) -= tx.amount + tx.fee;\n            *self.balances.entry(tx.to.clone()).or_insert(0) += tx.amount;\n        }\n        \n        self.blocks.push(block);\n        Ok(())\n    }\n    \n    fn get_balance(&self, address: &str) -> u64 {\n        self.balances.get(address).copied().unwrap_or(0)\n    }\n    \n    fn height(&self) -> usize {\n        self.blocks.len()\n    }\n}\n```\n\n## Usage Example\n\n```rust\nfn main() {\n    let mut blockchain = Blockchain::new();\n    \n    // Initialize accounts\n    blockchain.balances.insert(String::from(\"0xAlice\"), 1000);\n    blockchain.balances.insert(String::from(\"0xBob\"), 500);\n    \n    // Add transactions\n    blockchain.add_transaction(Transaction {\n        from: String::from(\"0xAlice\"),\n        to: String::from(\"0xBob\"),\n        amount: 100,\n        fee: 10,\n        timestamp: current_timestamp(),\n    }).unwrap();\n    \n    // Mine block\n    blockchain.mine_block(2).unwrap();\n    \n    println!(\"Blockchain height: {}\", blockchain.height());\n    println!(\"Alice balance: {}\", blockchain.get_balance(\"0xAlice\"));\n    println!(\"Bob balance: {}\", blockchain.get_balance(\"0xBob\"));\n}\n```\n\n## Next Steps\n\n- Add cryptographic hashing\n- Implement proper mining\n- Add digital signatures\n- Build P2P networking\n- Create consensus mechanism",
  "difficulty": "advanced",
  "estimatedTime": 60,
  "prerequisites": [
    "lesson-48-blockchain-optimization"
  ],
  "codeExamples": [
    {
      "id": "ex-49-1-complete-blockchain",
      "title": "Complete Blockchain",
      "description": "Full blockchain implementation",
      "code": "use std::collections::HashMap;\nstruct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    fee: u64,\n}\nstruct Block {\n    index: u64,\n    transactions: Vec<Transaction>,\n    previous_hash: String,\n    hash: String,\n}\nstruct Blockchain {\n    blocks: Vec<Block>,\n    balances: HashMap<String, u64>,\n    pending_transactions: Vec<Transaction>,\n}\nimpl Blockchain {\n    fn new() -> Self {\n        let mut chain = Blockchain {\n            blocks: Vec::new(),\n            balances: HashMap::new(),\n            pending_transactions: Vec::new(),\n        };\n        chain.blocks.push(Block {\n            index: 0,\n            transactions: Vec::new(),\n            previous_hash: String::from(\"0\"),\n            hash: String::from(\"genesis\"),\n        });\n        chain\n    }\n    fn add_transaction(&mut self, tx: Transaction) -> Result<(), String> {\n        let balance = self.balances.get(&tx.from).copied().unwrap_or(0);\n        if balance < tx.amount + tx.fee {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        self.pending_transactions.push(tx);\n        Ok(())\n    }\n    fn mine_block(&mut self) -> Result<(), String> {\n        if self.pending_transactions.is_empty() {\n            return Err(String::from(\"No transactions\"));\n        }\n        let transactions = self.pending_transactions.drain(..).collect();\n        let previous = self.blocks.last().unwrap();\n        let block = Block {\n            index: previous.index + 1,\n            transactions,\n            previous_hash: previous.hash.clone(),\n            hash: format!(\"hash_{}\", previous.index + 1),\n        };\n        for tx in &block.transactions {\n            *self.balances.entry(tx.from.clone()).or_insert(0) -= tx.amount + tx.fee;\n            *self.balances.entry(tx.to.clone()).or_insert(0) += tx.amount;\n        }\n        self.blocks.push(block);\n        Ok(())\n    }\n    fn get_balance(&self, address: &str) -> u64 {\n        self.balances.get(address).copied().unwrap_or(0)\n    }\n}\nfn main() {\n    let mut blockchain = Blockchain::new();\n    blockchain.balances.insert(String::from(\"0xAlice\"), 1000);\n    blockchain.balances.insert(String::from(\"0xBob\"), 0);\n    blockchain.add_transaction(Transaction {\n        from: String::from(\"0xAlice\"),\n        to: String::from(\"0xBob\"),\n        amount: 200,\n        fee: 10,\n    }).unwrap();\n    blockchain.mine_block().unwrap();\n    println!(\"Alice: {} tokens\", blockchain.get_balance(\"0xAlice\"));\n    println!(\"Bob: {} tokens\", blockchain.get_balance(\"0xBob\"));\n    println!(\"Blockchain height: {}\", blockchain.blocks.len());\n}",
      "explanation": "This complete blockchain implementation includes transaction processing, block mining, and balance management. It demonstrates how all blockchain concepts work together.",
      "language": "rust"
    },
    {
      "id": "ex-49-2-blockchain-operations",
      "title": "Blockchain Operations",
      "description": "Common blockchain operations",
      "code": "struct Blockchain {\n    blocks: Vec<String>,\n    balances: std::collections::HashMap<String, u64>,\n}\nimpl Blockchain {\n    fn new() -> Self {\n        let mut chain = Blockchain {\n            blocks: vec![String::from(\"genesis\")],\n            balances: std::collections::HashMap::new(),\n        };\n        chain.balances.insert(String::from(\"0xAlice\"), 1000);\n        chain\n    }\n    fn add_block(&mut self, block_hash: String) {\n        self.blocks.push(block_hash);\n    }\n    fn get_latest_block(&self) -> Option<&String> {\n        self.blocks.last()\n    }\n    fn get_chain_length(&self) -> usize {\n        self.blocks.len()\n    }\n    fn verify_chain(&self) -> bool {\n        !self.blocks.is_empty()\n    }\n}\nfn main() {\n    let mut blockchain = Blockchain::new();\n    blockchain.add_block(String::from(\"block1\"));\n    blockchain.add_block(String::from(\"block2\"));\n    println!(\"Chain length: {}\", blockchain.get_chain_length());\n    println!(\"Latest block: {:?}\", blockchain.get_latest_block());\n    println!(\"Chain valid: {}\", blockchain.verify_chain());\n}",
      "explanation": "Common blockchain operations include adding blocks, getting the latest block, checking chain length, and verifying chain integrity. These are fundamental operations for any blockchain node.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-49-1",
      "title": "Build a Simple Blockchain",
      "description": "Create a blockchain that can add blocks and track balances!",
      "starterCode": "use std::collections::HashMap;\nstruct Block {\n    index: u64,\n    hash: String,\n}\nstruct Blockchain {\n    blocks: Vec<Block>,\n    balances: HashMap<String, u64>,\n}\nfn main() {\n    let mut chain = Blockchain::new();\n    chain.balances.insert(String::from(\"0xAlice\"), 1000);\n    chain.add_block(Block { index: 1, hash: String::from(\"hash1\") });\n    println!(\"Alice balance: {}\", chain.get_balance(\"0xAlice\"));\n}",
      "solution": "use std::collections::HashMap;\nstruct Block {\n    index: u64,\n    hash: String,\n}\nstruct Blockchain {\n    blocks: Vec<Block>,\n    balances: HashMap<String, u64>,\n}\nimpl Blockchain {\n    fn new() -> Self {\n        Blockchain {\n            blocks: vec![Block { index: 0, hash: String::from(\"genesis\") }],\n            balances: HashMap::new(),\n        }\n    }\n    fn add_block(&mut self, block: Block) {\n        self.blocks.push(block);\n    }\n    fn get_balance(&self, address: &str) -> u64 {\n        self.balances.get(address).copied().unwrap_or(0)\n    }\n}\nfn main() {\n    let mut chain = Blockchain::new();\n    chain.balances.insert(String::from(\"0xAlice\"), 1000);\n    chain.add_block(Block { index: 1, hash: String::from(\"hash1\") });\n    println!(\"Alice balance: {}\", chain.get_balance(\"0xAlice\"));\n}",
      "hints": [
        "Create genesis block in new()",
        "Use push() to add blocks",
        "Use get() with unwrap_or() for balance"
      ],
      "difficulty": "hard"
    }
  ]
}
