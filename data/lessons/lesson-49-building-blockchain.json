{
  "id": "lesson-49-building-blockchain",
  "title": "Building a Complete Blockchain",
  "description": "Putting it all together: building a functional blockchain from scratch.",
  "content": "# Building a Complete Blockchain\n\nLet's build a complete, functional blockchain that combines all the concepts we've learned!\n\n## Project Structure\n\n```rust\n// Complete blockchain implementation\nuse std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nstruct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    fee: u64,\n    timestamp: u64,\n}\n\nstruct Block {\n    index: u64,\n    timestamp: u64,\n    transactions: Vec<Transaction>,\n    previous_hash: String,\n    hash: String,\n    nonce: u64,\n}\n\nstruct Blockchain {\n    blocks: Vec<Block>,\n    balances: HashMap<String, u64>,\n    pending_transactions: Vec<Transaction>,\n}\n```\n\n## Core Functionality\n\n1. **Genesis Block**: First block in the chain\n2. **Add Transactions**: Add to pending pool\n3. **Mine Block**: Create new block with transactions\n4. **Validate Chain**: Ensure blockchain integrity\n5. **Transfer Funds**: Update balances\n\n## Complete Implementation\n\n```rust\nimpl Blockchain {\n    fn new() -> Self {\n        let mut chain = Blockchain {\n            blocks: Vec::new(),\n            balances: HashMap::new(),\n            pending_transactions: Vec::new(),\n        };\n        \n        // Create genesis block\n        let genesis = Block {\n            index: 0,\n            timestamp: current_timestamp(),\n            transactions: Vec::new(),\n            previous_hash: String::from(\"0\"),\n            hash: String::from(\"genesis\"),\n            nonce: 0,\n        };\n        \n        chain.blocks.push(genesis);\n        chain\n    }\n    \n    fn add_transaction(&mut self, tx: Transaction) -> Result<(), String> {\n        // Validate transaction\n        let balance = self.balances.get(&tx.from).copied().unwrap_or(0);\n        if balance < tx.amount + tx.fee {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        self.pending_transactions.push(tx);\n        Ok(())\n    }\n    \n    fn mine_block(&mut self, difficulty: usize) -> Result<(), String> {\n        if self.pending_transactions.is_empty() {\n            return Err(String::from(\"No transactions to mine\"));\n        }\n        \n        // Take transactions from pool\n        let transactions: Vec<Transaction> = self.pending_transactions.drain(..).collect();\n        \n        // Create block\n        let previous_block = self.blocks.last().unwrap();\n        let mut block = Block {\n            index: previous_block.index + 1,\n            timestamp: current_timestamp(),\n            transactions,\n            previous_hash: previous_block.hash.clone(),\n            hash: String::new(),\n            nonce: 0,\n        };\n        \n        // Mine block (simplified)\n        block.hash = format!(\"block_hash_{}\", block.index);\n        \n        // Update balances\n        for tx in &block.transactions {\n            *self.balances.entry(tx.from.clone()).or_insert(0) -= tx.amount + tx.fee;\n            *self.balances.entry(tx.to.clone()).or_insert(0) += tx.amount;\n        }\n        \n        self.blocks.push(block);\n        Ok(())\n    }\n    \n    fn get_balance(&self, address: &str) -> u64 {\n        self.balances.get(address).copied().unwrap_or(0)\n    }\n    \n    fn height(&self) -> usize {\n        self.blocks.len()\n    }\n}\n```\n\n## Usage Example\n\n```rust\nfn main() {\n    let mut blockchain = Blockchain::new();\n    \n    // Initialize accounts\n    blockchain.balances.insert(String::from(\"0xAlice\"), 1000);\n    blockchain.balances.insert(String::from(\"0xBob\"), 500);\n    \n    // Add transactions\n    blockchain.add_transaction(Transaction {\n        from: String::from(\"0xAlice\"),\n        to: String::from(\"0xBob\"),\n        amount: 100,\n        fee: 10,\n        timestamp: current_timestamp(),\n    }).unwrap();\n    \n    // Mine block\n    blockchain.mine_block(2).unwrap();\n    \n    println!(\"Blockchain height: {}\", blockchain.height());\n    println!(\"Alice balance: {}\", blockchain.get_balance(\"0xAlice\"));\n    println!(\"Bob balance: {}\", blockchain.get_balance(\"0xBob\"));\n}\n```\n\n## Next Steps\n\n- Add cryptographic hashing\n- Implement proper mining\n- Add digital signatures\n- Build P2P networking\n- Create consensus mechanism",
  "difficulty": "advanced",
  "estimatedTime": 60,
  "prerequisites": [
    "lesson-48-blockchain-optimization"
  ],
  "codeExamples": [
    {
      "id": "ex-49-1-complete-blockchain",
      "title": "Complete Blockchain",
      "description": "Full blockchain implementation",
      "code": "use std::collections::HashMap;\nstruct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    fee: u64,\n}\nstruct Block {\n    index: u64,\n    transactions: Vec<Transaction>,\n    previous_hash: String,\n    hash: String,\n}\nstruct Blockchain {\n    blocks: Vec<Block>,\n    balances: HashMap<String, u64>,\n    pending_transactions: Vec<Transaction>,\n}\nimpl Blockchain {\n    fn new() -> Self {\n        let mut chain = Blockchain {\n            blocks: Vec::new(),\n            balances: HashMap::new(),\n            pending_transactions: Vec::new(),\n        };\n        chain.blocks.push(Block {\n            index: 0,\n            transactions: Vec::new(),\n            previous_hash: String::from(\"0\"),\n            hash: String::from(\"genesis\"),\n        });\n        chain\n    }\n    fn add_transaction(&mut self, tx: Transaction) -> Result<(), String> {\n        let balance = self.balances.get(&tx.from).copied().unwrap_or(0);\n        if balance < tx.amount + tx.fee {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        self.pending_transactions.push(tx);\n        Ok(())\n    }\n    fn mine_block(&mut self) -> Result<(), String> {\n        if self.pending_transactions.is_empty() {\n            return Err(String::from(\"No transactions\"));\n        }\n        let transactions = self.pending_transactions.drain(..).collect();\n        let previous = self.blocks.last().unwrap();\n        let block = Block {\n            index: previous.index + 1,\n            transactions,\n            previous_hash: previous.hash.clone(),\n            hash: format!(\"hash_{}\", previous.index + 1),\n        };\n        for tx in &block.transactions {\n            *self.balances.entry(tx.from.clone()).or_insert(0) -= tx.amount + tx.fee;\n            *self.balances.entry(tx.to.clone()).or_insert(0) += tx.amount;\n        }\n        self.blocks.push(block);\n        Ok(())\n    }\n    fn get_balance(&self, address: &str) -> u64 {\n        self.balances.get(address).copied().unwrap_or(0)\n    }\n}\nfn main() {\n    let mut blockchain = Blockchain::new();\n    blockchain.balances.insert(String::from(\"0xAlice\"), 1000);\n    blockchain.balances.insert(String::from(\"0xBob\"), 0);\n    blockchain.add_transaction(Transaction {\n        from: String::from(\"0xAlice\"),\n        to: String::from(\"0xBob\"),\n        amount: 200,\n        fee: 10,\n    }).unwrap();\n    blockchain.mine_block().unwrap();\n    println!(\"Alice: {} tokens\", blockchain.get_balance(\"0xAlice\"));\n    println!(\"Bob: {} tokens\", blockchain.get_balance(\"0xBob\"));\n    println!(\"Blockchain height: {}\", blockchain.blocks.len());\n}",
      "explanation": "This complete blockchain implementation includes transaction processing, block mining, and balance management. It demonstrates how all blockchain concepts work together.",
      "language": "rust"
    },
    {
      "id": "ex-49-2-blockchain-operations",
      "title": "Blockchain Operations",
      "description": "Common blockchain operations",
      "code": "struct Blockchain {\n    blocks: Vec<String>,\n    balances: std::collections::HashMap<String, u64>,\n}\nimpl Blockchain {\n    fn new() -> Self {\n        let mut chain = Blockchain {\n            blocks: vec![String::from(\"genesis\")],\n            balances: std::collections::HashMap::new(),\n        };\n        chain.balances.insert(String::from(\"0xAlice\"), 1000);\n        chain\n    }\n    fn add_block(&mut self, block_hash: String) {\n        self.blocks.push(block_hash);\n    }\n    fn get_latest_block(&self) -> Option<&String> {\n        self.blocks.last()\n    }\n    fn get_chain_length(&self) -> usize {\n        self.blocks.len()\n    }\n    fn verify_chain(&self) -> bool {\n        !self.blocks.is_empty()\n    }\n}\nfn main() {\n    let mut blockchain = Blockchain::new();\n    blockchain.add_block(String::from(\"block1\"));\n    blockchain.add_block(String::from(\"block2\"));\n    println!(\"Chain length: {}\", blockchain.get_chain_length());\n    println!(\"Latest block: {:?}\", blockchain.get_latest_block());\n    println!(\"Chain valid: {}\", blockchain.verify_chain());\n}",
      "explanation": "Common blockchain operations include adding blocks, getting the latest block, checking chain length, and verifying chain integrity. These are fundamental operations for any blockchain node.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-49-1",
      "title": "Build a Simple Blockchain",
      "description": "Create a blockchain that can add blocks and track balances!",
      "starterCode": "use std::collections::HashMap;\nstruct Block {\n    index: u64,\n    hash: String,\n}\nstruct Blockchain {\n    blocks: Vec<Block>,\n    balances: HashMap<String, u64>,\n}\nfn main() {\n    let mut chain = Blockchain::new();\n    chain.balances.insert(String::from(\"0xAlice\"), 1000);\n    chain.add_block(Block { index: 1, hash: String::from(\"hash1\") });\n    println!(\"Alice balance: {}\", chain.get_balance(\"0xAlice\"));\n}",
      "solution": "use std::collections::HashMap;\nstruct Block {\n    index: u64,\n    hash: String,\n}\nstruct Blockchain {\n    blocks: Vec<Block>,\n    balances: HashMap<String, u64>,\n}\nimpl Blockchain {\n    fn new() -> Self {\n        Blockchain {\n            blocks: vec![Block { index: 0, hash: String::from(\"genesis\") }],\n            balances: HashMap::new(),\n        }\n    }\n    fn add_block(&mut self, block: Block) {\n        self.blocks.push(block);\n    }\n    fn get_balance(&self, address: &str) -> u64 {\n        self.balances.get(address).copied().unwrap_or(0)\n    }\n}\nfn main() {\n    let mut chain = Blockchain::new();\n    chain.balances.insert(String::from(\"0xAlice\"), 1000);\n    chain.add_block(Block { index: 1, hash: String::from(\"hash1\") });\n    println!(\"Alice balance: {}\", chain.get_balance(\"0xAlice\"));\n}",
      "hints": [
        "Create genesis block in new()",
        "Use push() to add blocks",
        "Use get() with unwrap_or() for balance"
      ],
      "difficulty": "hard"
    }
  ],
  "projectIdeas": [
    {
      "id": "project-49-1",
      "title": "Complete Cryptocurrency Implementation",
      "description": "Build a full-featured cryptocurrency from scratch. Implement transactions, mining, balance tracking, and blockchain validation.",
      "difficulty": "hard",
      "estimatedTime": 20,
      "requirements": [
        "Complete blockchain with genesis block",
        "Transaction system with validation",
        "Balance tracking for multiple accounts",
        "Block mining functionality",
        "Transaction pool management",
        "Chain validation and integrity checks",
        "CLI interface for interactions"
      ],
      "hints": [
        "Start with basic structures, then add features incrementally",
        "Use HashMap for balance tracking",
        "Implement proper error handling",
        "Test each component separately"
      ],
      "extensions": [
        "Add cryptographic hashing (SHA-256)",
        "Implement Proof of Work mining",
        "Add digital signatures for transactions",
        "Create persistence (save/load blockchain)",
        "Add network support (P2P)",
        "Implement wallet functionality",
        "Add transaction history",
        "Create a simple GUI"
      ],
      "learningOutcomes": [
        "Master complete blockchain implementation",
        "Understand transaction processing",
        "Learn state management",
        "Practice with complex data structures",
        "Implement real-world blockchain features"
      ]
    },
    {
      "id": "project-49-2",
      "title": "Multi-Token Blockchain Platform",
      "description": "Create a blockchain that supports multiple token types. Each token has its own supply, balances, and transactions.",
      "difficulty": "hard",
      "estimatedTime": 15,
      "requirements": [
        "Support multiple token types",
        "Separate balance tracking per token",
        "Token-specific transactions",
        "Token creation/minting",
        "Cross-token operations",
        "Token metadata (name, symbol, decimals)"
      ],
      "hints": [
        "Use nested HashMaps: address -> token -> balance",
        "Create Token struct with metadata",
        "Separate transaction types per token",
        "Track total supply per token"
      ],
      "extensions": [
        "Add token transfer between users",
        "Implement token burning",
        "Add token exchange functionality",
        "Create token registry",
        "Support custom token creation",
        "Add token statistics"
      ],
      "learningOutcomes": [
        "Understand multi-asset systems",
        "Practice with complex data modeling",
        "Learn token economics",
        "Implement flexible blockchain design"
      ]
    },
    {
      "id": "project-49-3",
      "title": "Blockchain with Smart Contract Support",
      "description": "Extend your blockchain to support simple smart contracts. Allow users to deploy contracts and execute them.",
      "difficulty": "hard",
      "estimatedTime": 25,
      "requirements": [
        "Contract deployment functionality",
        "Contract storage system",
        "Contract execution engine",
        "Contract state management",
        "Contract interaction (call functions)",
        "Gas metering system"
      ],
      "hints": [
        "Create Contract struct with code and storage",
        "Use HashMap for contract storage",
        "Implement simple VM or interpreter",
        "Track gas usage per operation"
      ],
      "extensions": [
        "Add more contract operations",
        "Implement contract events",
        "Add contract upgradeability",
        "Support contract-to-contract calls",
        "Add contract verification",
        "Implement contract templates"
      ],
      "learningOutcomes": [
        "Understand smart contract architecture",
        "Learn virtual machine concepts",
        "Practice with execution engines",
        "Master state management for contracts"
      ]
    },
    {
      "id": "project-49-4",
      "title": "Blockchain Analytics Dashboard",
      "description": "Build a dashboard that analyzes blockchain data. Display statistics, transaction patterns, and network health metrics.",
      "difficulty": "medium",
      "estimatedTime": 10,
      "requirements": [
        "Calculate blockchain statistics (height, total transactions)",
        "Track transaction volume over time",
        "Analyze account activity",
        "Display top accounts by balance",
        "Calculate average block time",
        "Show transaction fee statistics"
      ],
      "hints": [
        "Iterate through blocks to collect data",
        "Use aggregations for statistics",
        "Track metrics over time",
        "Format output nicely"
      ],
      "extensions": [
        "Add visualization (ASCII charts)",
        "Export data to CSV/JSON",
        "Add time-based filtering",
        "Implement caching for performance",
        "Add real-time updates",
        "Create web API for data access"
      ],
      "learningOutcomes": [
        "Learn data analysis techniques",
        "Practice with aggregations",
        "Understand blockchain metrics",
        "Work with time-series data"
      ]
    }
  ]
}
