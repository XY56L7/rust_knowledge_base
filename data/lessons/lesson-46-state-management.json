{
  "id": "lesson-46-state-management",
  "title": "State Management",
  "description": "Managing blockchain state efficiently and securely.",
  "content": "# State Management\n\n**State management** is crucial for blockchain performance. The state represents the current snapshot of all accounts, balances, and contract data.\n\n## State Structure\n\n```rust\nstruct BlockchainState {\n    accounts: HashMap<String, Account>,\n    contracts: HashMap<String, ContractState>,\n    balances: HashMap<String, u64>,\n    nonces: HashMap<String, u64>,\n}\n\nstruct Account {\n    address: String,\n    balance: u64,\n    nonce: u64,\n    code: Option<Vec<u8>>,\n}\n```\n\n## State Updates\n\nState changes when:\n\n- **Transactions**: Transfer funds, call contracts\n- **Blocks**: Apply all transactions in block\n- **Reorganizations**: Revert and reapply on fork\n\n## State Trie (Merkle Patricia Tree)\n\nEthereum uses a Merkle Patricia Tree:\n\n- **Efficient**: O(log n) lookups\n- **Verifiable**: Root hash proves state\n- **Incremental**: Only changed nodes updated\n\n## State Caching\n\n```rust\nstruct StateCache {\n    cache: HashMap<String, Account>,\n    dirty: HashSet<String>,\n}\n\nimpl StateCache {\n    fn get_account(&mut self, address: &str) -> Option<&Account> {\n        // Check cache first\n        // If miss, load from storage\n    }\n    \n    fn commit(&mut self) {\n        // Write dirty accounts to storage\n    }\n}\n```\n\n## State Snapshots\n\n- **Checkpoints**: Save state at certain heights\n- **Rollback**: Revert to previous state\n- **Fork handling**: Switch states on reorganization\n\n## Storage Backends\n\n- **In-memory**: Fast but limited size\n- **Database**: Persistent storage (RocksDB, etc.)\n- **Hybrid**: Hot data in memory, cold in DB\n\n## Gas Optimization\n\n- **Minimize storage**: Use storage efficiently\n- **Batch updates**: Group state changes\n- **Cache reads**: Avoid repeated storage access",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": ["lesson-15-hashmaps"],
  "codeExamples": [
    {
      "id": "ex-46-1-state-structure",
      "title": "State Structure",
      "description": "Basic blockchain state structure",
      "code": "use std::collections::HashMap;\n\nstruct Account {\n    address: String,\n    balance: u64,\n    nonce: u64,\n}\n\nstruct BlockchainState {\n    accounts: HashMap<String, Account>,\n}\n\nimpl BlockchainState {\n    fn new() -> Self {\n        BlockchainState {\n            accounts: HashMap::new(),\n        }\n    }\n    \n    fn get_account(&self, address: &str) -> Option<&Account> {\n        self.accounts.get(address)\n    }\n    \n    fn create_account(&mut self, address: String, initial_balance: u64) {\n        self.accounts.insert(address.clone(), Account {\n            address,\n            balance: initial_balance,\n            nonce: 0,\n        });\n    }\n    \n    fn update_balance(&mut self, address: &str, new_balance: u64) -> Result<(), String> {\n        if let Some(account) = self.accounts.get_mut(address) {\n            account.balance = new_balance;\n            Ok(())\n        } else {\n            Err(String::from(\"Account not found\"))\n        }\n    }\n}\n\nfn main() {\n    let mut state = BlockchainState::new();\n    \n    state.create_account(String::from(\"0xAlice\"), 1000);\n    state.update_balance(\"0xAlice\", 1500).unwrap();\n    \n    if let Some(account) = state.get_account(\"0xAlice\") {\n        println!(\"Balance: {}\", account.balance);\n    }\n}",
      "explanation": "Blockchain state maintains account information. It's updated when transactions are processed and must be efficiently stored and retrieved.",
      "language": "rust"
    },
    {
      "id": "ex-46-2-state-cache",
      "title": "State Cache",
      "description": "Caching state for performance",
      "code": "use std::collections::{HashMap, HashSet};\n\nstruct Account {\n    balance: u64,\n}\n\nstruct StateCache {\n    cache: HashMap<String, Account>,\n    dirty: HashSet<String>,\n}\n\nimpl StateCache {\n    fn new() -> Self {\n        StateCache {\n            cache: HashMap::new(),\n            dirty: HashSet::new(),\n        }\n    }\n    \n    fn get(&mut self, address: &str) -> Option<&Account> {\n        // In real implementation: load from storage if not in cache\n        self.cache.get(address)\n    }\n    \n    fn set(&mut self, address: String, account: Account) {\n        self.cache.insert(address.clone(), account);\n        self.dirty.insert(address);\n    }\n    \n    fn commit(&mut self) {\n        println!(\"Committing {} dirty accounts\", self.dirty.len());\n        // In real implementation: write to persistent storage\n        self.dirty.clear();\n    }\n}\n\nfn main() {\n    let mut cache = StateCache::new();\n    \n    cache.set(String::from(\"0xAlice\"), Account { balance: 1000 });\n    cache.set(String::from(\"0xBob\"), Account { balance: 500 });\n    \n    cache.commit();\n}",
      "explanation": "State caching improves performance by keeping frequently accessed data in memory. Dirty tracking ensures only changed data is written to storage.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-46-1",
      "title": "State Management",
      "description": "Create a state structure that manages accounts!",
      "starterCode": "use std::collections::HashMap;\n\nstruct Account {\n    balance: u64,\n}\n\nstruct State {\n    accounts: HashMap<String, Account>,\n}\n\n// Implement new(), add_account(), and get_balance()\n\nfn main() {\n    let mut state = State::new();\n    state.add_account(String::from(\"Alice\"), 1000);\n    println!(\"Balance: {}\", state.get_balance(\"Alice\"));\n}",
      "solution": "use std::collections::HashMap;\n\nstruct Account {\n    balance: u64,\n}\n\nstruct State {\n    accounts: HashMap<String, Account>,\n}\n\nimpl State {\n    fn new() -> Self {\n        State {\n            accounts: HashMap::new(),\n        }\n    }\n    \n    fn add_account(&mut self, address: String, balance: u64) {\n        self.accounts.insert(address, Account { balance });\n    }\n    \n    fn get_balance(&self, address: &str) -> u64 {\n        self.accounts.get(address)\n            .map(|acc| acc.balance)\n            .unwrap_or(0)\n    }\n}\n\nfn main() {\n    let mut state = State::new();\n    state.add_account(String::from(\"Alice\"), 1000);\n    println!(\"Balance: {}\", state.get_balance(\"Alice\"));\n}",
      "hints": [
        "Use HashMap to store accounts",
        "Use map() and unwrap_or() for get_balance"
      ],
      "difficulty": "medium"
    }
  ]
}

