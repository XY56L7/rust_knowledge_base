{
  "id": "lesson-64-frontend-integration",
  "title": "Frontend Integration",
  "description": "Integrating Rust backends with frontend applications and full-stack Rust.",
  "content": "# Frontend Integration\n\nRust backends can integrate with various frontend technologies, and Rust can also be used for frontend development.\n\n## Backend + Frontend Architecture\n\n### Traditional: Rust API + JavaScript Frontend\n\n```\nFrontend (React/Vue/Angular)\n    ↓ HTTP/REST\nRust Backend (Axum/Actix)\n    ↓\nDatabase\n```\n\n### Full-Stack Rust\n\n```\nFrontend (Yew/Leptos/Dioxus)\n    ↓ HTTP/WebSocket\nRust Backend (Axum/Actix)\n    ↓\nDatabase\n```\n\n## Rust Backend for Frontend\n\n### CORS Configuration\n\n```rust\n// src/api/middleware/cors.rs\nuse tower_http::cors::{CorsLayer, Any, AllowOrigin};\n\npub fn cors_layer() -> CorsLayer {\n    CorsLayer::new()\n        .allow_origin(Any)\n        .allow_methods(Any)\n        .allow_headers(Any)\n        .allow_credentials(true)\n}\n\n// In main.rs\nlet app = Router::new()\n    .route(\"/api/users\", get(get_users))\n    .layer(cors_layer());\n```\n\n### API Structure for Frontend\n\n```rust\n// src/api/routes.rs\npub fn create_router() -> Router {\n    Router::new()\n        .nest(\"/api/v1\", api_v1_routes())\n        .layer(cors_layer())\n}\n\nfn api_v1_routes() -> Router {\n    Router::new()\n        .route(\"/users\", get(get_users).post(create_user))\n        .route(\"/users/:id\", get(get_user).put(update_user))\n        .route(\"/auth/login\", post(login))\n        .route(\"/auth/register\", post(register))\n}\n```\n\n### WebSocket Support\n\n```rust\n// src/api/websocket.rs\nuse axum::extract::ws::{WebSocket, Message};\n\npub async fn websocket_handler(socket: WebSocket) {\n    let (mut sender, mut receiver) = socket.split();\n    \n    while let Some(msg) = receiver.next().await {\n        match msg {\n            Ok(Message::Text(text)) => {\n                // Handle message from frontend\n                sender.send(Message::Text(\"Response\".to_string())).await;\n            }\n            Ok(Message::Close(_)) => break,\n            _ => {}\n        }\n    }\n}\n\n// In routes\n.route(\"/ws\", get(websocket_handler))\n```\n\n## Rust Frontend Frameworks\n\n### 1. Yew (React-like)\n\n```toml\n[dependencies]\nyew = \"0.21\"\nwasm-bindgen = \"0.2\"\n```\n\n```rust\n// src/lib.rs\nuse yew::prelude::*;\n\n#[function_component]\nfn App() -> Html {\n    let counter = use_state(|| 0);\n    \n    let increment = {\n        let counter = counter.clone();\n        Callback::from(move |_| counter.set(*counter + 1))\n    };\n    \n    html! {\n        <div>\n            <p>{ *counter }</p>\n            <button onclick={increment}>{ \"Increment\" }</button>\n        </div>\n    }\n}\n\n#[wasm_bindgen::prelude::wasm_bindgen(start)]\npub fn main() {\n    yew::Renderer::<App>::new().render();\n}\n```\n\n### 2. Leptos (Modern, Fast)\n\n```toml\n[dependencies]\nleptos = \"0.6\"\nleptos_axum = \"0.6\"\n```\n\n```rust\n// src/lib.rs\nuse leptos::*;\n\n#[component]\nfn App() -> impl IntoView {\n    let (count, set_count) = create_signal(0);\n    \n    view! {\n        <div>\n            <p>{count}</p>\n            <button on:click=move |_| set_count.update(|n| *n += 1)>\n                \"Increment\"\n            </button>\n        </div>\n    }\n}\n```\n\n### 3. Dioxus (Cross-platform)\n\n```toml\n[dependencies]\ndioxus = \"0.5\"\n```\n\n```rust\n// src/main.rs\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus::launch(App);\n}\n\nfn App() -> Element {\n    let mut count = use_signal(|| 0);\n    \n    rsx! {\n        div {\n            p { \"Count: {count}\" }\n            button { onclick: move |_| count += 1, \"Increment\" }\n        }\n    }\n}\n```\n\n## Full-Stack Rust Project Structure\n\n```\nfullstack-rust/\n├── Cargo.toml              # Workspace\n├── backend/\n│   ├── Cargo.toml\n│   └── src/\n│       ├── main.rs\n│       ├── api/\n│       └── services/\n├── frontend/\n│   ├── Cargo.toml\n│   └── src/\n│       └── lib.rs\n└── shared/\n    ├── Cargo.toml          # Shared types\n    └── src/\n        └── lib.rs\n```\n\n## Shared Types\n\n```rust\n// shared/src/lib.rs\nuse serde::{Serialize, Deserialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    pub id: u64,\n    pub email: String,\n    pub name: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CreateUserRequest {\n    pub email: String,\n    pub name: String,\n}\n```\n\n## Frontend-Backend Communication\n\n```rust\n// frontend/src/api.rs\nuse wasm_bindgen_futures::spawn_local;\nuse gloo_net::http::Request;\n\npub async fn fetch_users() -> Result<Vec<User>, Error> {\n    let response = Request::get(\"http://localhost:3000/api/users\")\n        .send()\n        .await?;\n    response.json().await\n}\n\n// In component\nlet users = use_state(|| Vec::new());\n\nuse_effect(move || {\n    spawn_local(async move {\n        if let Ok(fetched_users) = fetch_users().await {\n            users.set(fetched_users);\n        }\n    });\n});\n```\n\n## Deployment Architecture\n\n### Development\n\n```\nFrontend (localhost:8080)\n    ↓\nBackend (localhost:3000)\n    ↓\nDatabase\n```\n\n### Production\n\n```\nCDN/Static Hosting (Frontend)\n    ↓ HTTPS\nLoad Balancer\n    ↓\nRust Backend (Multiple Instances)\n    ↓\nDatabase Cluster\n```\n\n## Best Practices\n\n- **API versioning**: Version your APIs\n- **Type safety**: Share types between frontend/backend\n- **Error handling**: Consistent error responses\n- **Authentication**: JWT tokens, secure cookies\n- **CORS**: Configure properly for production\n- **WebSocket**: For real-time features\n- **SSR**: Server-side rendering for SEO (Leptos supports this)\n- **Build optimization**: Optimize WASM bundle size",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": ["lesson-62-api-architecture"],
  "codeExamples": [
    {
      "id": "ex-64-1-fullstack-structure",
      "title": "Full-Stack Structure",
      "description": "Organizing full-stack Rust project",
      "code": "// Full-stack Rust project structure\n\n// workspace/Cargo.toml\n// [workspace]\n// members = [\"backend\", \"frontend\", \"shared\"]\n\n// backend/src/main.rs\n// - Axum/Actix server\n// - REST API\n// - Database\n\n// frontend/src/lib.rs\n// - Yew/Leptos/Dioxus app\n// - Calls backend API\n// - Shared types from shared crate\n\n// shared/src/lib.rs\n// - Common types\n// - Serialize/Deserialize\n// - Used by both frontend and backend\n\nfn main() {\n    println!(\"Full-stack Rust:\");\n    println!(\"- Backend: API server\");\n    println!(\"- Frontend: WebAssembly\");\n    println!(\"- Shared: Common types\");\n}",
      "explanation": "Full-stack Rust projects use a workspace with separate crates for backend, frontend, and shared code. This enables type safety across the stack.",
      "language": "rust"
    },
    {
      "id": "ex-64-2-api-integration",
      "title": "Frontend-Backend Integration",
      "description": "Frontend calling Rust backend",
      "code": "// Frontend calling backend API\n\n// In Yew component:\n// use gloo_net::http::Request;\n// \n// async fn fetch_data() -> Result<Vec<User>, Error> {\n//     let response = Request::get(\"http://localhost:3000/api/users\")\n//         .send()\n//         .await?;\n//     response.json().await\n// }\n\n// Backend endpoint:\n// async fn get_users() -> Json<Vec<User>> {\n//     Json(vec![User { id: 1, name: String::from(\"User\") }])\n// }\n\nstruct User {\n    id: u64,\n    name: String,\n}\n\nfn main() {\n    println!(\"Frontend-Backend integration:\");\n    println!(\"- Frontend makes HTTP requests\");\n    println!(\"- Backend returns JSON\");\n    println!(\"- Shared types ensure type safety\");\n}",
      "explanation": "Frontend and backend communicate via HTTP. Shared types ensure both sides use the same data structures, providing compile-time type safety.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-64-1",
      "title": "Shared Type",
      "description": "Create a shared User type that can be used by both frontend and backend!",
      "starterCode": "// Create a User struct with:\n// - id: u64\n// - name: String\n// - email: String\n// \n// Make it serializable with serde\n\nfn main() {\n    println!(\"Shared type created!\");\n}",
      "solution": "use serde::{Serialize, Deserialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    pub id: u64,\n    pub name: String,\n    pub email: String,\n}\n\nfn main() {\n    println!(\"Shared type created!\");\n}",
      "hints": [
        "Use serde Serialize and Deserialize",
        "Make fields public with pub"
      ],
      "difficulty": "easy"
    }
  ]
}

