{
  "id": "lesson-82-advanced-cryptography",
  "title": "Advanced Cryptography: Multi-Sig, Threshold Signatures, Ring Signatures",
  "description": "Implementing advanced cryptographic schemes: multi-signature wallets, threshold signatures (Schnorr, BLS), and ring signatures.",
  "content": "# Advanced Cryptography: Multi-Sig, Threshold Signatures, Ring Signatures\n\nAdvanced cryptographic schemes for enhanced security and privacy.\n\n## Multi-Signature Wallets\n\n**Multi-sig** requires multiple signatures to authorize a transaction.\n\n### Implementation\n\n```rust\nstruct MultiSigWallet {\n    owners: Vec<String>,\n    threshold: usize, // Minimum signatures required\n    nonce: u64,\n}\n\nstruct Signature {\n    signer: String,\n    signature: Vec<u8>,\n}\n\nstruct Transaction {\n    to: String,\n    amount: u64,\n    nonce: u64,\n    signatures: Vec<Signature>,\n}\n\nimpl MultiSigWallet {\n    fn new(owners: Vec<String>, threshold: usize) -> Self {\n        if threshold > owners.len() || threshold == 0 {\n            panic!(\"Invalid threshold\");\n        }\n        \n        MultiSigWallet {\n            owners,\n            threshold,\n            nonce: 0,\n        }\n    }\n    \n    fn create_transaction(\n        &mut self,\n        to: String,\n        amount: u64,\n    ) -> Transaction {\n        let tx = Transaction {\n            to,\n            amount,\n            nonce: self.nonce,\n            signatures: Vec::new(),\n        };\n        \n        self.nonce += 1;\n        tx\n    }\n    \n    fn add_signature(\n        &mut self,\n        tx: &mut Transaction,\n        signer: &str,\n        signature: Vec<u8>,\n    ) -> Result<(), String> {\n        // Verify signer is owner\n        if !self.owners.contains(&signer.to_string()) {\n            return Err(String::from(\"Not an owner\"));\n        }\n        \n        // Verify not already signed\n        if tx.signatures.iter().any(|s| s.signer == signer) {\n            return Err(String::from(\"Already signed\"));\n        }\n        \n        // Verify signature (simplified)\n        if !self.verify_signature(tx, signer, &signature) {\n            return Err(String::from(\"Invalid signature\"));\n        }\n        \n        tx.signatures.push(Signature {\n            signer: signer.to_string(),\n            signature,\n        });\n        \n        Ok(())\n    }\n    \n    fn execute_transaction(&self, tx: &Transaction) -> Result<(), String> {\n        // Check threshold\n        if tx.signatures.len() < self.threshold {\n            return Err(format!(\"Need {} signatures, got {}\", \n                             self.threshold, tx.signatures.len()));\n        }\n        \n        // Verify all signatures are from owners\n        for sig in &tx.signatures {\n            if !self.owners.contains(&sig.signer) {\n                return Err(String::from(\"Invalid signer\"));\n            }\n        }\n        \n        // Execute transaction\n        Ok(())\n    }\n    \n    fn verify_signature(\n        &self,\n        tx: &Transaction,\n        signer: &str,\n        signature: &[u8],\n    ) -> bool {\n        // In real implementation: verify cryptographic signature\n        // Simplified: just check signature is not empty\n        !signature.is_empty()\n    }\n}\n```\n\n## Threshold Signatures\n\n**Threshold signatures** allow a group to sign with only a subset (threshold) of members.\n\n### Schnorr Signatures\n\n```rust\n// Simplified Schnorr threshold signature concept\nstruct SchnorrKeyShare {\n    public_key: Vec<u8>,\n    secret_share: Vec<u8>, // Secret share (never revealed)\n    index: usize,\n}\n\nstruct SchnorrThresholdSig {\n    threshold: usize,\n    total: usize,\n    public_key: Vec<u8>, // Aggregate public key\n    key_shares: Vec<SchnorrKeyShare>,\n}\n\nimpl SchnorrThresholdSig {\n    fn generate_shares(threshold: usize, total: usize) -> Vec<SchnorrKeyShare> {\n        // Generate secret shares using Shamir's Secret Sharing\n        // Each participant gets one share\n        // Need 'threshold' shares to reconstruct\n        \n        vec![] // Simplified\n    }\n    \n    fn sign_with_shares(\n        &self,\n        message: &[u8],\n        shares: &[SchnorrKeyShare],\n    ) -> Result<Vec<u8>, String> {\n        if shares.len() < self.threshold {\n            return Err(String::from(\"Insufficient shares\"));\n        }\n        \n        // Combine signatures from shares\n        // Create aggregate signature\n        \n        Ok(vec![]) // Simplified\n    }\n    \n    fn verify(\n        &self,\n        message: &[u8],\n        signature: &[u8],\n    ) -> bool {\n        // Verify aggregate signature against aggregate public key\n        true // Simplified\n    }\n}\n```\n\n### BLS Signatures\n\n```rust\n// BLS (Boneh-Lynn-Shacham) signatures support aggregation\nstruct BLSSignature {\n    signature: Vec<u8>,\n    public_key: Vec<u8>,\n}\n\nstruct BLSAggregator {\n    signatures: Vec<BLSSignature>,\n}\n\nimpl BLSAggregator {\n    fn aggregate(&self) -> Vec<u8> {\n        // BLS signatures can be aggregated\n        // Aggregate signature is same size as single signature\n        // Very efficient for multi-sig\n        \n        vec![] // Simplified\n    }\n    \n    fn verify_aggregate(\n        &self,\n        message: &[u8],\n        aggregate_sig: &[u8],\n        public_keys: &[Vec<u8>],\n    ) -> bool {\n        // Verify aggregate signature against all public keys\n        true // Simplified\n    }\n}\n```\n\n## Ring Signatures\n\n**Ring signatures** provide anonymity by signing with a group without revealing which member signed.\n\n```rust\nstruct RingMember {\n    public_key: Vec<u8>,\n    index: usize,\n}\n\nstruct RingSignature {\n    ring: Vec<RingMember>,\n    signature: Vec<u8>,\n    message: Vec<u8>,\n}\n\nimpl RingSignature {\n    fn sign(\n        message: &[u8],\n        signer_private_key: &[u8],\n        ring: Vec<RingMember>,\n    ) -> RingSignature {\n        // Create signature that proves:\n        // 1. Someone in the ring signed\n        // 2. But doesn't reveal who\n        \n        RingSignature {\n            ring,\n            signature: vec![], // Simplified\n            message: message.to_vec(),\n        }\n    }\n    \n    fn verify(&self) -> bool {\n        // Verify signature is valid\n        // But cannot determine which ring member signed\n        true // Simplified\n    }\n}\n```\n\n## Homomorphic Encryption\n\n**Homomorphic encryption** allows computation on encrypted data without decrypting.\n\n### Concept\n\n```rust\n// Simplified homomorphic encryption concept\nstruct EncryptedValue {\n    ciphertext: Vec<u8>,\n    public_key: Vec<u8>,\n}\n\nstruct HomomorphicEncryption {\n    // Supports operations on encrypted data\n}\n\nimpl HomomorphicEncryption {\n    fn encrypt(&self, value: u64, public_key: &[u8]) -> EncryptedValue {\n        // Encrypt value\n        EncryptedValue {\n            ciphertext: vec![], // Simplified\n            public_key: public_key.to_vec(),\n        }\n    }\n    \n    fn add_encrypted(\n        &self,\n        a: &EncryptedValue,\n        b: &EncryptedValue,\n    ) -> EncryptedValue {\n        // Add encrypted values without decrypting\n        // Result is encryption of (a + b)\n        EncryptedValue {\n            ciphertext: vec![], // Simplified\n            public_key: a.public_key.clone(),\n        }\n    }\n    \n    fn decrypt(&self, encrypted: &EncryptedValue, private_key: &[u8]) -> u64 {\n        // Decrypt to get result\n        0 // Simplified\n    }\n}\n```\n\n## Use Cases\n\n### Multi-Sig\n\n- **Treasury Management**: Require multiple approvals\n- **DAO Governance**: Multi-sig for proposals\n- **Exchange Security**: Cold wallet multi-sig\n\n### Threshold Signatures\n\n- **Distributed Validators**: Validator key split across nodes\n- **Custody Solutions**: Shared custody without single point of failure\n- **Consensus**: BFT consensus with threshold signatures\n\n### Ring Signatures\n\n- **Privacy Coins**: Monero uses ring signatures\n- **Anonymous Voting**: Vote without revealing identity\n- **Whistleblowing**: Prove membership without revealing identity\n\n### Homomorphic Encryption\n\n- **Private Computation**: Compute on encrypted data\n- **Zero-Knowledge Proofs**: Used in some ZKP schemes\n- **Secure Multi-Party Computation**: Privacy-preserving computation\n\n## Real-World Examples\n\n- **Gnosis Safe**: Multi-sig wallet\n- **Monero**: Ring signatures for privacy\n- **Ethereum 2.0**: BLS signatures for validators\n- **Zcash**: Uses homomorphic encryption concepts\n\n## Security Considerations\n\n- **Key Management**: Secure storage of private keys\n- **Threshold Selection**: Balance security vs. usability\n- **Signature Verification**: Always verify before execution\n- **Key Rotation**: Ability to rotate compromised keys",
  "difficulty": "advanced",
  "estimatedTime": 60,
  "prerequisites": [
    "lesson-34-digital-signatures",
    "lesson-36-elliptic-curves"
  ],
  "codeExamples": [
    {
      "id": "ex-82-1-multisig",
      "title": "Multi-Signature Wallet",
      "description": "Basic multi-sig implementation",
      "code": "use std::collections::HashSet;\n\nstruct Transaction {\n    to: String,\n    amount: u64,\n    nonce: u64,\n    signers: HashSet<String>,\n}\n\nstruct MultiSigWallet {\n    owners: Vec<String>,\n    threshold: usize,\n    nonce: u64,\n}\n\nimpl MultiSigWallet {\n    fn new(owners: Vec<String>, threshold: usize) -> Self {\n        if threshold > owners.len() || threshold == 0 {\n            panic!(\"Invalid threshold\");\n        }\n        \n        MultiSigWallet {\n            owners,\n            threshold,\n            nonce: 0,\n        }\n    }\n    \n    fn create_transaction(&mut self, to: String, amount: u64) -> Transaction {\n        let tx = Transaction {\n            to,\n            amount,\n            nonce: self.nonce,\n            signers: HashSet::new(),\n        };\n        \n        self.nonce += 1;\n        tx\n    }\n    \n    fn sign_transaction(\n        &self,\n        tx: &mut Transaction,\n        signer: &str,\n    ) -> Result<(), String> {\n        if !self.owners.contains(&signer.to_string()) {\n            return Err(String::from(\"Not an owner\"));\n        }\n        \n        if tx.signers.contains(signer) {\n            return Err(String::from(\"Already signed\"));\n        }\n        \n        tx.signers.insert(signer.to_string());\n        Ok(())\n    }\n    \n    fn can_execute(&self, tx: &Transaction) -> bool {\n        tx.signers.len() >= self.threshold\n    }\n    \n    fn execute(&self, tx: &Transaction) -> Result<(), String> {\n        if !self.can_execute(tx) {\n            return Err(format!(\"Need {} signatures, got {}\", \n                             self.threshold, tx.signers.len()));\n        }\n        \n        // Verify all signers are owners\n        for signer in &tx.signers {\n            if !self.owners.contains(signer) {\n                return Err(String::from(\"Invalid signer\"));\n            }\n        }\n        \n        println!(\"Executing transaction: {} to {}, amount: {}\", \n                tx.nonce, tx.to, tx.amount);\n        \n        Ok(())\n    }\n}\n\nfn main() {\n    let owners = vec![\n        String::from(\"alice\"),\n        String::from(\"bob\"),\n        String::from(\"charlie\"),\n    ];\n    \n    let mut wallet = MultiSigWallet::new(owners, 2); // 2 of 3\n    \n    let mut tx = wallet.create_transaction(String::from(\"0xRecipient\"), 1000);\n    \n    // Sign with 2 owners\n    wallet.sign_transaction(&mut tx, \"alice\").unwrap();\n    wallet.sign_transaction(&mut tx, \"bob\").unwrap();\n    \n    // Execute (has 2/3 signatures)\n    wallet.execute(&tx).unwrap();\n    \n    println!(\"Multi-sig transaction executed successfully!\");\n}",
      "explanation": "Multi-sig wallets require multiple signatures to authorize transactions. This provides security: even if one key is compromised, the wallet is still secure. Common setups are 2-of-3 or 3-of-5.",
      "language": "rust"
    },
    {
      "id": "ex-82-2-threshold-concept",
      "title": "Threshold Signature Concept",
      "description": "Conceptual threshold signature system",
      "code": "// Simplified threshold signature concept\nstruct KeyShare {\n    index: usize,\n    public_share: Vec<u8>,\n    // secret_share is never stored, only known to participant\n}\n\nstruct ThresholdSignature {\n    threshold: usize,\n    total: usize,\n    public_key: Vec<u8>, // Aggregate public key\n    key_shares: Vec<KeyShare>,\n}\n\nimpl ThresholdSignature {\n    fn new(threshold: usize, total: usize) -> Self {\n        ThresholdSignature {\n            threshold,\n            total,\n            public_key: vec![], // Generated from shares\n            key_shares: vec![],\n        }\n    }\n    \n    fn can_sign(&self, shares_available: usize) -> bool {\n        shares_available >= self.threshold\n    }\n    \n    fn aggregate_signature(&self, partial_signatures: &[Vec<u8>]) -> Vec<u8> {\n        // Combine partial signatures into full signature\n        // Need exactly 'threshold' partial signatures\n        \n        if partial_signatures.len() < self.threshold {\n            panic!(\"Insufficient signatures\");\n        }\n        \n        // In real implementation: use cryptographic aggregation\n        vec![] // Simplified aggregate signature\n    }\n    \n    fn verify(&self, message: &[u8], signature: &[u8]) -> bool {\n        // Verify signature against aggregate public key\n        // Doesn't reveal which participants signed\n        true // Simplified\n    }\n}\n\nfn main() {\n    // 3-of-5 threshold signature\n    let threshold_sig = ThresholdSignature::new(3, 5);\n    \n    println!(\"Threshold: {}/{}\", threshold_sig.threshold, threshold_sig.total);\n    println!(\"Need {} signatures to create valid signature\", threshold_sig.threshold);\n    println!(\"Even if 2 participants are compromised, wallet is secure!\");\n}",
      "explanation": "Threshold signatures allow a group to sign with only a subset of members. The private key is split into shares. Need 'threshold' shares to sign, but no single person has the full key. More secure than multi-sig.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-82-1",
      "title": "Multi-Sig Check",
      "description": "Check if transaction has enough signatures!",
      "starterCode": "struct Transaction {\n    signers: Vec<String>,\n}\n\nfn can_execute(tx: &Transaction, threshold: usize) -> bool {\n    // Check if enough signatures\n}",
      "solution": "struct Transaction {\n    signers: Vec<String>,\n}\n\nfn can_execute(tx: &Transaction, threshold: usize) -> bool {\n    tx.signers.len() >= threshold\n}\n\nfn main() {\n    let tx = Transaction {\n        signers: vec![String::from(\"alice\"), String::from(\"bob\")],\n    };\n    \n    println!(\"Can execute with threshold 2: {}\", can_execute(&tx, 2));\n    println!(\"Can execute with threshold 3: {}\", can_execute(&tx, 3));\n}",
      "hints": [
        "Check if signers.len() >= threshold",
        "Return boolean"
      ],
      "difficulty": "easy"
    }
  ]
}

