{
  "id": "lesson-61-clean-architecture",
  "title": "Clean Architecture",
  "description": "Implementing Clean Architecture principles in Rust for maintainable applications.",
  "content": "# Clean Architecture\n\n**Clean Architecture** organizes code into concentric layers with dependencies pointing inward toward the domain.\n\n## Architecture Layers\n\n### 1. Domain Layer (Core)\n\n**Innermost layer** - Pure business logic, no dependencies\n\n```rust\n// src/domain/mod.rs\npub mod entities;\npub mod use_cases;\npub mod traits;\n\n// src/domain/entities/user.rs\npub struct User {\n    pub id: UserId,\n    pub email: Email,\n    pub balance: Balance,\n}\n\nimpl User {\n    pub fn transfer_to(&mut self, recipient: &mut User, amount: u64) -> Result<(), Error> {\n        // Pure business logic\n        if self.balance < amount {\n            return Err(Error::InsufficientFunds);\n        }\n        self.balance -= amount;\n        recipient.balance += amount;\n        Ok(())\n    }\n}\n\n// src/domain/use_cases/transfer_funds.rs\npub struct TransferFundsUseCase;\n\nimpl TransferFundsUseCase {\n    pub fn execute(\n        &self,\n        user_repo: &dyn UserRepository,\n        from: UserId,\n        to: UserId,\n        amount: u64\n    ) -> Result<(), Error> {\n        // Use case orchestration\n        let mut from_user = user_repo.find_by_id(from)?;\n        let mut to_user = user_repo.find_by_id(to)?;\n        from_user.transfer_to(&mut to_user, amount)?;\n        user_repo.save(&from_user)?;\n        user_repo.save(&to_user)?;\n        Ok(())\n    }\n}\n\n// src/domain/traits/user_repository.rs\npub trait UserRepository: Send + Sync {\n    fn find_by_id(&self, id: UserId) -> Result<User, Error>;\n    fn save(&self, user: &User) -> Result<(), Error>;\n}\n```\n\n### 2. Application Layer\n\n**Use cases and application services** - Depends on domain\n\n```rust\n// src/application/mod.rs\npub mod use_cases;\npub mod dto;\n\n// src/application/use_cases/transfer_funds.rs\nuse crate::domain::{UserRepository, TransferFundsUseCase};\n\npub struct TransferFundsService {\n    user_repo: Box<dyn UserRepository>,\n    use_case: TransferFundsUseCase,\n}\n\nimpl TransferFundsService {\n    pub fn execute(&self, from: UserId, to: UserId, amount: u64) -> Result<(), Error> {\n        self.use_case.execute(&*self.user_repo, from, to, amount)\n    }\n}\n```\n\n### 3. Infrastructure Layer\n\n**External concerns** - Database, HTTP, file system - Depends on domain traits\n\n```rust\n// src/infrastructure/mod.rs\npub mod database;\npub mod http;\npub mod repositories;\n\n// src/infrastructure/repositories/user_repository_impl.rs\nuse crate::domain::{User, UserRepository, UserId, Error};\nuse sqlx::PgPool;\n\npub struct PostgresUserRepository {\n    pool: PgPool,\n}\n\nimpl UserRepository for PostgresUserRepository {\n    fn find_by_id(&self, id: UserId) -> Result<User, Error> {\n        // Database implementation\n        // Convert DB row to domain entity\n    }\n    \n    fn save(&self, user: &User) -> Result<(), Error> {\n        // Save to database\n    }\n}\n```\n\n### 4. Presentation Layer\n\n**API, CLI, Web** - Depends on application layer\n\n```rust\n// src/presentation/mod.rs\npub mod api;\npub mod cli;\n\n// src/presentation/api/routes.rs\nuse crate::application::TransferFundsService;\nuse axum::{Router, extract::State};\n\npub fn create_router(service: TransferFundsService) -> Router {\n    Router::new()\n        .route(\"/transfer\", post(transfer_funds))\n        .with_state(service)\n}\n\nasync fn transfer_funds(\n    State(service): State<TransferFundsService>,\n    Json(payload): Json<TransferRequest>\n) -> Result<Json<()>, Error> {\n    service.execute(payload.from, payload.to, payload.amount)?;\n    Ok(Json(()))\n}\n```\n\n## Project Structure\n\n```\nsrc/\n├── main.rs\n├── lib.rs\n├── domain/              # Core business logic\n│   ├── mod.rs\n│   ├── entities/        # Domain entities\n│   │   ├── mod.rs\n│   │   ├── user.rs\n│   │   └── transaction.rs\n│   ├── use_cases/       # Business use cases\n│   │   ├── mod.rs\n│   │   └── transfer_funds.rs\n│   └── traits/          # Repository traits\n│       ├── mod.rs\n│       └── user_repository.rs\n├── application/         # Application services\n│   ├── mod.rs\n│   ├── use_cases/\n│   └── dto/\n├── infrastructure/      # External implementations\n│   ├── mod.rs\n│   ├── database/\n│   ├── repositories/    # Repository implementations\n│   └── http/\n└── presentation/        # API/CLI/Web\n    ├── mod.rs\n    ├── api/\n    └── cli/\n```\n\n## Dependency Rule\n\n**Dependencies point inward**:\n\n```\nPresentation → Application → Domain ← Infrastructure\n```\n\n- **Domain**: No dependencies (pure Rust)\n- **Application**: Depends on Domain\n- **Infrastructure**: Depends on Domain (implements traits)\n- **Presentation**: Depends on Application\n\n## Benefits\n\n- **Independence**: Domain logic independent of frameworks\n- **Testability**: Easy to test domain without infrastructure\n- **Flexibility**: Swap implementations (DB, HTTP framework)\n- **Maintainability**: Clear boundaries and responsibilities\n- **Longevity**: Business logic survives technology changes",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": [
    "lesson-60-layered-architecture"
  ],
  "codeExamples": [
    {
      "id": "ex-61-1-clean-structure",
      "title": "Clean Architecture Structure",
      "description": "Clean architecture with trait-based dependencies",
      "code": "pub trait UserRepository {\n    fn find(&self, id: u64) -> Result<User, Error>;\n}\npub struct User {\n    pub id: u64,\n    pub name: String,\n}\npub struct UserService {\n    repo: Box<dyn UserRepository>,\n}\nimpl UserService {\n    pub fn get_user(&self, id: u64) -> Result<User, Error> {\n        self.repo.find(id)\n    }\n}\npub struct PostgresUserRepository;\nimpl UserRepository for PostgresUserRepository {\n    fn find(&self, id: u64) -> Result<User, Error> {\n        Ok(User { id, name: String::from(\"User\") })\n    }\n}\nfn main() {\n    println!(\"Clean Architecture:\");\n    println!(\"1. Domain: Pure business logic\");\n    println!(\"2. Application: Use cases\");\n    println!(\"3. Infrastructure: External implementations\");\n    println!(\"4. Presentation: API/CLI\");\n}",
      "explanation": "Clean Architecture uses traits to invert dependencies. Infrastructure implements domain traits, keeping domain independent of external concerns.",
      "language": "rust"
    },
    {
      "id": "ex-61-2-trait-based",
      "title": "Trait-Based Design",
      "description": "Using traits for dependency inversion",
      "code": "pub trait PaymentProcessor {\n    fn process_payment(&self, amount: u64) -> Result<(), Error>;\n}\npub struct Order {\n    processor: Box<dyn PaymentProcessor>,\n}\nimpl Order {\n    pub fn pay(&self, amount: u64) -> Result<(), Error> {\n        self.processor.process_payment(amount)\n    }\n}\npub struct StripeProcessor;\nimpl PaymentProcessor for StripeProcessor {\n    fn process_payment(&self, amount: u64) -> Result<(), Error> {\n        Ok(())\n    }\n}\npub struct PayPalProcessor;\nimpl PaymentProcessor for PayPalProcessor {\n    fn process_payment(&self, amount: u64) -> Result<(), Error> {\n        Ok(())\n    }\n}\nfn main() {\n    println!(\"Trait-based design:\");\n    println!(\"- Domain defines interface\");\n    println!(\"- Infrastructure implements it\");\n    println!(\"- Easy to swap implementations\");\n}",
      "explanation": "Traits enable dependency inversion. The domain defines what it needs, and infrastructure provides implementations. This keeps domain independent.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-61-1",
      "title": "Create Repository Trait",
      "description": "Define a repository trait in domain and implement it in infrastructure!",
      "starterCode": "pub trait UserRepository {\n    fn find(&self, id: u64) -> Option<String>;\n}\npub struct InMemoryUserRepository;\nfn main() {\n    let repo = InMemoryUserRepository;\n    let user = repo.find(1);\n    println!(\"{:?}\", user);\n}",
      "solution": "pub trait UserRepository {\n    fn find(&self, id: u64) -> Option<String>;\n}\npub struct InMemoryUserRepository;\nimpl UserRepository for InMemoryUserRepository {\n    fn find(&self, id: u64) -> Option<String> {\n        Some(format!(\"User {}\", id))\n    }\n}\nfn main() {\n    let repo = InMemoryUserRepository;\n    let user = repo.find(1);\n    println!(\"{:?}\", user);\n}",
      "hints": [
        "Use impl Trait for Type syntax",
        "Implement the trait methods"
      ],
      "difficulty": "medium"
    }
  ]
}
