{
  "id": "lesson-43-p2p-networking",
  "title": "P2P Networking",
  "description": "Building peer-to-peer networks for blockchain nodes.",
  "content": "# P2P Networking\n\nBlockchain nodes communicate via **peer-to-peer (P2P)** networks. Each node connects to multiple peers to share blocks and transactions.\n\n## P2P Network Structure\n\n- **No central server**: All nodes are equal\n- **Mesh topology**: Nodes connect to multiple peers\n- **Discovery**: Nodes find each other via bootstrapping\n- **Gossip protocol**: Information spreads through network\n\n## Node Structure\n\n```rust\nstruct Node {\n    id: String,\n    address: String,\n    peers: Vec<Peer>,\n    blockchain: Blockchain,\n}\n\nstruct Peer {\n    id: String,\n    address: String,\n    is_connected: bool,\n}\n```\n\n## Connection Management\n\n```rust\nimpl Node {\n    fn connect_to_peer(&mut self, peer_address: String) -> Result<(), String> {\n        // Establish connection to peer\n        // Add to peers list\n        Ok(())\n    }\n    \n    fn disconnect_from_peer(&mut self, peer_id: String) {\n        // Remove peer from list\n    }\n    \n    fn broadcast_block(&self, block: &Block) {\n        // Send block to all connected peers\n    }\n}\n```\n\n## Message Types\n\n- **Handshake**: Initial connection\n- **Block**: New block announcement\n- **Transaction**: New transaction\n- **GetBlocks**: Request blocks\n- **Blocks**: Send requested blocks\n- **Ping/Pong**: Keep-alive\n\n## Network Discovery\n\n1. **Bootstrap nodes**: Known entry points\n2. **Peer exchange**: Peers share their peer lists\n3. **DNS seeds**: DNS records with node addresses\n4. **DHT**: Distributed hash table for discovery\n\n## Advantages\n\n- **Resilient**: No single point of failure\n- **Scalable**: More nodes = more capacity\n- **Censorship resistant**: Hard to shut down\n- **Decentralized**: No central authority",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": [
    "lesson-25-async-await"
  ],
  "codeExamples": [
    {
      "id": "ex-43-1-node-structure",
      "title": "Node Structure",
      "description": "Basic P2P node structure",
      "code": "struct Peer {\n    id: String,\n    address: String,\n    is_connected: bool,\n}\nstruct Node {\n    id: String,\n    address: String,\n    peers: Vec<Peer>,\n}\nimpl Node {\n    fn new(id: String, address: String) -> Self {\n        Node {\n            id,\n            address,\n            peers: Vec::new(),\n        }\n    }\n    fn add_peer(&mut self, peer: Peer) {\n        self.peers.push(peer);\n        println!(\"Added peer: {} at {}\", peer.id, peer.address);\n    }\n    fn get_peer_count(&self) -> usize {\n        self.peers.len()\n    }\n    fn broadcast(&self, message: &str) {\n        println!(\"Broadcasting '{}' to {} peers\", message, self.peers.len());\n        for peer in &self.peers {\n            if peer.is_connected {\n                println!(\"  -> Sending to peer: {}\", peer.id);\n            }\n        }\n    }\n}\nfn main() {\n    let mut node = Node::new(\n        String::from(\"node1\"),\n        String::from(\"127.0.0.1:8080\"),\n    );\n    node.add_peer(Peer {\n        id: String::from(\"peer1\"),\n        address: String::from(\"127.0.0.1:8081\"),\n        is_connected: true,\n    });\n    node.add_peer(Peer {\n        id: String::from(\"peer2\"),\n        address: String::from(\"127.0.0.1:8082\"),\n        is_connected: true,\n    });\n    println!(\"Node has {} peers\", node.get_peer_count());\n    node.broadcast(\"New block\");\n}",
      "explanation": "A P2P node maintains connections to multiple peers. It can broadcast messages to all connected peers, enabling information propagation through the network.",
      "language": "rust"
    },
    {
      "id": "ex-43-2-message-types",
      "title": "Message Types",
      "description": "Different message types in P2P network",
      "code": "enum Message {\n    Handshake { node_id: String, version: u32 },\n    Block { block_data: String },\n    Transaction { tx_data: String },\n    GetBlocks { from_height: u64 },\n    Blocks { blocks: Vec<String> },\n    Ping,\n    Pong,\n}\nfn handle_message(msg: Message) {\n    match msg {\n        Message::Handshake { node_id, version } => {\n            println!(\"Handshake from {} version {}\", node_id, version);\n        },\n        Message::Block { block_data } => {\n            println!(\"Received block: {}\", block_data);\n        },\n        Message::Transaction { tx_data } => {\n            println!(\"Received transaction: {}\", tx_data);\n        },\n        Message::GetBlocks { from_height } => {\n            println!(\"Requesting blocks from height {}\", from_height);\n        },\n        Message::Blocks { blocks } => {\n            println!(\"Received {} blocks\", blocks.len());\n        },\n        Message::Ping => {\n            println!(\"Received ping, sending pong\");\n        },\n        Message::Pong => {\n            println!(\"Received pong\");\n        },\n    }\n}\nfn main() {\n    handle_message(Message::Handshake {\n        node_id: String::from(\"node1\"),\n        version: 1,\n    });\n    handle_message(Message::Block {\n        block_data: String::from(\"block123\"),\n    });\n}",
      "explanation": "P2P networks use different message types for various operations. Enums in Rust are perfect for representing these message types.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-43-1",
      "title": "Create P2P Node",
      "description": "Create a node that can add peers and broadcast messages!",
      "starterCode": "struct Peer {\n    id: String,\n    address: String,\n}\nstruct Node {\n    id: String,\n    peers: Vec<Peer>,\n}\nfn main() {\n    let mut node = Node::new(String::from(\"node1\"));\n    node.add_peer(Peer {\n        id: String::from(\"peer1\"),\n        address: String::from(\"127.0.0.1:8081\"),\n    });\n    node.broadcast(\"Hello\");\n}",
      "solution": "struct Peer {\n    id: String,\n    address: String,\n}\nstruct Node {\n    id: String,\n    peers: Vec<Peer>,\n}\nimpl Node {\n    fn new(id: String) -> Self {\n        Node { id, peers: Vec::new() }\n    }\n    fn add_peer(&mut self, peer: Peer) {\n        self.peers.push(peer);\n    }\n    fn broadcast(&self, message: &str) {\n        println!(\"Broadcasting '{}' to {} peers\", message, self.peers.len());\n    }\n}\nfn main() {\n    let mut node = Node::new(String::from(\"node1\"));\n    node.add_peer(Peer {\n        id: String::from(\"peer1\"),\n        address: String::from(\"127.0.0.1:8081\"),\n    });\n    node.broadcast(\"Hello\");\n}",
      "hints": [
        "Use Vec to store peers",
        "broadcast() should print message and peer count"
      ],
      "difficulty": "medium"
    }
  ]
}
