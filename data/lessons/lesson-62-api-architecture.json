{
  "id": "lesson-62-api-architecture",
  "title": "REST API Architecture",
  "description": "Building RESTful APIs with Rust using modern frameworks.",
  "content": "# REST API Architecture\n\nBuilding production-ready REST APIs with Rust requires proper structure and framework selection.\n\n## Popular Rust Web Frameworks\n\n### 1. Axum (Recommended)\n\n**Modern, async-first framework built on Tokio**\n\n```toml\n[dependencies]\naxum = \"0.7\"\ntokio = { version = \"1.0\", features = [\"full\"] }\ntower = \"0.4\"\ntower-http = { version = \"0.5\", features = [\"cors\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n```\n\n### 2. Actix Web\n\n**High-performance, actor-based framework**\n\n```toml\n[dependencies]\nactix-web = \"4.4\"\nactix-rt = \"2.9\"\nserde = { version = \"1.0\", features = [\"derive\"] }\n```\n\n### 3. Rocket\n\n**Easy-to-use, type-safe framework**\n\n```toml\n[dependencies]\nrocket = { version = \"0.5\", features = [\"json\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\n```\n\n## Axum API Structure\n\n```\nsrc/\n├── main.rs\n├── lib.rs\n├── api/\n│   ├── mod.rs\n│   ├── routes.rs          # Route definitions\n│   ├── handlers/          # Request handlers\n│   │   ├── mod.rs\n│   │   ├── user_handler.rs\n│   │   └── transaction_handler.rs\n│   ├── middleware/        # Custom middleware\n│   │   ├── mod.rs\n│   │   ├── auth.rs\n│   │   └── logging.rs\n│   └── extractors/        # Custom extractors\n│       └── mod.rs\n├── services/\n│   ├── mod.rs\n│   └── user_service.rs\n├── repositories/\n│   ├── mod.rs\n│   └── user_repository.rs\n├── models/\n│   ├── mod.rs\n│   ├── user.rs\n│   └── dto.rs            # Data Transfer Objects\n├── database/\n│   ├── mod.rs\n│   └── connection.rs\n└── config/\n    └── mod.rs\n```\n\n## Complete Axum Example\n\n```rust\n// src/main.rs\nuse axum::{Router, routing::get, Json};\nuse serde_json::{Value, json};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/\", get(root))\n        .route(\"/health\", get(health_check));\n    \n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn root() -> Json<Value> {\n    Json(json!({ \"message\": \"Hello, World!\" }))\n}\n\nasync fn health_check() -> Json<Value> {\n    Json(json!({ \"status\": \"healthy\" }))\n}\n```\n\n## Route Organization\n\n```rust\n// src/api/routes.rs\nuse axum::{Router, routing::{get, post, put, delete}};\nuse crate::api::handlers::{user_handler, transaction_handler};\n\npub fn create_router() -> Router {\n    Router::new()\n        .nest(\"/api/v1\", api_v1_routes())\n        .route(\"/health\", get(health_check))\n}\n\nfn api_v1_routes() -> Router {\n    Router::new()\n        .nest(\"/users\", user_routes())\n        .nest(\"/transactions\", transaction_routes())\n}\n\nfn user_routes() -> Router {\n    Router::new()\n        .route(\"/\", get(user_handler::list_users))\n        .route(\"/\", post(user_handler::create_user))\n        .route(\"/:id\", get(user_handler::get_user))\n        .route(\"/:id\", put(user_handler::update_user))\n        .route(\"/:id\", delete(user_handler::delete_user))\n}\n```\n\n## Handler Implementation\n\n```rust\n// src/api/handlers/user_handler.rs\nuse axum::{extract::{Path, State}, Json, response::Json as ResponseJson};\nuse crate::{services::UserService, models::dto::CreateUserRequest};\n\npub async fn create_user(\n    State(service): State<UserService>,\n    Json(payload): Json<CreateUserRequest>\n) -> Result<ResponseJson<User>, AppError> {\n    let user = service.create_user(payload).await?;\n    Ok(ResponseJson(user))\n}\n\npub async fn get_user(\n    State(service): State<UserService>,\n    Path(id): Path<u64>\n) -> Result<ResponseJson<User>, AppError> {\n    let user = service.get_user(id).await?;\n    Ok(ResponseJson(user))\n}\n```\n\n## Middleware\n\n```rust\n// src/api/middleware/auth.rs\nuse axum::{extract::Request, middleware::Next, response::Response};\nuse tower::ServiceBuilder;\nuse tower_http::auth::RequireAuthorizationLayer;\n\npub async fn auth_middleware(\n    mut request: Request,\n    next: Next\n) -> Response {\n    // Extract and validate token\n    // Add user to request extensions\n    next.run(request).await\n}\n\n// Apply middleware\nlet app = Router::new()\n    .route(\"/api/protected\", get(protected_route))\n    .layer(ServiceBuilder::new()\n        .layer(RequireAuthorizationLayer::bearer(\"secret\"))\n    );\n```\n\n## Error Handling\n\n```rust\n// src/error.rs\nuse axum::{response::{Response, IntoResponse}, http::StatusCode};\n\n#[derive(Debug)]\npub enum AppError {\n    NotFound,\n    ValidationError(String),\n    DatabaseError(String),\n    Unauthorized,\n}\n\nimpl IntoResponse for AppError {\n    fn into_response(self) -> Response {\n        let (status, message) = match self {\n            AppError::NotFound => (StatusCode::NOT_FOUND, \"Resource not found\"),\n            AppError::ValidationError(msg) => (StatusCode::BAD_REQUEST, &msg),\n            AppError::DatabaseError(msg) => (StatusCode::INTERNAL_SERVER_ERROR, &msg),\n            AppError::Unauthorized => (StatusCode::UNAUTHORIZED, \"Unauthorized\"),\n        };\n        \n        (status, Json(json!({ \"error\": message }))).into_response()\n    }\n}\n```\n\n## Database Integration\n\n```rust\n// src/database/connection.rs\nuse sqlx::{PgPool, postgres::PgPoolOptions};\n\npub async fn create_pool(database_url: &str) -> Result<PgPool, sqlx::Error> {\n    PgPoolOptions::new()\n        .max_connections(10)\n        .connect(database_url)\n        .await\n}\n\n// In main.rs\nlet pool = create_pool(&database_url).await?;\nlet app = Router::new()\n    .route(\"/api/users\", get(get_users))\n    .with_state(pool);\n```\n\n## Best Practices\n\n- **Route organization**: Group related routes\n- **State management**: Use `State` extractor for dependencies\n- **Error handling**: Centralized error types\n- **Validation**: Validate input in handlers\n- **Middleware**: Use for cross-cutting concerns\n- **Documentation**: Use OpenAPI/Swagger\n- **Testing**: Integration tests for API endpoints",
  "difficulty": "intermediate",
  "estimatedTime": 50,
  "prerequisites": ["lesson-60-layered-architecture"],
  "codeExamples": [
    {
      "id": "ex-62-1-axum-api",
      "title": "Axum API Example",
      "description": "Basic Axum REST API structure",
      "code": "// Axum API structure\n// use axum::{Router, routing::get, Json};\n// use serde_json::json;\n\nstruct AppState {\n    // Database, services, etc.\n}\n\n// Route definition\n// fn create_router() -> Router<AppState> {\n//     Router::new()\n//         .route(\"/\", get(root))\n//         .route(\"/api/users\", get(get_users))\n//         .with_state(AppState {})\n// }\n\n// Handler\n// async fn root() -> Json<Value> {\n//     Json(json!({ \"message\": \"Hello\" }))\n// }\n\nfn main() {\n    println!(\"REST API with Axum:\");\n    println!(\"1. Router: Define routes\");\n    println!(\"2. Handlers: Process requests\");\n    println!(\"3. State: Share dependencies\");\n    println!(\"4. Middleware: Cross-cutting concerns\");\n    println!(\"5. Extractors: Parse request data\");\n}",
      "explanation": "Axum provides a modern, type-safe API for building REST APIs. It uses async/await and integrates well with Tokio.",
      "language": "rust"
    },
    {
      "id": "ex-62-2-api-structure",
      "title": "API Project Structure",
      "description": "Organizing API code",
      "code": "// API project structure\n\n// src/api/routes.rs\n// - Define all routes\n// - Group by resource\n// - Apply middleware\n\n// src/api/handlers/\n// - One file per resource\n// - Handle HTTP requests\n// - Call services\n\n// src/services/\n// - Business logic\n// - Use repositories\n\n// src/repositories/\n// - Data access\n// - Database operations\n\n// src/models/\n// - Domain entities\n// - DTOs for API\n\nfn main() {\n    println!(\"API Architecture:\");\n    println!(\"routes → handlers → services → repositories\");\n    println!(\"Each layer has clear responsibility\");\n}",
      "explanation": "Well-organized API code separates concerns: routes define endpoints, handlers process requests, services contain business logic, and repositories handle data access.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-62-1",
      "title": "API Route",
      "description": "Create a simple API route structure!",
      "starterCode": "// Create a Router with two routes:\n// - GET /health -> returns \"healthy\"\n// - GET /api/users -> returns list of users\n\n// Use this structure:\n// Router::new()\n//     .route(\"/health\", get(health))\n//     .route(\"/api/users\", get(users))\n\nfn main() {\n    println!(\"API routes created!\");\n}",
      "solution": "// In real Axum:\n// use axum::{Router, routing::get, Json};\n// \n// fn create_router() -> Router {\n//     Router::new()\n//         .route(\"/health\", get(health))\n//         .route(\"/api/users\", get(users))\n// }\n// \n// async fn health() -> &'static str {\n//     \"healthy\"\n// }\n// \n// async fn users() -> Json<Vec<String>> {\n//     Json(vec![String::from(\"User1\")])\n// }\n\nfn main() {\n    println!(\"API routes created!\");\n}",
      "hints": [
        "Use Router::new() to create router",
        "Chain .route() calls for each endpoint"
      ],
      "difficulty": "medium"
    }
  ]
}

