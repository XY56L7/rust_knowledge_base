{
  "id": "lesson-60-layered-architecture",
  "title": "Layered Architecture",
  "description": "Implementing layered architecture pattern in Rust applications.",
  "content": "# Layered Architecture\n\n**Layered Architecture** separates concerns into distinct layers, each with specific responsibilities.\n\n## Architecture Layers\n\n### 1. Presentation Layer (API/Controllers)\n\n**Responsibility**: Handle HTTP requests, validate input, format responses\n\n```rust\n// src/api/mod.rs\npub mod routes;\npub mod handlers;\npub mod middleware;\n\n// src/api/handlers.rs\nuse crate::services::UserService;\nuse crate::models::User;\n\npub struct UserHandler {\n    user_service: UserService,\n}\n\nimpl UserHandler {\n    pub async fn create_user(&self, data: CreateUserRequest) -> Result<User, Error> {\n        // Validate input\n        // Call service layer\n        // Format response\n        self.user_service.create_user(data).await\n    }\n}\n```\n\n### 2. Service Layer (Business Logic)\n\n**Responsibility**: Implement business rules, orchestrate operations\n\n```rust\n// src/services/mod.rs\npub mod user_service;\npub mod transaction_service;\n\n// src/services/user_service.rs\nuse crate::repositories::UserRepository;\nuse crate::models::User;\n\npub struct UserService {\n    user_repo: UserRepository,\n}\n\nimpl UserService {\n    pub async fn create_user(&self, data: CreateUserRequest) -> Result<User, Error> {\n        // Business logic\n        // Validation rules\n        // Call repository\n        self.user_repo.create(data).await\n    }\n    \n    pub async fn transfer_funds(\n        &self,\n        from: UserId,\n        to: UserId,\n        amount: u64\n    ) -> Result<(), Error> {\n        // Complex business logic\n        // Multiple repository calls\n        // Transaction management\n    }\n}\n```\n\n### 3. Repository Layer (Data Access)\n\n**Responsibility**: Abstract database operations, data persistence\n\n```rust\n// src/repositories/mod.rs\npub mod user_repository;\npub mod transaction_repository;\n\n// src/repositories/user_repository.rs\nuse crate::models::User;\nuse crate::database::Connection;\n\npub struct UserRepository {\n    db: Connection,\n}\n\nimpl UserRepository {\n    pub async fn create(&self, data: CreateUserData) -> Result<User, Error> {\n        // Database operations\n        // SQL queries\n        // Data mapping\n    }\n    \n    pub async fn find_by_id(&self, id: UserId) -> Result<Option<User>, Error> {\n        // Query database\n    }\n}\n```\n\n### 4. Domain/Model Layer\n\n**Responsibility**: Define data structures, domain entities\n\n```rust\n// src/models/mod.rs\npub mod user;\npub mod transaction;\n\n// src/models/user.rs\nuse serde::{Serialize, Deserialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    pub id: UserId,\n    pub email: String,\n    pub balance: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CreateUserRequest {\n    pub email: String,\n    pub password: String,\n}\n```\n\n## Complete Example Structure\n\n```\nsrc/\n├── main.rs\n├── lib.rs\n├── api/                    # Presentation Layer\n│   ├── mod.rs\n│   ├── routes.rs           # Route definitions\n│   ├── handlers.rs         # Request handlers\n│   └── middleware.rs       # Auth, logging, etc.\n├── services/               # Service Layer\n│   ├── mod.rs\n│   ├── user_service.rs\n│   └── transaction_service.rs\n├── repositories/           # Repository Layer\n│   ├── mod.rs\n│   ├── user_repository.rs\n│   └── transaction_repository.rs\n├── models/                 # Domain Layer\n│   ├── mod.rs\n│   ├── user.rs\n│   └── transaction.rs\n├── database/               # Infrastructure\n│   ├── mod.rs\n│   └── connection.rs\n└── config/                 # Configuration\n    └── mod.rs\n```\n\n## Dependency Flow\n\n```\nAPI Layer\n  ↓ (depends on)\nService Layer\n  ↓ (depends on)\nRepository Layer\n  ↓ (depends on)\nDatabase/Infrastructure\n```\n\n**Key Principle**: Dependencies flow downward. Upper layers depend on lower layers, but not vice versa.\n\n## Benefits\n\n- **Separation of concerns**: Each layer has clear responsibility\n- **Testability**: Easy to mock dependencies\n- **Maintainability**: Changes isolated to specific layers\n- **Reusability**: Services can be used by different APIs\n- **Scalability**: Layers can scale independently",
  "difficulty": "intermediate",
  "estimatedTime": 45,
  "prerequisites": [
    "lesson-59-rust-project-structure"
  ],
  "codeExamples": [
    {
      "id": "ex-60-1-layered-structure",
      "title": "Layered Architecture Example",
      "description": "Complete layered architecture structure",
      "code": "struct ApiHandler {\n    service: UserService,\n}\nimpl ApiHandler {\n    fn handle_request(&self) {\n        self.service.process();\n    }\n}\nstruct UserService {\n    repo: UserRepository,\n}\nimpl UserService {\n    fn process(&self) {\n        self.repo.save();\n    }\n}\nstruct UserRepository {\n    db: Database,\n}\nimpl UserRepository {\n    fn save(&self) {\n    }\n}\nstruct User {\n    id: u64,\n    name: String,\n}\nfn main() {\n    println!(\"Layered Architecture:\");\n    println!(\"1. API Layer: HTTP handling\");\n    println!(\"2. Service Layer: Business logic\");\n    println!(\"3. Repository Layer: Data access\");\n    println!(\"4. Domain Layer: Models\");\n}",
      "explanation": "Layered architecture separates concerns into distinct layers. Each layer has a specific responsibility and depends only on layers below it.",
      "language": "rust"
    },
    {
      "id": "ex-60-2-service-layer",
      "title": "Service Layer Pattern",
      "description": "Service layer with business logic",
      "code": "struct TransferService {\n    user_repo: UserRepository,\n    tx_repo: TransactionRepository,\n}\nimpl TransferService {\n    fn transfer_funds(\n        &self,\n        from: u64,\n        to: u64,\n        amount: u64\n    ) -> Result<(), String> {\n        if amount == 0 {\n            return Err(String::from(\"Amount must be positive\"));\n        }\n        Ok(())\n    }\n}\nfn main() {\n    println!(\"Service layer contains:\");\n    println!(\"- Business rules\");\n    println!(\"- Validation logic\");\n    println!(\"- Orchestration\");\n}",
      "explanation": "The service layer contains business logic and orchestrates operations across multiple repositories. It's where complex business rules are implemented.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-60-1",
      "title": "Create Service Layer",
      "description": "Create a service struct with a method that uses a repository!",
      "starterCode": "struct UserService {\n    repo: UserRepository,\n}\nstruct UserRepository;\nimpl UserRepository {\n    fn find_by_id(&self, id: u64) -> Option<String> {\n        Some(format!(\"User {}\", id))\n    }\n}\nfn main() {\n    let service = UserService::new(UserRepository);\n    let user = service.get_user(1);\n    println!(\"{:?}\", user);\n}",
      "solution": "struct UserService {\n    repo: UserRepository,\n}\nimpl UserService {\n    fn new(repo: UserRepository) -> Self {\n        UserService { repo }\n    }\n    fn get_user(&self, id: u64) -> Option<String> {\n        self.repo.find_by_id(id)\n    }\n}\nstruct UserRepository;\nimpl UserRepository {\n    fn find_by_id(&self, id: u64) -> Option<String> {\n        Some(format!(\"User {}\", id))\n    }\n}\nfn main() {\n    let service = UserService::new(UserRepository);\n    let user = service.get_user(1);\n    println!(\"{:?}\", user);\n}",
      "hints": [
        "Service depends on repository",
        "Service methods call repository methods"
      ],
      "difficulty": "medium"
    }
  ]
}
