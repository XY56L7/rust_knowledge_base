{
  "id": "lesson-52-dex-implementation",
  "title": "Decentralized Exchange (DEX)",
  "description": "Building a simple decentralized exchange for token trading.",
  "content": "# Decentralized Exchange (DEX)\n\nA **Decentralized Exchange** allows users to trade tokens without a central authority. Let's build a simple order book DEX.\n\n## DEX Components\n\n1. **Order Book**: Buy and sell orders\n2. **Matching Engine**: Matches orders\n3. **Liquidity Pool**: Alternative AMM model\n4. **Trade Execution**: Execute matched trades\n\n## Order Structure\n\n```rust\nenum OrderType {\n    Buy,\n    Sell,\n}\n\nstruct Order {\n    id: String,\n    trader: String,\n    order_type: OrderType,\n    token_pair: (String, String),  // (base, quote)\n    price: u64,\n    amount: u64,\n    filled: u64,\n}\n```\n\n## Order Book\n\n```rust\nstruct OrderBook {\n    buy_orders: Vec<Order>,   // Sorted by price (highest first)\n    sell_orders: Vec<Order>,  // Sorted by price (lowest first)\n}\n\nimpl OrderBook {\n    fn add_order(&mut self, order: Order) {\n        match order.order_type {\n            OrderType::Buy => self.buy_orders.push(order),\n            OrderType::Sell => self.sell_orders.push(order),\n        }\n        self.match_orders();\n    }\n    \n    fn match_orders(&mut self) {\n        // Match highest buy with lowest sell\n        // Execute trades when prices overlap\n    }\n}\n```\n\n## Automated Market Maker (AMM)\n\nAlternative to order books:\n\n```rust\nstruct LiquidityPool {\n    token_a: u64,\n    token_b: u64,\n    total_supply: u64,\n}\n\nimpl LiquidityPool {\n    fn swap(&mut self, token_in: String, amount_in: u64) -> u64 {\n        // Constant product formula: x * y = k\n        // Calculate amount_out based on pool reserves\n    }\n}\n```\n\n## Trade Execution\n\n```rust\nfn execute_trade(buy_order: &mut Order, sell_order: &mut Order) -> Trade {\n    let trade_amount = buy_order.amount.min(sell_order.amount);\n    let trade_price = sell_order.price;  // Use sell price\n    \n    // Update orders\n    buy_order.filled += trade_amount;\n    sell_order.filled += trade_amount;\n    \n    Trade {\n        buy_order_id: buy_order.id.clone(),\n        sell_order_id: sell_order.id.clone(),\n        amount: trade_amount,\n        price: trade_price,\n    }\n}\n```\n\n## DEX Features\n\n- **No KYC**: Permissionless trading\n- **Non-custodial**: Users control funds\n- **Transparent**: All trades on-chain\n- **Liquidity**: Provided by users\n\n## Implementation Considerations\n\n- **Slippage**: Price impact of large trades\n- **Front-running**: MEV (Maximal Extractable Value)\n- **Gas optimization**: Minimize on-chain operations\n- **Liquidity incentives**: Reward liquidity providers",
  "difficulty": "advanced",
  "estimatedTime": 60,
  "prerequisites": [
    "lesson-41-smart-contract-structure"
  ],
  "codeExamples": [
    {
      "id": "ex-52-1-order-book",
      "title": "Order Book",
      "description": "Basic order book implementation",
      "code": "enum OrderType {\n    Buy,\n    Sell,\n}\nstruct Order {\n    id: String,\n    trader: String,\n    order_type: OrderType,\n    price: u64,\n    amount: u64,\n}\nstruct OrderBook {\n    buy_orders: Vec<Order>,\n    sell_orders: Vec<Order>,\n}\nimpl OrderBook {\n    fn new() -> Self {\n        OrderBook {\n            buy_orders: Vec::new(),\n            sell_orders: Vec::new(),\n        }\n    }\n    fn add_order(&mut self, order: Order) {\n        match order.order_type {\n            OrderType::Buy => {\n                self.buy_orders.push(order);\n                self.buy_orders.sort_by(|a, b| b.price.cmp(&a.price));\n            },\n            OrderType::Sell => {\n                self.sell_orders.push(order);\n                self.sell_orders.sort_by(|a, b| a.price.cmp(&b.price));\n            },\n        }\n    }\n    fn get_best_buy(&self) -> Option<&Order> {\n        self.buy_orders.first()\n    }\n    fn get_best_sell(&self) -> Option<&Order> {\n        self.sell_orders.first()\n    }\n}\nfn main() {\n    let mut book = OrderBook::new();\n    book.add_order(Order {\n        id: String::from(\"buy1\"),\n        trader: String::from(\"0xAlice\"),\n        order_type: OrderType::Buy,\n        price: 100,\n        amount: 10,\n    });\n    book.add_order(Order {\n        id: String::from(\"sell1\"),\n        trader: String::from(\"0xBob\"),\n        order_type: OrderType::Sell,\n        price: 95,\n        amount: 5,\n    });\n    if let Some(best_buy) = book.get_best_buy() {\n        println!(\"Best buy: {} at price {}\", best_buy.amount, best_buy.price);\n    }\n    if let Some(best_sell) = book.get_best_sell() {\n        println!(\"Best sell: {} at price {}\", best_sell.amount, best_sell.price);\n    }\n}",
      "explanation": "An order book maintains buy and sell orders sorted by price. The best buy (highest price) and best sell (lowest price) can be matched when prices overlap.",
      "language": "rust"
    },
    {
      "id": "ex-52-2-amm-pool",
      "title": "AMM Liquidity Pool",
      "description": "Automated Market Maker pool",
      "code": "struct LiquidityPool {\n    token_a_reserve: u64,\n    token_b_reserve: u64,\n}\nimpl LiquidityPool {\n    fn new(amount_a: u64, amount_b: u64) -> Self {\n        LiquidityPool {\n            token_a_reserve: amount_a,\n            token_b_reserve: amount_b,\n        }\n    }\n    fn swap_a_for_b(&mut self, amount_a_in: u64) -> u64 {\n        let k = self.token_a_reserve * self.token_b_reserve;\n        self.token_a_reserve += amount_a_in;\n        let new_b_reserve = k / self.token_a_reserve;\n        let amount_b_out = self.token_b_reserve - new_b_reserve;\n        self.token_b_reserve = new_b_reserve;\n        amount_b_out\n    }\n    fn get_price(&self) -> f64 {\n        if self.token_a_reserve > 0 {\n            self.token_b_reserve as f64 / self.token_a_reserve as f64\n        } else {\n            0.0\n        }\n    }\n}\nfn main() {\n    let mut pool = LiquidityPool::new(1000, 2000);\n    println!(\"Initial price: {:.2}\", pool.get_price());\n    let b_received = pool.swap_a_for_b(100);\n    println!(\"Swapped 100 A for {} B\", b_received);\n    println!(\"New price: {:.2}\", pool.get_price());\n}",
      "explanation": "AMM pools use constant product formula (x * y = k) to determine swap rates. Prices change based on pool reserves, providing automatic price discovery.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-52-1",
      "title": "Order Book",
      "description": "Create an order book that can add buy and sell orders!",
      "starterCode": "enum OrderType {\n    Buy,\n    Sell,\n}\nstruct Order {\n    price: u64,\n    amount: u64,\n}\nstruct OrderBook {\n    buy_orders: Vec<Order>,\n    sell_orders: Vec<Order>,\n}\nfn main() {\n    let mut book = OrderBook::new();\n    book.add_buy_order(Order { price: 100, amount: 10 });\n    book.add_sell_order(Order { price: 95, amount: 5 });\n    println!(\"Buy orders: {}, Sell orders: {}\",\n            book.buy_orders.len(), book.sell_orders.len());\n}",
      "solution": "enum OrderType {\n    Buy,\n    Sell,\n}\nstruct Order {\n    price: u64,\n    amount: u64,\n}\nstruct OrderBook {\n    buy_orders: Vec<Order>,\n    sell_orders: Vec<Order>,\n}\nimpl OrderBook {\n    fn new() -> Self {\n        OrderBook {\n            buy_orders: Vec::new(),\n            sell_orders: Vec::new(),\n        }\n    }\n    fn add_buy_order(&mut self, order: Order) {\n        self.buy_orders.push(order);\n    }\n    fn add_sell_order(&mut self, order: Order) {\n        self.sell_orders.push(order);\n    }\n}\nfn main() {\n    let mut book = OrderBook::new();\n    book.add_buy_order(Order { price: 100, amount: 10 });\n    book.add_sell_order(Order { price: 95, amount: 5 });\n    println!(\"Buy orders: {}, Sell orders: {}\",\n            book.buy_orders.len(), book.sell_orders.len());\n}",
      "hints": [
        "Use Vec to store orders",
        "Separate buy and sell orders"
      ],
      "difficulty": "medium"
    }
  ]
}
