{
  "id": "lesson-58-monitoring-observability",
  "title": "Monitoring and Observability",
  "description": "Monitoring Rust blockchain applications in production.",
  "content": "# Monitoring and Observability\n\n**Observability** is crucial for production blockchain applications. It includes logging, metrics, and tracing.\n\n## Three Pillars of Observability\n\n1. **Logs**: What happened and when\n2. **Metrics**: How much, how often\n3. **Traces**: Request flow through system\n\n## Logging\n\n### Structured Logging with tracing\n\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n```\n\n```rust\nuse tracing::{info, error, warn, debug};\n\nfn main() {\n    tracing_subscriber::fmt::init();\n    \n    info!(target: \"blockchain\", \"Node starting\");\n    info!(height = 1000, \"Blockchain synced\");\n    \n    error!(target: \"blockchain\", error = ?err, \"Sync failed\");\n    warn!(target: \"network\", \"Peer disconnected\");\n}\n```\n\n### Log Levels\n\n- **ERROR**: Critical failures\n- **WARN**: Potential issues\n- **INFO**: Important events\n- **DEBUG**: Detailed debugging\n- **TRACE**: Very detailed\n\n## Metrics\n\n### Prometheus Integration\n\n```toml\n[dependencies]\nprometheus = \"0.13\"\n```\n\n```rust\nuse prometheus::{Counter, Histogram, Registry};\n\nlazy_static! {\n    static ref BLOCKS_MINED: Counter = Counter::new(\n        \"blocks_mined_total\",\n        \"Total blocks mined\"\n    ).unwrap();\n    \n    static ref BLOCK_TIME: Histogram = Histogram::with_opts(\n        HistogramOpts::new(\"block_time_seconds\", \"Time to mine block\")\n    ).unwrap();\n}\n\nfn mine_block() {\n    let timer = BLOCK_TIME.start_timer();\n    // ... mining logic ...\n    BLOCKS_MINED.inc();\n    timer.observe_duration();\n}\n```\n\n### Key Metrics for Blockchain\n\n- **Block height**: Current chain height\n- **Transaction throughput**: TPS\n- **Peer count**: Connected peers\n- **Sync status**: Sync percentage\n- **Memory usage**: RAM consumption\n- **CPU usage**: Processing load\n- **Network I/O**: Bytes sent/received\n\n## Distributed Tracing\n\n```rust\nuse tracing::{instrument, Span};\n\n#[instrument]\nasync fn process_transaction(tx: Transaction) -> Result<(), Error> {\n    // Function automatically creates span\n    // Logs entry, exit, and errors\n}\n```\n\n## Alerting\n\n### Critical Alerts\n\n- **Node down**: No health check response\n- **Sync stalled**: Height not increasing\n- **High error rate**: Many failed operations\n- **Memory leak**: Continuously growing memory\n- **Disk full**: Running out of storage\n\n### Alert Configuration\n\n```yaml\n# Prometheus alert rules\nalert: BlockchainNodeDown\nexpr: up{job=\"blockchain-node\"} == 0\nfor: 5m\nannotations:\n  summary: \"Blockchain node is down\"\n```\n\n## Dashboards\n\n### Grafana Dashboards\n\nVisualize:\n- Block production rate\n- Transaction volume\n- Network activity\n- Resource usage\n- Error rates\n\n## Log Aggregation\n\n- **ELK Stack**: Elasticsearch, Logstash, Kibana\n- **Loki**: Log aggregation by Grafana\n- **CloudWatch**: AWS logging\n- **Stackdriver**: GCP logging\n\n## Best Practices\n\n- **Structured logs**: Use JSON format\n- **Context**: Include request IDs, user IDs\n- **Sampling**: Don't log everything at DEBUG\n- **Rotation**: Rotate log files\n- **Retention**: Keep logs for compliance\n- **Privacy**: Don't log sensitive data",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": ["lesson-56-production-checklist"],
  "codeExamples": [
    {
      "id": "ex-58-1-structured-logging",
      "title": "Structured Logging",
      "description": "Using tracing for structured logs",
      "code": "// Add to Cargo.toml:\n// tracing = \"0.1\"\n// tracing-subscriber = \"0.3\"\n\n// use tracing::{info, error, warn};\n\nstruct BlockchainNode {\n    height: u64,\n    peer_count: u32,\n}\n\nimpl BlockchainNode {\n    fn log_status(&self) {\n        // Structured logging with fields\n        // info!(\n        //     height = self.height,\n        //     peers = self.peer_count,\n        //     \"Node status\"\n        // );\n        \n        println!(\"Height: {}, Peers: {}\", self.height, self.peer_count);\n    }\n    \n    fn log_error(&self, error: &str) {\n        // error!(\n        //     error = error,\n        //     height = self.height,\n        //     \"Critical error occurred\"\n        // );\n        \n        println!(\"ERROR: {} at height {}\", error, self.height);\n    }\n}\n\nfn main() {\n    let node = BlockchainNode {\n        height: 1000,\n        peer_count: 5,\n    };\n    \n    node.log_status();\n    node.log_error(\"Sync failed\");\n}",
      "explanation": "Structured logging with fields makes logs searchable and analyzable. Tools like ELK or Loki can parse structured logs for better insights.",
      "language": "rust"
    },
    {
      "id": "ex-58-2-metrics",
      "title": "Metrics Collection",
      "description": "Collecting blockchain metrics",
      "code": "// Metrics structure for blockchain\nstruct BlockchainMetrics {\n    blocks_mined: u64,\n    transactions_processed: u64,\n    current_height: u64,\n    peer_count: u32,\n    sync_percentage: f64,\n}\n\nimpl BlockchainMetrics {\n    fn new() -> Self {\n        BlockchainMetrics {\n            blocks_mined: 0,\n            transactions_processed: 0,\n            current_height: 0,\n            peer_count: 0,\n            sync_percentage: 0.0,\n        }\n    }\n    \n    fn update(&mut self, height: u64, peers: u32) {\n        self.current_height = height;\n        self.peer_count = peers;\n        self.sync_percentage = (height as f64 / 10000.0) * 100.0;\n    }\n    \n    fn display(&self) {\n        println!(\"Metrics:\");\n        println!(\"  Blocks mined: {}\", self.blocks_mined);\n        println!(\"  Transactions: {}\", self.transactions_processed);\n        println!(\"  Height: {}\", self.current_height);\n        println!(\"  Peers: {}\", self.peer_count);\n        println!(\"  Sync: {:.1}%\", self.sync_percentage);\n    }\n}\n\nfn main() {\n    let mut metrics = BlockchainMetrics::new();\n    metrics.update(5000, 10);\n    metrics.blocks_mined = 100;\n    metrics.transactions_processed = 50000;\n    metrics.display();\n}",
      "explanation": "Metrics provide quantitative data about blockchain performance. They're essential for monitoring health, performance, and detecting issues early.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-58-1",
      "title": "Metrics Structure",
      "description": "Create a metrics structure for tracking blockchain stats!",
      "starterCode": "struct Metrics {\n    blocks: u64,\n    transactions: u64,\n}\n\n// Implement new(), increment_blocks(), and display()\n\nfn main() {\n    let mut metrics = Metrics::new();\n    metrics.increment_blocks();\n    metrics.display();\n}",
      "solution": "struct Metrics {\n    blocks: u64,\n    transactions: u64,\n}\n\nimpl Metrics {\n    fn new() -> Self {\n        Metrics { blocks: 0, transactions: 0 }\n    }\n    \n    fn increment_blocks(&mut self) {\n        self.blocks += 1;\n    }\n    \n    fn display(&self) {\n        println!(\"Blocks: {}, Transactions: {}\", self.blocks, self.transactions);\n    }\n}\n\nfn main() {\n    let mut metrics = Metrics::new();\n    metrics.increment_blocks();\n    metrics.display();\n}",
      "hints": [
        "Use u64 for counters",
        "Implement methods to update and display"
      ],
      "difficulty": "easy"
    }
  ]
}

