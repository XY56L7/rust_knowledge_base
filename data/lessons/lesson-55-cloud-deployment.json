{
  "id": "lesson-55-cloud-deployment",
  "title": "Cloud Deployment",
  "description": "Deploying Rust blockchain nodes and backends to cloud platforms.",
  "content": "# Cloud Deployment\n\nDeploying Rust blockchain applications to cloud platforms provides scalability, reliability, and global distribution.\n\n## Cloud Platforms\n\n### AWS (Amazon Web Services)\n\n**Services for Rust blockchain:**\n\n- **EC2**: Virtual servers for blockchain nodes\n- **ECS/EKS**: Container orchestration\n- **Lambda**: Serverless functions (limited Rust support)\n- **RDS**: Managed databases\n\n**Deployment:**\n\n```bash\n# Build Docker image\ndocker build -t blockchain-node .\n\n# Push to ECR\naws ecr get-login-password | docker login --username AWS --password-stdin <account>.dkr.ecr.<region>.amazonaws.com\ndocker tag blockchain-node:latest <account>.dkr.ecr.<region>.amazonaws.com/blockchain-node:latest\ndocker push <account>.dkr.ecr.<region>.amazonaws.com/blockchain-node:latest\n\n# Deploy to ECS\naws ecs update-service --cluster blockchain-cluster --service blockchain-node --force-new-deployment\n```\n\n### Google Cloud Platform\n\n**Services:**\n\n- **Cloud Run**: Serverless containers\n- **GKE**: Kubernetes\n- **Compute Engine**: VMs\n\n**Deployment:**\n\n```bash\n# Build and push to GCR\ngcloud builds submit --tag gcr.io/<project>/blockchain-node\n\n# Deploy to Cloud Run\ngcloud run deploy blockchain-node --image gcr.io/<project>/blockchain-node --platform managed\n```\n\n### DigitalOcean\n\n**Services:**\n\n- **Droplets**: VPS instances\n- **App Platform**: Managed containers\n- **Kubernetes**: Managed K8s\n\n**Simple deployment:**\n\n```bash\n# SSH to droplet\nssh root@your-droplet-ip\n\n# Clone and build\ncd /opt\ncargo build --release\n\n# Run as service\nsystemctl enable blockchain-node\nsystemctl start blockchain-node\n```\n\n## Kubernetes Deployment\n\nFor production blockchain networks:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: blockchain-node\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: blockchain-node\n  template:\n    metadata:\n      labels:\n        app: blockchain-node\n    spec:\n      containers:\n      - name: blockchain-node\n        image: blockchain-node:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: RUST_LOG\n          value: \"info\"\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n          limits:\n            memory: \"2Gi\"\n            cpu: \"2000m\"\n```\n\n## Deployment Strategies\n\n### Blue-Green Deployment\n\n- Deploy new version alongside old\n- Switch traffic when ready\n- Instant rollback if issues\n\n### Rolling Updates\n\n- Gradually replace instances\n- Zero downtime\n- Automatic health checks\n\n### Canary Deployment\n\n- Deploy to small subset first\n- Monitor metrics\n- Gradually expand if successful\n\n## Monitoring and Logging\n\n```rust\n// Use tracing for structured logging\nuse tracing::{info, error, warn};\n\nfn main() {\n    tracing_subscriber::fmt::init();\n    \n    info!(target: \"blockchain\", \"Node starting\");\n    \n    // In production, send to:\n    // - CloudWatch (AWS)\n    // - Stackdriver (GCP)\n    // - Datadog, Prometheus, etc.\n}\n```\n\n## Health Checks\n\n```rust\n// Health check endpoint\nasync fn health_check() -> impl Responder {\n    // Check:\n    // - Database connection\n    // - Blockchain sync status\n    // - Memory usage\n    // - Disk space\n    \n    \"OK\"\n}\n```",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": ["lesson-54-docker-deployment"],
  "codeExamples": [
    {
      "id": "ex-55-1-deployment-config",
      "title": "Deployment Configuration",
      "description": "Configuration for cloud deployment",
      "code": "// Deployment configuration structure\nstruct DeploymentConfig {\n    platform: String,\n    region: String,\n    instance_type: String,\n    replicas: u32,\n    environment: HashMap<String, String>,\n}\n\nfn main() {\n    println!(\"Cloud deployment options:\");\n    println!(\"\\n1. AWS:\");\n    println!(\"   - EC2: Full control, manual setup\");\n    println!(\"   - ECS: Container orchestration\");\n    println!(\"   - EKS: Kubernetes on AWS\");\n    \n    println!(\"\\n2. Google Cloud:\");\n    println!(\"   - Cloud Run: Serverless containers\");\n    println!(\"   - GKE: Managed Kubernetes\");\n    \n    println!(\"\\n3. DigitalOcean:\");\n    println!(\"   - Droplets: Simple VPS\");\n    println!(\"   - App Platform: Managed deployment\");\n    \n    println!(\"\\n4. Self-hosted:\");\n    println!(\"   - Your own servers\");\n    println!(\"   - Full control\");\n}",
      "explanation": "Different cloud platforms offer various deployment options. Choose based on your needs: simplicity (DigitalOcean), features (AWS/GCP), or control (self-hosted).",
      "language": "rust"
    },
    {
      "id": "ex-55-2-health-check",
      "title": "Health Check Implementation",
      "description": "Health check endpoint for deployment",
      "code": "// Health check for cloud deployment\nstruct HealthStatus {\n    status: String,\n    version: String,\n    uptime: u64,\n    checks: HashMap<String, bool>,\n}\n\nimpl HealthStatus {\n    fn new() -> Self {\n        let mut checks = HashMap::new();\n        checks.insert(String::from(\"database\"), true);\n        checks.insert(String::from(\"blockchain_sync\"), true);\n        checks.insert(String::from(\"memory\"), true);\n        \n        HealthStatus {\n            status: String::from(\"healthy\"),\n            version: String::from(\"1.0.0\"),\n            uptime: 3600,\n            checks,\n        }\n    }\n    \n    fn is_healthy(&self) -> bool {\n        self.checks.values().all(|&v| v)\n    }\n}\n\nfn main() {\n    let health = HealthStatus::new();\n    \n    if health.is_healthy() {\n        println!(\"Status: {}\", health.status);\n        println!(\"Version: {}\", health.version);\n        println!(\"Uptime: {} seconds\", health.uptime);\n    } else {\n        println!(\"Unhealthy!\");\n    }\n}",
      "explanation": "Health checks are essential for cloud deployment. Load balancers and orchestrators use them to determine if instances are ready to receive traffic.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-55-1",
      "title": "Health Check",
      "description": "Create a simple health check function!",
      "starterCode": "struct HealthCheck {\n    healthy: bool,\n}\n\n// Implement new() and check() methods\n// check() should return true if healthy\n\nfn main() {\n    let health = HealthCheck::new();\n    println!(\"Healthy: {}\", health.check());\n}",
      "solution": "struct HealthCheck {\n    healthy: bool,\n}\n\nimpl HealthCheck {\n    fn new() -> Self {\n        HealthCheck { healthy: true }\n    }\n    \n    fn check(&self) -> bool {\n        self.healthy\n    }\n}\n\nfn main() {\n    let health = HealthCheck::new();\n    println!(\"Healthy: {}\", health.check());\n}",
      "hints": [
        "Simple boolean flag",
        "check() returns the healthy status"
      ],
      "difficulty": "easy"
    }
  ]
}

