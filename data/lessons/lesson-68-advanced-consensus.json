{
  "id": "lesson-68-advanced-consensus",
  "title": "Advanced Consensus Mechanisms",
  "description": "Implementing advanced consensus algorithms: PBFT, Raft, Tendermint, and Byzantine Fault Tolerance.",
  "content": "# Advanced Consensus Mechanisms\n\nBeyond Proof of Work and Proof of Stake, advanced consensus mechanisms provide different trade-offs.\n\n## Consensus Requirements\n\n1. **Safety**: All honest nodes agree on the same value\n2. **Liveness**: The system eventually makes progress\n3. **Fault Tolerance**: Works despite some nodes failing or being malicious\n\n## Byzantine Fault Tolerance (BFT)\n\n**BFT** systems tolerate Byzantine failures - nodes that can behave arbitrarily (lie, crash, etc.).\n\n### PBFT (Practical Byzantine Fault Tolerance)\n\n- **Assumption**: At most f Byzantine nodes out of 3f+1 total\n- **Phases**: Pre-prepare, Prepare, Commit\n- **Finality**: Immediate (no waiting for confirmations)\n- **Use Cases**: Permissioned blockchains, enterprise\n\n### Tendermint Consensus\n\n- **Voting Rounds**: Validators vote on blocks\n- **Lock Mechanism**: Prevents double-spending\n- **Finality**: Blocks are final once committed\n- **Use Cases**: Cosmos, Binance Chain\n\n### Raft Consensus\n\n- **Leader Election**: One leader coordinates\n- **Log Replication**: Leader replicates log to followers\n- **Crash Fault Tolerant**: Doesn't handle Byzantine faults\n- **Use Cases**: Distributed databases, private blockchains\n\n## PBFT Implementation\n\n```rust\nenum PBFTPhase {\n    PrePrepare,\n    Prepare,\n    Commit,\n}\n\nstruct PBFTMessage {\n    phase: PBFTPhase,\n    view: u64,\n    sequence: u64,\n    block_hash: String,\n    sender: String,\n    signature: Vec<u8>,\n}\n\nstruct PBFTNode {\n    id: String,\n    view: u64,\n    prepared: HashMap<u64, HashSet<String>>, // sequence -> set of prepare messages\n    committed: HashSet<u64>,\n}\n\nimpl PBFTNode {\n    fn pre_prepare(&mut self, block_hash: String, sequence: u64) -> PBFTMessage {\n        // Leader sends pre-prepare\n        PBFTMessage {\n            phase: PBFTPhase::PrePrepare,\n            view: self.view,\n            sequence,\n            block_hash,\n            sender: self.id.clone(),\n            signature: vec![],\n        }\n    }\n    \n    fn prepare(&mut self, msg: &PBFTMessage) -> Option<PBFTMessage> {\n        // Node sends prepare after receiving pre-prepare\n        // Need 2f prepares to move to commit\n        let prepares = self.prepared.entry(msg.sequence).or_insert_with(HashSet::new);\n        prepares.insert(msg.sender.clone());\n        \n        if prepares.len() >= 2 {\n            // Have enough prepares\n            Some(PBFTMessage {\n                phase: PBFTPhase::Prepare,\n                view: self.view,\n                sequence: msg.sequence,\n                block_hash: msg.block_hash.clone(),\n                sender: self.id.clone(),\n                signature: vec![],\n            })\n        } else {\n            None\n        }\n    }\n    \n    fn commit(&mut self, msg: &PBFTMessage) -> bool {\n        // Need 2f+1 commits to finalize\n        if msg.phase == PBFTPhase::Commit {\n            self.committed.insert(msg.sequence);\n            self.committed.len() >= 3 // 2f+1 for f=1\n        } else {\n            false\n        }\n    }\n}\n```\n\n## Tendermint Consensus\n\n```rust\nenum TendermintStep {\n    Propose,\n    Prevote,\n    Precommit,\n    Commit,\n}\n\nstruct TendermintVote {\n    step: TendermintStep,\n    height: u64,\n    round: u64,\n    block_hash: Option<String>,\n    validator: String,\n}\n\nstruct TendermintNode {\n    height: u64,\n    round: u64,\n    locked_block: Option<String>,\n    locked_round: Option<u64>,\n    valid_round: Option<u64>,\n}\n\nimpl TendermintNode {\n    fn propose(&mut self, block_hash: String) -> TendermintVote {\n        TendermintVote {\n            step: TendermintStep::Propose,\n            height: self.height,\n            round: self.round,\n            block_hash: Some(block_hash),\n            validator: String::from(\"validator1\"),\n        }\n    }\n    \n    fn prevote(&mut self, block_hash: &str) -> TendermintVote {\n        // Lock on block if valid\n        if self.is_valid_block(block_hash) {\n            self.locked_block = Some(block_hash.to_string());\n            self.locked_round = Some(self.round);\n        }\n        \n        TendermintVote {\n            step: TendermintStep::Prevote,\n            height: self.height,\n            round: self.round,\n            block_hash: Some(block_hash.to_string()),\n            validator: String::from(\"validator1\"),\n        }\n    }\n    \n    fn is_valid_block(&self, _block_hash: &str) -> bool {\n        // Validate block\n        true\n    }\n}\n```\n\n## Comparison\n\n| Mechanism | Fault Tolerance | Finality | Throughput | Use Case |\n|-----------|----------------|----------|------------|----------|\n| PoW | 50% honest | Probabilistic | Low | Public, permissionless |\n| PoS | 33% honest | Probabilistic | Medium | Public, permissionless |\n| PBFT | 33% Byzantine | Immediate | High | Permissioned |\n| Tendermint | 33% Byzantine | Immediate | High | Public, permissioned |\n| Raft | 50% crash | Immediate | Very High | Private |\n\n## Choosing a Consensus\n\n- **Public, Permissionless**: PoW or PoS\n- **High Throughput Needed**: PBFT or Tendermint\n- **Immediate Finality**: BFT-based (PBFT, Tendermint)\n- **Private Network**: Raft or PBFT\n- **Energy Efficiency**: PoS or BFT\n\n## Real-World Examples\n\n- **Hyperledger Fabric**: Uses PBFT\n- **Cosmos**: Uses Tendermint\n- **Ethereum 2.0**: Uses PoS with BFT finality\n- **Solana**: Uses Proof of History + PoS",
  "difficulty": "advanced",
  "estimatedTime": 60,
  "prerequisites": [
    "lesson-37-proof-of-work",
    "lesson-38-proof-of-stake",
    "lesson-39-consensus-implementation"
  ],
  "codeExamples": [
    {
      "id": "ex-68-1-pbft-simple",
      "title": "Simplified PBFT",
      "description": "Basic PBFT consensus implementation",
      "code": "use std::collections::{HashMap, HashSet};\n\nenum Phase {\n    PrePrepare,\n    Prepare,\n    Commit,\n}\n\nstruct Message {\n    phase: Phase,\n    view: u64,\n    sequence: u64,\n    block_hash: String,\n    sender: String,\n}\n\nstruct PBFTNode {\n    id: String,\n    view: u64,\n    prepares: HashMap<u64, HashSet<String>>,\n    commits: HashMap<u64, HashSet<String>>,\n    total_nodes: usize,\n}\n\nimpl PBFTNode {\n    fn new(id: String, total_nodes: usize) -> Self {\n        PBFTNode {\n            id,\n            view: 0,\n            prepares: HashMap::new(),\n            commits: HashMap::new(),\n            total_nodes,\n        }\n    }\n    \n    fn receive_prepare(&mut self, msg: &Message) -> Option<Message> {\n        let prepares = self.prepares.entry(msg.sequence).or_insert_with(HashSet::new);\n        prepares.insert(msg.sender.clone());\n        \n        // Need 2f prepares (where f = (total_nodes - 1) / 3)\n        let f = (self.total_nodes - 1) / 3;\n        let required = 2 * f;\n        \n        if prepares.len() >= required && !self.commits.contains_key(&msg.sequence) {\n            // Send commit\n            Some(Message {\n                phase: Phase::Commit,\n                view: self.view,\n                sequence: msg.sequence,\n                block_hash: msg.block_hash.clone(),\n                sender: self.id.clone(),\n            })\n        } else {\n            None\n        }\n    }\n    \n    fn receive_commit(&mut self, msg: &Message) -> bool {\n        let commits = self.commits.entry(msg.sequence).or_insert_with(HashSet::new);\n        commits.insert(msg.sender.clone());\n        \n        // Need 2f+1 commits to finalize\n        let f = (self.total_nodes - 1) / 3;\n        let required = 2 * f + 1;\n        \n        commits.len() >= required\n    }\n}\n\nfn main() {\n    // 4 nodes: can tolerate 1 Byzantine fault (f=1)\n    let mut node1 = PBFTNode::new(String::from(\"node1\"), 4);\n    \n    // Simulate receiving prepares\n    let prepare_msg = Message {\n        phase: Phase::Prepare,\n        view: 0,\n        sequence: 1,\n        block_hash: String::from(\"block_hash_123\"),\n        sender: String::from(\"node2\"),\n    };\n    \n    // Receive 2 prepares (need 2f = 2 for f=1)\n    node1.receive_prepare(&prepare_msg);\n    let mut prepare2 = prepare_msg;\n    prepare2.sender = String::from(\"node3\");\n    \n    if let Some(commit_msg) = node1.receive_prepare(&prepare2) {\n        println!(\"Node1 sending commit for sequence {}\", commit_msg.sequence);\n        \n        // Receive commits\n        let mut commit1 = commit_msg.clone();\n        commit1.sender = String::from(\"node2\");\n        let mut commit2 = commit_msg.clone();\n        commit2.sender = String::from(\"node3\");\n        \n        if node1.receive_commit(&commit_msg) {\n            println!(\"Block finalized!\");\n        }\n        if node1.receive_commit(&commit1) {\n            println!(\"Block finalized!\");\n        }\n        if node1.receive_commit(&commit2) {\n            println!(\"Block finalized!\");\n        }\n    }\n}",
      "explanation": "PBFT requires 3 phases: pre-prepare (leader proposes), prepare (nodes agree), and commit (nodes finalize). With 4 nodes (f=1), we need 2 prepares and 3 commits to finalize a block. This provides immediate finality unlike PoW/PoS.",
      "language": "rust"
    },
    {
      "id": "ex-68-2-tendermint-voting",
      "title": "Tendermint Voting",
      "description": "Tendermint consensus voting mechanism",
      "code": "enum VoteType {\n    Prevote,\n    Precommit,\n}\n\nstruct Vote {\n    vote_type: VoteType,\n    height: u64,\n    round: u64,\n    block_hash: Option<String>,\n    validator: String,\n}\n\nstruct TendermintValidator {\n    id: String,\n    height: u64,\n    round: u64,\n    prevotes: Vec<Vote>,\n    precommits: Vec<Vote>,\n    locked_block: Option<String>,\n}\n\nimpl TendermintValidator {\n    fn new(id: String) -> Self {\n        TendermintValidator {\n            id,\n            height: 1,\n            round: 0,\n            prevotes: Vec::new(),\n            precommits: Vec::new(),\n            locked_block: None,\n        }\n    }\n    \n    fn receive_prevote(&mut self, vote: Vote) -> bool {\n        if vote.height == self.height && vote.round == self.round {\n            self.prevotes.push(vote);\n            \n            // Check if we have 2/3+ prevotes for a block\n            let block_votes: usize = self.prevotes\n                .iter()\n                .filter(|v| v.block_hash == vote.block_hash)\n                .count();\n            \n            let total_validators = 4; // Simplified\n            let required = (2 * total_validators) / 3 + 1;\n            \n            if block_votes >= required && vote.block_hash.is_some() {\n                // Lock on this block\n                self.locked_block = vote.block_hash.clone();\n                return true;\n            }\n        }\n        false\n    }\n    \n    fn can_precommit(&self) -> bool {\n        self.locked_block.is_some()\n    }\n    \n    fn create_precommit(&self) -> Option<Vote> {\n        if self.can_precommit() {\n            Some(Vote {\n                vote_type: VoteType::Precommit,\n                height: self.height,\n                round: self.round,\n                block_hash: self.locked_block.clone(),\n                validator: self.id.clone(),\n            })\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let mut validator = TendermintValidator::new(String::from(\"validator1\"));\n    \n    // Receive prevotes\n    for i in 0..3 {\n        let vote = Vote {\n            vote_type: VoteType::Prevote,\n            height: 1,\n            round: 0,\n            block_hash: Some(String::from(\"block123\")),\n            validator: format!(\"validator{}\", i + 1),\n        };\n        validator.receive_prevote(vote);\n    }\n    \n    if let Some(precommit) = validator.create_precommit() {\n        println!(\"Validator can precommit for block: {:?}\", precommit.block_hash);\n        println!(\"Block is locked and ready to commit\");\n    }\n}",
      "explanation": "Tendermint uses voting rounds: propose, prevote, precommit. Validators lock on a block after receiving 2/3+ prevotes. Once locked, they can precommit. With 2/3+ precommits, the block is committed. This provides immediate finality.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-68-1",
      "title": "Simple BFT Voting",
      "description": "Create a simple BFT voting system!",
      "starterCode": "struct Vote {\n    block_hash: String,\n    voter: String,\n}\n\nfn main() {\n    // Collect votes\n    // Check if we have 2/3+ votes\n}",
      "solution": "struct Vote {\n    block_hash: String,\n    voter: String,\n}\n\nstruct ConsensusNode {\n    votes: Vec<Vote>,\n    total_nodes: usize,\n}\n\nimpl ConsensusNode {\n    fn new(total_nodes: usize) -> Self {\n        ConsensusNode {\n            votes: Vec::new(),\n            total_nodes,\n        }\n    }\n    \n    fn add_vote(&mut self, vote: Vote) {\n        self.votes.push(vote);\n    }\n    \n    fn has_consensus(&self, block_hash: &str) -> bool {\n        let votes_for_block = self.votes\n            .iter()\n            .filter(|v| v.block_hash == block_hash)\n            .count();\n        \n        // Need 2/3+ votes\n        let required = (2 * self.total_nodes) / 3 + 1;\n        votes_for_block >= required\n    }\n}\n\nfn main() {\n    let mut node = ConsensusNode::new(4);\n    \n    // Add votes\n    node.add_vote(Vote { block_hash: String::from(\"block1\"), voter: String::from(\"v1\") });\n    node.add_vote(Vote { block_hash: String::from(\"block1\"), voter: String::from(\"v2\") });\n    node.add_vote(Vote { block_hash: String::from(\"block1\"), voter: String::from(\"v3\") });\n    \n    println!(\"Consensus reached: {}\", node.has_consensus(\"block1\"));\n}",
      "hints": [
        "Calculate 2/3+ of total nodes",
        "Count votes for the same block",
        "Return true if votes >= required threshold"
      ],
      "difficulty": "hard"
    }
  ]
}

