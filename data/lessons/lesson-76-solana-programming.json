{
  "id": "lesson-76-solana-programming",
  "title": "Solana Programming Model: Accounts, Programs, and PDAs",
  "description": "Learn Solana's unique programming model with accounts, programs, and Program Derived Addresses (PDAs).",
  "content": "# Solana Programming Model: Accounts, Programs, and PDAs\n\n**Solana** uses a unique account-based model different from Ethereum.\n\n## Key Concepts\n\n### Accounts\n\nIn Solana, **everything is an account**:\n\n- **Data Accounts**: Store data\n- **Program Accounts**: Store executable code\n- **System Accounts**: Native programs\n\n### Account Structure\n\n```rust\nstruct AccountInfo {\n    key: Pubkey,           // Account address\n    lamports: u64,         // Balance in lamports (1 SOL = 1e9 lamports)\n    data: Vec<u8>,         // Account data\n    owner: Pubkey,         // Program that owns this account\n    executable: bool,      // Is this a program?\n    rent_epoch: u64,       // Rent epoch\n}\n```\n\n### Programs\n\n**Programs** are Solana's equivalent of smart contracts:\n\n- Written in Rust (or C)\n- Compiled to BPF (Berkeley Packet Filter) bytecode\n- Stateless: Programs don't store data\n- Data stored in separate accounts\n\n### Program Derived Addresses (PDAs)\n\n**PDAs** are program-controlled addresses:\n\n- Derived from program ID + seeds\n- No private key (can't sign)\n- Only the program can sign for them\n- Used for program-owned accounts\n\n## Solana Program Example\n\n```rust\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    pubkey::Pubkey,\n    program_error::ProgramError,\n};\n\n// Program entry point\nentrypoint!(process_instruction);\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    \n    // Get accounts\n    let user_account = next_account_info(accounts_iter)?;\n    let data_account = next_account_info(accounts_iter)?;\n    \n    // Verify ownership\n    if data_account.owner != program_id {\n        return Err(ProgramError::IncorrectProgramId);\n    }\n    \n    // Read/write account data\n    let mut data = data_account.data.borrow_mut();\n    // ... process instruction ...\n    \n    Ok(())\n}\n```\n\n## Key Differences from Ethereum\n\n| Feature | Ethereum | Solana |\n|---------|----------|--------|\n| State | In contract | In accounts |\n| Execution | Sequential | Parallel |\n| Fees | Gas | Compute units |\n| Finality | ~15s | ~400ms |\n| Throughput | ~15 TPS | ~65,000 TPS |\n\n## Account Ownership\n\n```rust\n// Transfer ownership\npub fn transfer_ownership(\n    account: &AccountInfo,\n    new_owner: &Pubkey,\n) -> ProgramResult {\n    // Only current owner can transfer\n    account.assign(new_owner);\n    Ok(())\n}\n\n// Check ownership\npub fn is_owned_by(account: &AccountInfo, owner: &Pubkey) -> bool {\n    account.owner == owner\n}\n```\n\n## PDA (Program Derived Address)\n\n```rust\nuse solana_program::pubkey::Pubkey;\n\n// Find PDA\npub fn find_pda(\n    program_id: &Pubkey,\n    seeds: &[&[u8]],\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(seeds, program_id)\n}\n\n// Example: User's token account PDA\nlet (user_token_pda, bump) = find_pda(\n    &program_id,\n    &[b\"token\", user_pubkey.as_ref()],\n);\n```\n\n## Cross-Program Invocations (CPI)\n\nPrograms can call other programs:\n\n```rust\nuse solana_program::program::invoke;\n\npub fn call_other_program(\n    instruction: &Instruction,\n    account_infos: &[AccountInfo],\n) -> ProgramResult {\n    invoke(instruction, account_infos)?;\n    Ok(())\n}\n```\n\n## Real-World Examples\n\n- **Serum DEX**: Decentralized exchange on Solana\n- **Raydium**: AMM on Solana\n- **Magic Eden**: NFT marketplace\n- **Jupiter**: DEX aggregator\n\n## Advantages\n\n- **High Throughput**: Parallel execution\n- **Low Fees**: ~$0.00025 per transaction\n- **Fast Finality**: Sub-second confirmation\n- **Composability**: Programs can call each other\n\n## Challenges\n\n- **Account Model**: Different from Ethereum\n- **Rent**: Accounts must pay rent\n- **Size Limits**: Accounts have size limits\n- **Learning Curve**: Different programming model",
  "difficulty": "advanced",
  "estimatedTime": 60,
  "prerequisites": [
    "lesson-49-building-blockchain",
    "lesson-41-smart-contract-structure"
  ],
  "codeExamples": [
    {
      "id": "ex-76-1-solana-account",
      "title": "Solana Account Structure",
      "description": "Basic account structure in Solana",
      "code": "// Simplified Solana account model\nuse std::collections::HashMap;\n\n#[derive(Clone)]\npub struct Pubkey([u8; 32]);\n\nstruct Account {\n    key: Pubkey,\n    lamports: u64,\n    data: Vec<u8>,\n    owner: Pubkey,\n    executable: bool,\n}\n\nstruct SolanaState {\n    accounts: HashMap<Pubkey, Account>,\n}\n\nimpl SolanaState {\n    fn new() -> Self {\n        SolanaState {\n            accounts: HashMap::new(),\n        }\n    }\n    \n    fn create_account(&mut self, key: Pubkey, owner: Pubkey, data: Vec<u8>) -> Account {\n        let account = Account {\n            key: key.clone(),\n            lamports: 0,\n            data,\n            owner,\n            executable: false,\n        };\n        self.accounts.insert(key, account.clone());\n        account\n    }\n    \n    fn get_account(&self, key: &Pubkey) -> Option<&Account> {\n        self.accounts.get(key)\n    }\n    \n    fn transfer_lamports(&mut self, from: &Pubkey, to: &Pubkey, amount: u64) -> Result<(), String> {\n        let from_account = self.accounts.get_mut(from)\n            .ok_or(\"From account not found\")?;\n        \n        if from_account.lamports < amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        \n        from_account.lamports -= amount;\n        \n        let to_account = self.accounts.get_mut(to)\n            .ok_or(\"To account not found\")?;\n        to_account.lamports += amount;\n        \n        Ok(())\n    }\n}\n\nfn main() {\n    let mut state = SolanaState::new();\n    \n    let alice_key = Pubkey([1; 32]);\n    let bob_key = Pubkey([2; 32]);\n    \n    // Create accounts\n    state.create_account(alice_key.clone(), Pubkey([0; 32]), vec![]);\n    state.create_account(bob_key.clone(), Pubkey([0; 32]), vec![]);\n    \n    // Set initial balance\n    if let Some(account) = state.accounts.get_mut(&alice_key) {\n        account.lamports = 1_000_000_000; // 1 SOL\n    }\n    \n    // Transfer\n    state.transfer_lamports(&alice_key, &bob_key, 100_000_000).unwrap();\n    \n    println!(\"Solana account model: Everything is an account!\");\n}",
      "explanation": "In Solana, everything is an account. Programs are accounts with executable=true. Data is stored in separate accounts. This enables parallel execution and high throughput.",
      "language": "rust"
    },
    {
      "id": "ex-76-2-pda-concept",
      "title": "Program Derived Address",
      "description": "PDA concept and usage",
      "code": "// Simplified PDA concept\nuse std::collections::HashMap;\n\nstruct Pubkey([u8; 32]);\n\nstruct PDA {\n    program_id: Pubkey,\n    seeds: Vec<Vec<u8>>,\n    address: Pubkey,\n    bump: u8,\n}\n\nfn find_pda(program_id: &Pubkey, seeds: &[&[u8]]) -> (Pubkey, u8) {\n    // Simplified: In real Solana, uses find_program_address\n    // Combines seeds + program_id + bump to find valid address\n    let combined: Vec<u8> = seeds.iter()\n        .flat_map(|s| s.iter().copied())\n        .chain(program_id.0.iter().copied())\n        .collect();\n    \n    // Simplified hash\n    let mut address = [0u8; 32];\n    for (i, &byte) in combined.iter().take(32).enumerate() {\n        address[i] = byte;\n    }\n    \n    (Pubkey(address), 255) // Simplified bump\n}\n\nstruct Program {\n    id: Pubkey,\n    pdas: HashMap<Pubkey, PDA>,\n}\n\nimpl Program {\n    fn new(id: Pubkey) -> Self {\n        Program {\n            id,\n            pdas: HashMap::new(),\n        }\n    }\n    \n    fn create_pda(&mut self, seeds: &[&[u8]]) -> Pubkey {\n        let (address, bump) = find_pda(&self.id, seeds);\n        \n        let pda = PDA {\n            program_id: self.id.clone(),\n            seeds: seeds.iter().map(|s| s.to_vec()).collect(),\n            address: address.clone(),\n            bump,\n        };\n        \n        self.pdas.insert(address.clone(), pda);\n        address\n    }\n}\n\nfn main() {\n    let program_id = Pubkey([1; 32]);\n    let mut program = Program::new(program_id);\n    \n    // Create PDA for user token account\n    let user_pubkey = b\"user123\";\n    let pda = program.create_pda(&[b\"token\", user_pubkey]);\n    \n    println!(\"Created PDA for user token account\");\n    println!(\"PDA can only be controlled by the program!\");\n}",
      "explanation": "PDAs are addresses derived from a program ID and seeds. They have no private key, so only the program can sign for them. This enables programs to own accounts and manage state.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-76-1",
      "title": "Simple Account Transfer",
      "description": "Create a simple account transfer function!",
      "starterCode": "struct Account {\n    lamports: u64,\n}\n\nfn main() {\n    // Create two accounts\n    // Transfer lamports between them\n}",
      "solution": "struct Account {\n    lamports: u64,\n}\n\nfn transfer(from: &mut Account, to: &mut Account, amount: u64) -> Result<(), String> {\n    if from.lamports < amount {\n        return Err(\"Insufficient balance\".to_string());\n    }\n    \n    from.lamports -= amount;\n    to.lamports += amount;\n    \n    Ok(())\n}\n\nfn main() {\n    let mut alice = Account { lamports: 1_000_000_000 };\n    let mut bob = Account { lamports: 0 };\n    \n    transfer(&mut alice, &mut bob, 100_000_000).unwrap();\n    \n    println!(\"Alice: {} lamports\", alice.lamports);\n    println!(\"Bob: {} lamports\", bob.lamports);\n}",
      "hints": [
        "Check balance before transferring",
        "Update both accounts",
        "Return Result for error handling"
      ],
      "difficulty": "medium"
    }
  ]
}

