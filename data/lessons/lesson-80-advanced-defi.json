{
  "id": "lesson-80-advanced-defi",
  "title": "Advanced DeFi: Flash Loans, Liquidations, Yield Farming",
  "description": "Deep dive into advanced DeFi: flash loans, liquidation mechanisms, yield farming, options, and stablecoins.",
  "content": "# Advanced DeFi: Flash Loans, Liquidations, Yield Farming\n\nAdvanced DeFi protocols enable complex financial operations on-chain.\n\n## Flash Loans\n\n**Flash loans** allow borrowing without collateral, but must be repaid in the same transaction.\n\n### Implementation\n\n```rust\nstruct FlashLoanPool {\n    reserves: u64,\n    fee_percentage: u8, // e.g., 9 = 0.09%\n}\n\nstruct FlashLoan {\n    amount: u64,\n    token: String,\n    borrower: String,\n    callback: String, // Function to call\n}\n\nimpl FlashLoanPool {\n    fn flash_loan(\n        &mut self,\n        amount: u64,\n        borrower: &str,\n        callback_data: Vec<u8>,\n    ) -> Result<(), String> {\n        // Check sufficient reserves\n        if amount > self.reserves {\n            return Err(String::from(\"Insufficient reserves\"));\n        }\n        \n        // Transfer funds to borrower\n        self.reserves -= amount;\n        // In real implementation: transfer tokens\n        \n        // Execute callback (borrower's logic)\n        self.execute_callback(borrower, callback_data)?;\n        \n        // Calculate repayment (amount + fee)\n        let fee = (amount * self.fee_percentage as u64) / 10000;\n        let repayment = amount + fee;\n        \n        // Verify repayment\n        // In real implementation: check balance increased by repayment\n        if !self.verify_repayment(borrower, repayment) {\n            return Err(String::from(\"Flash loan not repaid\"));\n        }\n        \n        // Add repayment to reserves\n        self.reserves += repayment;\n        \n        Ok(())\n    }\n    \n    fn execute_callback(&self, borrower: &str, data: Vec<u8>) -> Result<(), String> {\n        // Execute borrower's contract function\n        // This is where they use the loan\n        Ok(())\n    }\n    \n    fn verify_repayment(&self, borrower: &str, required: u64) -> bool {\n        // Check borrower's balance increased by required amount\n        // Simplified\n        true\n    }\n}\n```\n\n### Use Cases\n\n- **Arbitrage**: Exploit price differences\n- **Collateral Swaps**: Swap collateral in one transaction\n- **Liquidation**: Liquidate and repay in one transaction\n- **Debt Refinancing**: Repay old loan, take new loan\n\n## Liquidations\n\n**Liquidations** occur when collateral value falls below required threshold.\n\n### Implementation\n\n```rust\nstruct Position {\n    borrower: String,\n    collateral_amount: u64,\n    collateral_token: String,\n    debt_amount: u64,\n    debt_token: String,\n    collateralization_ratio: u64, // e.g., 15000 = 150%\n}\n\nstruct LiquidationEngine {\n    min_collateralization: u64, // e.g., 15000 = 150%\n    liquidation_bonus: u8,      // e.g., 5 = 5% bonus\n    price_oracle: PriceOracle,\n}\n\nimpl LiquidationEngine {\n    fn check_liquidation(&self, position: &Position) -> bool {\n        let collateral_value = self.price_oracle.get_value(\n            &position.collateral_token,\n            position.collateral_amount\n        );\n        \n        let debt_value = self.price_oracle.get_value(\n            &position.debt_token,\n            position.debt_amount\n        );\n        \n        // Calculate collateralization ratio\n        let ratio = if debt_value > 0 {\n            (collateral_value * 10000) / debt_value\n        } else {\n            u64::MAX\n        };\n        \n        // Liquidatable if below minimum\n        ratio < self.min_collateralization\n    }\n    \n    fn liquidate(\n        &mut self,\n        position: &mut Position,\n        liquidator: &str,\n        repay_amount: u64,\n    ) -> Result<u64, String> {\n        if !self.check_liquidation(position) {\n            return Err(String::from(\"Position not liquidatable\"));\n        }\n        \n        if repay_amount > position.debt_amount {\n            return Err(String::from(\"Repay amount exceeds debt\"));\n        }\n        \n        // Calculate collateral to seize (with bonus)\n        let collateral_value = self.price_oracle.get_value(\n            &position.collateral_token,\n            position.collateral_amount\n        );\n        \n        let debt_value = self.price_oracle.get_value(\n            &position.debt_token,\n            repay_amount\n        );\n        \n        let bonus = (debt_value * self.liquidation_bonus as u64) / 100;\n        let collateral_to_seize_value = debt_value + bonus;\n        \n        let collateral_to_seize = (collateral_to_seize_value * position.collateral_amount) / collateral_value;\n        \n        // Update position\n        position.debt_amount -= repay_amount;\n        position.collateral_amount -= collateral_to_seize;\n        \n        // Transfer collateral to liquidator\n        // Transfer repaid debt to protocol\n        \n        Ok(collateral_to_seize)\n    }\n}\n```\n\n## Yield Farming\n\n**Yield farming** involves providing liquidity to earn rewards.\n\n### Implementation\n\n```rust\nstruct YieldFarm {\n    staking_token: String,\n    reward_token: String,\n    total_staked: u64,\n    reward_per_block: u64,\n    last_update_block: u64,\n    acc_reward_per_share: u128, // Accumulated rewards per share\n}\n\nstruct UserStake {\n    amount: u64,\n    reward_debt: u128, // Rewards already accounted for\n}\n\nimpl YieldFarm {\n    fn stake(&mut self, user: &str, amount: u64, user_stakes: &mut HashMap<String, UserStake>) {\n        self.update_pool();\n        \n        let user_stake = user_stakes.entry(user.to_string()).or_insert(UserStake {\n            amount: 0,\n            reward_debt: 0,\n        });\n        \n        // Calculate pending rewards\n        let pending = self.calculate_pending_rewards(user_stake);\n        \n        // Update stake\n        user_stake.amount += amount;\n        user_stake.reward_debt = (user_stake.amount as u128 * self.acc_reward_per_share) / 1e12;\n        \n        self.total_staked += amount;\n    }\n    \n    fn update_pool(&mut self) {\n        let current_block = 1000; // Simplified\n        \n        if self.total_staked > 0 {\n            let blocks_elapsed = current_block - self.last_update_block;\n            let reward = blocks_elapsed * self.reward_per_block;\n            \n            self.acc_reward_per_share += (reward as u128 * 1e12) / self.total_staked as u128;\n        }\n        \n        self.last_update_block = current_block;\n    }\n    \n    fn calculate_pending_rewards(&self, user_stake: &UserStake) -> u64 {\n        if self.total_staked == 0 {\n            return 0;\n        }\n        \n        let user_reward = (user_stake.amount as u128 * self.acc_reward_per_share) / 1e12;\n        let pending = user_reward.saturating_sub(user_stake.reward_debt);\n        \n        pending as u64\n    }\n}\n```\n\n## Options and Derivatives\n\n### Call Option\n\n```rust\nstruct CallOption {\n    strike_price: u64,\n    expiration: u64,\n    premium: u64,\n    underlying: String,\n}\n\nimpl CallOption {\n    fn exercise(&self, current_price: u64, block_number: u64) -> Option<u64> {\n        if block_number > self.expiration {\n            return None; // Expired\n        }\n        \n        if current_price > self.strike_price {\n            // In the money\n            Some(current_price - self.strike_price)\n        } else {\n            None // Out of the money\n        }\n    }\n}\n```\n\n## Stablecoin Mechanisms\n\n### Algorithmic Stablecoin\n\n```rust\nstruct AlgorithmicStablecoin {\n    target_price: u64, // e.g., $1.00\n    supply: u64,\n    collateral_ratio: u64, // e.g., 150% = 15000\n}\n\nimpl AlgorithmicStablecoin {\n    fn rebase(&mut self, current_price: u64) {\n        if current_price > self.target_price {\n            // Price too high: increase supply (inflation)\n            let increase = (self.supply * (current_price - self.target_price)) / self.target_price;\n            self.supply += increase;\n        } else if current_price < self.target_price {\n            // Price too low: decrease supply (deflation)\n            let decrease = (self.supply * (self.target_price - current_price)) / self.target_price;\n            self.supply = self.supply.saturating_sub(decrease);\n        }\n    }\n}\n```\n\n## Real-World Examples\n\n- **Aave**: Flash loans, liquidations\n- **Compound**: Lending with liquidations\n- **Yearn Finance**: Yield farming aggregator\n- **MakerDAO**: DAI stablecoin\n- **dYdX**: Options and perpetuals",
  "difficulty": "advanced",
  "estimatedTime": 65,
  "prerequisites": [
    "lesson-70-defi-protocols",
    "lesson-77-oracle-integration"
  ],
  "codeExamples": [
    {
      "id": "ex-80-1-flash-loan",
      "title": "Flash Loan Implementation",
      "description": "Basic flash loan mechanism",
      "code": "struct FlashLoanPool {\n    reserves: u64,\n    fee_bps: u64, // Basis points (e.g., 9 = 0.09%)\n}\n\nimpl FlashLoanPool {\n    fn new() -> Self {\n        FlashLoanPool {\n            reserves: 1_000_000,\n            fee_bps: 9, // 0.09%\n        }\n    }\n    \n    fn flash_loan(\n        &mut self,\n        amount: u64,\n        callback: fn(u64) -> u64,\n    ) -> Result<u64, String> {\n        if amount > self.reserves {\n            return Err(String::from(\"Insufficient reserves\"));\n        }\n        \n        // Lend funds\n        self.reserves -= amount;\n        \n        // Execute callback (borrower's logic)\n        let profit = callback(amount);\n        \n        // Calculate repayment\n        let fee = (amount * self.fee_bps) / 10000;\n        let repayment = amount + fee;\n        \n        // Verify repayment (simplified: assume callback returns profit)\n        // In real implementation: check contract balance increased\n        if profit < repayment {\n            return Err(String::from(\"Flash loan not repaid\"));\n        }\n        \n        // Repay loan\n        self.reserves += repayment;\n        \n        Ok(profit - repayment)\n    }\n}\n\n// Example: Arbitrage using flash loan\nfn arbitrage_callback(loan_amount: u64) -> u64 {\n    // Buy on DEX A\n    let tokens_bought = loan_amount * 2; // Simplified\n    \n    // Sell on DEX B\n    let proceeds = tokens_bought * 3 / 2; // Simplified\n    \n    proceeds\n}\n\nfn main() {\n    let mut pool = FlashLoanPool::new();\n    \n    match pool.flash_loan(100_000, arbitrage_callback) {\n        Ok(profit) => {\n            println!(\"Flash loan successful! Profit: {}\", profit);\n            println!(\"Loan was borrowed and repaid in same transaction!\");\n        }\n        Err(e) => println!(\"Flash loan failed: {}\", e),\n    }\n}",
      "explanation": "Flash loans allow borrowing without collateral, but must be repaid in the same transaction. This enables arbitrage, liquidations, and other complex DeFi operations that weren't possible before.",
      "language": "rust"
    },
    {
      "id": "ex-80-2-liquidation",
      "title": "Liquidation System",
      "description": "Collateral liquidation mechanism",
      "code": "struct Position {\n    collateral: u64,\n    debt: u64,\n    collateral_price: u64, // Price per unit\n    debt_price: u64,\n}\n\nstruct LiquidationEngine {\n    min_ratio: u64, // e.g., 15000 = 150%\n    bonus: u8,      // e.g., 5 = 5%\n}\n\nimpl LiquidationEngine {\n    fn new() -> Self {\n        LiquidationEngine {\n            min_ratio: 15000, // 150%\n            bonus: 5,         // 5%\n        }\n    }\n    \n    fn is_liquidatable(&self, position: &Position) -> bool {\n        let collateral_value = position.collateral * position.collateral_price;\n        let debt_value = position.debt * position.debt_price;\n        \n        if debt_value == 0 {\n            return false;\n        }\n        \n        let ratio = (collateral_value * 10000) / debt_value;\n        ratio < self.min_ratio\n    }\n    \n    fn liquidate(\n        &self,\n        position: &mut Position,\n        repay_amount: u64,\n    ) -> Result<u64, String> {\n        if !self.is_liquidatable(position) {\n            return Err(String::from(\"Position not liquidatable\"));\n        }\n        \n        let debt_value = repay_amount * position.debt_price;\n        let bonus = (debt_value * self.bonus as u64) / 100;\n        let collateral_value = debt_value + bonus;\n        \n        let collateral_seized = (collateral_value * position.collateral) / \n                                (position.collateral * position.collateral_price);\n        \n        if collateral_seized > position.collateral {\n            return Err(String::from(\"Cannot seize more than available\"));\n        }\n        \n        position.debt -= repay_amount;\n        position.collateral -= collateral_seized;\n        \n        Ok(collateral_seized)\n    }\n}\n\nfn main() {\n    let engine = LiquidationEngine::new();\n    \n    let mut position = Position {\n        collateral: 1000,      // 1000 ETH\n        debt: 500_000,         // 500k USDC\n        collateral_price: 2000, // $2000/ETH\n        debt_price: 1,         // $1/USDC\n    };\n    \n    // Check if liquidatable\n    let collateral_value = position.collateral * position.collateral_price;\n    let debt_value = position.debt * position.debt_price;\n    let ratio = (collateral_value * 10000) / debt_value;\n    \n    println!(\"Collateralization ratio: {}%\", ratio as f64 / 100.0);\n    \n    if engine.is_liquidatable(&position) {\n        println!(\"Position is liquidatable!\");\n        \n        // Liquidate half the debt\n        match engine.liquidate(&mut position, position.debt / 2) {\n            Ok(collateral_seized) => {\n                println!(\"Liquidated! Seized {} collateral\", collateral_seized);\n                println!(\"Remaining debt: {}\", position.debt);\n                println!(\"Remaining collateral: {}\", position.collateral);\n            }\n            Err(e) => println!(\"Liquidation failed: {}\", e),\n        }\n    } else {\n        println!(\"Position is healthy\");\n    }\n}",
      "explanation": "Liquidations protect lending protocols by allowing anyone to repay undercollateralized debt in exchange for collateral at a discount. This ensures the protocol remains solvent.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-80-1",
      "title": "Flash Loan Repayment",
      "description": "Calculate flash loan repayment with fee!",
      "starterCode": "fn calculate_repayment(amount: u64, fee_bps: u64) -> u64 {\n    // Calculate amount + fee\n    // fee_bps is in basis points (10000 = 100%)\n}",
      "solution": "fn calculate_repayment(amount: u64, fee_bps: u64) -> u64 {\n    let fee = (amount * fee_bps) / 10000;\n    amount + fee\n}\n\nfn main() {\n    let amount = 100_000;\n    let fee_bps = 9; // 0.09%\n    \n    let repayment = calculate_repayment(amount, fee_bps);\n    println!(\"Loan: {}, Repayment: {}\", amount, repayment);\n}",
      "hints": [
        "Fee = (amount * fee_bps) / 10000",
        "Repayment = amount + fee"
      ],
      "difficulty": "easy"
    }
  ]
}

