{
  "id": "lesson-81-nft-marketplace",
  "title": "NFT Marketplace: Implementation, Royalties, and IPFS",
  "description": "Building a complete NFT marketplace with royalties, IPFS metadata integration, and lazy minting.",
  "content": "# NFT Marketplace: Implementation, Royalties, and IPFS\n\nBuilding a complete NFT marketplace with advanced features.\n\n## Marketplace Components\n\n### 1. Listing System\n\n```rust\nenum ListingStatus {\n    Active,\n    Sold,\n    Cancelled,\n}\n\nstruct Listing {\n    id: u64,\n    token_id: u64,\n    collection: String,\n    seller: String,\n    price: u64,\n    status: ListingStatus,\n    expires_at: u64,\n}\n\nstruct Marketplace {\n    listings: HashMap<u64, Listing>,\n    next_listing_id: u64,\n    fee_percentage: u8, // e.g., 25 = 2.5%\n}\n\nimpl Marketplace {\n    fn list_nft(\n        &mut self,\n        token_id: u64,\n        collection: &str,\n        seller: &str,\n        price: u64,\n        expires_at: u64,\n    ) -> Result<u64, String> {\n        // Verify seller owns NFT\n        // Create listing\n        \n        let listing_id = self.next_listing_id;\n        self.next_listing_id += 1;\n        \n        let listing = Listing {\n            id: listing_id,\n            token_id,\n            collection: collection.to_string(),\n            seller: seller.to_string(),\n            price,\n            status: ListingStatus::Active,\n            expires_at,\n        };\n        \n        self.listings.insert(listing_id, listing);\n        Ok(listing_id)\n    }\n    \n    fn buy_nft(\n        &mut self,\n        listing_id: u64,\n        buyer: &str,\n    ) -> Result<(), String> {\n        let listing = self.listings.get_mut(&listing_id)\n            .ok_or(\"Listing not found\")?;\n        \n        if !matches!(listing.status, ListingStatus::Active) {\n            return Err(String::from(\"Listing not active\"));\n        }\n        \n        // Calculate fees\n        let marketplace_fee = (listing.price * self.fee_percentage as u64) / 1000;\n        let seller_payment = listing.price - marketplace_fee;\n        \n        // Transfer NFT to buyer\n        // Transfer payment to seller\n        // Transfer fee to marketplace\n        \n        listing.status = ListingStatus::Sold;\n        \n        Ok(())\n    }\n}\n```\n\n### 2. Royalty System\n\n```rust\nstruct RoyaltyInfo {\n    recipient: String,\n    percentage: u8, // e.g., 100 = 10%\n}\n\nstruct NFTCollection {\n    royalty_info: Option<RoyaltyInfo>,\n    royalty_enforced: bool,\n}\n\nimpl Marketplace {\n    fn calculate_royalties(\n        &self,\n        collection: &str,\n        sale_price: u64,\n    ) -> Option<(String, u64)> {\n        // Get collection royalty info\n        // Calculate royalty amount\n        \n        // Simplified: assume 10% royalty\n        let royalty_percentage = 10;\n        let royalty_amount = (sale_price * royalty_percentage as u64) / 100;\n        \n        Some((String::from(\"royalty_recipient\"), royalty_amount))\n    }\n    \n    fn buy_with_royalties(\n        &mut self,\n        listing_id: u64,\n        buyer: &str,\n    ) -> Result<(), String> {\n        let listing = self.listings.get(&listing_id)\n            .ok_or(\"Listing not found\")?;\n        \n        let total_price = listing.price;\n        \n        // Calculate royalties\n        let (royalty_recipient, royalty_amount) = self\n            .calculate_royalties(&listing.collection, total_price)\n            .ok_or(\"Royalty calculation failed\")?;\n        \n        // Calculate marketplace fee\n        let marketplace_fee = (total_price * self.fee_percentage as u64) / 1000;\n        \n        // Seller receives: price - marketplace_fee - royalty\n        let seller_payment = total_price - marketplace_fee - royalty_amount;\n        \n        // Transfer payments\n        // - Royalty to creator\n        // - Marketplace fee to marketplace\n        // - Remaining to seller\n        \n        Ok(())\n    }\n}\n```\n\n### 3. IPFS Metadata\n\n```rust\nstruct NFTMetadata {\n    name: String,\n    description: String,\n    image_ipfs_hash: String, // IPFS CID\n    attributes: Vec<Attribute>,\n    external_url: Option<String>,\n}\n\nstruct Attribute {\n    trait_type: String,\n    value: String,\n}\n\nstruct IPFSStorage {\n    gateway: String, // e.g., \"https://ipfs.io/ipfs/\"\n}\n\nimpl IPFSStorage {\n    fn get_metadata_url(&self, ipfs_hash: &str) -> String {\n        format!(\"{}{}\", self.gateway, ipfs_hash)\n    }\n    \n    fn validate_ipfs_hash(&self, hash: &str) -> bool {\n        // Validate IPFS CID format\n        hash.starts_with(\"Qm\") || hash.starts_with(\"bafy\")\n    }\n}\n\nstruct NFT {\n    token_id: u64,\n    owner: String,\n    metadata_ipfs: String,\n    metadata: Option<NFTMetadata>,\n}\n\nimpl NFT {\n    fn fetch_metadata(&mut self, ipfs: &IPFSStorage) -> Result<(), String> {\n        if !ipfs.validate_ipfs_hash(&self.metadata_ipfs) {\n            return Err(String::from(\"Invalid IPFS hash\"));\n        }\n        \n        // In real implementation: fetch from IPFS\n        // For now: create placeholder\n        self.metadata = Some(NFTMetadata {\n            name: format!(\"NFT #{}\", self.token_id),\n            description: String::from(\"An awesome NFT\"),\n            image_ipfs_hash: self.metadata_ipfs.clone(),\n            attributes: vec![\n                Attribute {\n                    trait_type: String::from(\"Rarity\"),\n                    value: String::from(\"Common\"),\n                },\n            ],\n            external_url: None,\n        });\n        \n        Ok(())\n    }\n}\n```\n\n### 4. Lazy Minting\n\n**Lazy minting** allows creating NFTs without paying gas until first sale.\n\n```rust\nstruct LazyMintListing {\n    id: u64,\n    creator: String,\n    metadata_ipfs: String,\n    price: u64,\n    signature: Vec<u8>, // Creator's signature\n    status: ListingStatus,\n}\n\nstruct LazyMintingMarketplace {\n    lazy_listings: HashMap<u64, LazyMintListing>,\n    next_id: u64,\n}\n\nimpl LazyMintingMarketplace {\n    fn create_lazy_listing(\n        &mut self,\n        creator: &str,\n        metadata_ipfs: String,\n        price: u64,\n        signature: Vec<u8>,\n    ) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let listing = LazyMintListing {\n            id,\n            creator: creator.to_string(),\n            metadata_ipfs,\n            price,\n            signature,\n            status: ListingStatus::Active,\n        };\n        \n        self.lazy_listings.insert(id, listing);\n        id\n    }\n    \n    fn buy_lazy_minted(\n        &mut self,\n        listing_id: u64,\n        buyer: &str,\n    ) -> Result<u64, String> {\n        let listing = self.lazy_listings.get_mut(&listing_id)\n            .ok_or(\"Listing not found\")?;\n        \n        // Verify signature\n        if !self.verify_signature(listing) {\n            return Err(String::from(\"Invalid signature\"));\n        }\n        \n        // Mint NFT (now that buyer pays gas)\n        let token_id = self.mint_nft(\n            buyer,\n            &listing.metadata_ipfs,\n            &listing.creator,\n        )?;\n        \n        // Transfer payment to creator\n        // No marketplace fee on lazy minting (or reduced)\n        \n        listing.status = ListingStatus::Sold;\n        \n        Ok(token_id)\n    }\n    \n    fn verify_signature(&self, listing: &LazyMintListing) -> bool {\n        // Verify creator's signature\n        // Ensures listing is authorized\n        true\n    }\n    \n    fn mint_nft(\n        &self,\n        owner: &str,\n        metadata_ipfs: &str,\n        creator: &str,\n    ) -> Result<u64, String> {\n        // Mint NFT with metadata\n        // Set creator for royalties\n        Ok(1)\n    }\n}\n```\n\n## Auction System\n\n```rust\nenum AuctionStatus {\n    Active,\n    Ended,\n    Cancelled,\n}\n\nstruct Auction {\n    id: u64,\n    token_id: u64,\n    seller: String,\n    starting_price: u64,\n    reserve_price: u64,\n    highest_bid: u64,\n    highest_bidder: Option<String>,\n    end_time: u64,\n    status: AuctionStatus,\n}\n\nstruct AuctionHouse {\n    auctions: HashMap<u64, Auction>,\n    bids: HashMap<(u64, String), u64>, // (auction_id, bidder) -> bid_amount\n}\n\nimpl AuctionHouse {\n    fn place_bid(\n        &mut self,\n        auction_id: u64,\n        bidder: &str,\n        amount: u64,\n    ) -> Result<(), String> {\n        let auction = self.auctions.get_mut(&auction_id)\n            .ok_or(\"Auction not found\")?;\n        \n        if !matches!(auction.status, AuctionStatus::Active) {\n            return Err(String::from(\"Auction not active\"));\n        }\n        \n        if amount <= auction.highest_bid {\n            return Err(String::from(\"Bid too low\"));\n        }\n        \n        // Refund previous highest bidder\n        if let Some(prev_bidder) = &auction.highest_bidder {\n            // Refund logic\n        }\n        \n        // Set new highest bid\n        auction.highest_bid = amount;\n        auction.highest_bidder = Some(bidder.to_string());\n        self.bids.insert((auction_id, bidder.to_string()), amount);\n        \n        Ok(())\n    }\n    \n    fn end_auction(&mut self, auction_id: u64) -> Result<(), String> {\n        let auction = self.auctions.get_mut(&auction_id)\n            .ok_or(\"Auction not found\")?;\n        \n        if auction.highest_bid < auction.reserve_price {\n            auction.status = AuctionStatus::Cancelled;\n            // Refund highest bidder\n            return Ok(());\n        }\n        \n        // Transfer NFT to highest bidder\n        // Transfer payment to seller\n        \n        auction.status = AuctionStatus::Ended;\n        Ok(())\n    }\n}\n```\n\n## Real-World Examples\n\n- **OpenSea**: Largest NFT marketplace\n- **LooksRare**: Community-owned marketplace\n- **Magic Eden**: Solana NFT marketplace\n- **Rarible**: Creator-focused marketplace\n\n## Best Practices\n\n1. **Royalty Enforcement**: Always pay creator royalties\n2. **IPFS Integration**: Store metadata on IPFS\n3. **Lazy Minting**: Reduce creator costs\n4. **Signature Verification**: Verify lazy minting signatures\n5. **Fee Structure**: Transparent marketplace fees",
  "difficulty": "advanced",
  "estimatedTime": 60,
  "prerequisites": [
    "lesson-69-token-standards",
    "lesson-34-digital-signatures"
  ],
  "codeExamples": [
    {
      "id": "ex-81-1-marketplace",
      "title": "NFT Marketplace",
      "description": "Basic NFT marketplace with listings",
      "code": "use std::collections::HashMap;\n\nenum ListingStatus {\n    Active,\n    Sold,\n}\n\nstruct Listing {\n    id: u64,\n    token_id: u64,\n    seller: String,\n    price: u64,\n    status: ListingStatus,\n}\n\nstruct Marketplace {\n    listings: HashMap<u64, Listing>,\n    next_id: u64,\n    fee_percentage: u8,\n}\n\nimpl Marketplace {\n    fn new() -> Self {\n        Marketplace {\n            listings: HashMap::new(),\n            next_id: 1,\n            fee_percentage: 25, // 2.5%\n        }\n    }\n    \n    fn list_nft(\n        &mut self,\n        token_id: u64,\n        seller: &str,\n        price: u64,\n    ) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        self.listings.insert(id, Listing {\n            id,\n            token_id,\n            seller: seller.to_string(),\n            price,\n            status: ListingStatus::Active,\n        });\n        \n        id\n    }\n    \n    fn buy_nft(\n        &mut self,\n        listing_id: u64,\n        buyer: &str,\n    ) -> Result<u64, String> {\n        let listing = self.listings.get_mut(&listing_id)\n            .ok_or(\"Listing not found\")?;\n        \n        if matches!(listing.status, ListingStatus::Sold) {\n            return Err(String::from(\"Already sold\"));\n        }\n        \n        // Calculate fees\n        let marketplace_fee = (listing.price * self.fee_percentage as u64) / 1000;\n        let seller_payment = listing.price - marketplace_fee;\n        \n        println!(\"Buying NFT #{} for {}\", listing.token_id, listing.price);\n        println!(\"Marketplace fee: {}\", marketplace_fee);\n        println!(\"Seller receives: {}\", seller_payment);\n        \n        listing.status = ListingStatus::Sold;\n        \n        Ok(listing.token_id)\n    }\n}\n\nfn main() {\n    let mut marketplace = Marketplace::new();\n    \n    // List NFT\n    let listing_id = marketplace.list_nft(1, \"alice\", 1000);\n    println!(\"NFT listed with ID: {}\", listing_id);\n    \n    // Buy NFT\n    match marketplace.buy_nft(listing_id, \"bob\") {\n        Ok(token_id) => {\n            println!(\"NFT #{} purchased successfully!\", token_id);\n        }\n        Err(e) => println!(\"Purchase failed: {}\", e),\n    }\n}",
      "explanation": "NFT marketplaces enable buying and selling NFTs. They charge a fee on each sale. Listings track the NFT, seller, price, and status. When bought, the NFT transfers to the buyer and payment goes to the seller (minus fees).",
      "language": "rust"
    },
    {
      "id": "ex-81-2-royalties",
      "title": "Royalty System",
      "description": "Calculate and distribute royalties",
      "code": "struct RoyaltyInfo {\n    recipient: String,\n    percentage: u8, // e.g., 100 = 10%\n}\n\nstruct Sale {\n    price: u64,\n    marketplace_fee_percent: u8,\n    royalty_info: Option<RoyaltyInfo>,\n}\n\nimpl Sale {\n    fn calculate_payments(&self) -> (u64, u64, u64) {\n        // Marketplace fee\n        let marketplace_fee = (self.price * self.marketplace_fee_percent as u64) / 1000;\n        \n        // Royalty\n        let (royalty_amount, royalty_recipient) = if let Some(ref royalty) = self.royalty_info {\n            let amount = (self.price * royalty.percentage as u64) / 1000;\n            (amount, royalty.recipient.clone())\n        } else {\n            (0, String::new())\n        };\n        \n        // Seller payment\n        let seller_payment = self.price - marketplace_fee - royalty_amount;\n        \n        (marketplace_fee, royalty_amount, seller_payment)\n    }\n}\n\nfn main() {\n    let sale = Sale {\n        price: 1000,\n        marketplace_fee_percent: 25, // 2.5%\n        royalty_info: Some(RoyaltyInfo {\n            recipient: String::from(\"0xCreator\"),\n            percentage: 100, // 10%\n        }),\n    };\n    \n    let (marketplace_fee, royalty, seller_payment) = sale.calculate_payments();\n    \n    println!(\"Sale price: {}\", sale.price);\n    println!(\"Marketplace fee: {}\", marketplace_fee);\n    println!(\"Royalty to creator: {}\", royalty);\n    println!(\"Seller receives: {}\", seller_payment);\n    println!(\"Total: {}\", marketplace_fee + royalty + seller_payment);\n}",
      "explanation": "Royalties ensure creators get paid on secondary sales. The sale price is split between marketplace fee, creator royalty, and seller payment. This incentivizes creators and is a key feature of NFT marketplaces.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-81-1",
      "title": "Calculate Marketplace Fee",
      "description": "Calculate marketplace fee from sale price!",
      "starterCode": "fn calculate_fee(price: u64, fee_percent: u8) -> u64 {\n    // fee_percent is in basis points (1000 = 100%)\n    // e.g., 25 = 2.5%\n}",
      "solution": "fn calculate_fee(price: u64, fee_percent: u8) -> u64 {\n    (price * fee_percent as u64) / 1000\n}\n\nfn main() {\n    let price = 1000;\n    let fee_percent = 25; // 2.5%\n    \n    let fee = calculate_fee(price, fee_percent);\n    println!(\"Price: {}, Fee: {}, Seller receives: {}\", price, fee, price - fee);\n}",
      "hints": [
        "Fee = (price * fee_percent) / 1000",
        "fee_percent is in basis points (1000 = 100%)"
      ],
      "difficulty": "easy"
    }
  ]
}

