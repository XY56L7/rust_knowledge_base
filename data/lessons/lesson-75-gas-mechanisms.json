{
  "id": "lesson-75-gas-mechanisms",
  "title": "Gas Mechanisms and Fee Markets",
  "description": "Understanding gas calculation, fee markets (EIP-1559), and priority fee mechanisms in blockchain.",
  "content": "# Gas Mechanisms and Fee Markets\n\n**Gas** is the unit that measures computational work in blockchain transactions.\n\n## Why Gas?\n\n- **Prevent Spam**: Costly to execute many transactions\n- **Resource Limits**: Prevent infinite loops\n- **Fair Pricing**: Pay for actual computation\n- **Network Stability**: Regulate transaction throughput\n\n## Gas Calculation\n\n### Gas Costs\n\nDifferent operations cost different amounts:\n\n- **Simple Transfer**: 21,000 gas\n- **Contract Creation**: 32,000 + code size\n- **Storage Write**: 20,000 gas (first time), 5,000 (update)\n- **Storage Read**: 2,100 gas\n- **SHA3**: 30 gas + 6 per word\n\n### Gas Price\n\n**Gas Price** is how much you pay per unit of gas (in wei/gas).\n\n```rust\nstruct Transaction {\n    gas_limit: u64,\n    gas_price: u64, // wei per gas\n    // ...\n}\n\nfn calculate_fee(tx: &Transaction) -> u64 {\n    tx.gas_limit * tx.gas_price\n}\n```\n\n## EIP-1559 Fee Market\n\nEIP-1559 introduced a new fee structure:\n\n### Components\n\n1. **Base Fee**: Burned, adjusts per block\n2. **Priority Fee**: Goes to miner/validator\n3. **Max Fee**: Maximum user willing to pay\n\n### Implementation\n\n```rust\nstruct EIP1559Transaction {\n    max_fee_per_gas: u64,\n    max_priority_fee_per_gas: u64,\n    gas_limit: u64,\n}\n\nstruct Block {\n    base_fee: u64,\n    transactions: Vec<EIP1559Transaction>,\n}\n\nfn calculate_fee(tx: &EIP1559Transaction, base_fee: u64) -> (u64, u64) {\n    // Effective gas price = min(max_fee, base_fee + priority_fee)\n    let effective_gas_price = tx.max_fee_per_gas.min(base_fee + tx.max_priority_fee_per_gas);\n    \n    // Total fee = effective_gas_price * gas_limit\n    let total_fee = effective_gas_price * tx.gas_limit;\n    \n    // Base fee portion (burned)\n    let base_fee_portion = base_fee.min(effective_gas_price) * tx.gas_limit;\n    \n    // Priority fee portion (to miner)\n    let priority_fee_portion = total_fee - base_fee_portion;\n    \n    (base_fee_portion, priority_fee_portion)\n}\n\nfn adjust_base_fee(previous_base_fee: u64, block_fullness: f64) -> u64 {\n    // Target: 50% block fullness\n    let target = 0.5;\n    \n    if block_fullness > target {\n        // Increase base fee\n        previous_base_fee + (previous_base_fee / 8)\n    } else {\n        // Decrease base fee\n        previous_base_fee - (previous_base_fee / 8)\n    }\n}\n```\n\n## Benefits of EIP-1559\n\n- **Predictable Fees**: Base fee adjusts smoothly\n- **Fee Burning**: Base fee is burned (deflationary)\n- **Better UX**: Users set max fee, not exact fee\n- **MEV Reduction**: Less front-running incentive\n\n## Gas Optimization\n\n### Best Practices\n\n- **Cache Storage**: Read once, use multiple times\n- **Pack Data**: Use smaller data types\n- **Batch Operations**: Combine multiple operations\n- **Avoid Loops**: Unroll when possible\n- **Use Events**: Cheaper than storage\n\n### Example\n\n```rust\n// Bad: Multiple storage writes\nfn bad_function(&mut self) {\n    self.value1 = 1;\n    self.value2 = 2;\n    self.value3 = 3;\n}\n\n// Good: Pack into struct\nstruct PackedValues {\n    value1: u8,\n    value2: u8,\n    value3: u8,\n}\n\nfn good_function(&mut self) {\n    self.packed = PackedValues { value1: 1, value2: 2, value3: 3 };\n    // Single storage write instead of three\n}\n```\n\n## Real-World Examples\n\n- **Ethereum**: Uses gas for all operations\n- **EIP-1559**: Implemented in Ethereum London upgrade\n- **Polygon**: Lower gas costs, similar mechanism\n- **Arbitrum**: L2 with lower gas costs\n\n## Fee Estimation\n\n```rust\nfn estimate_gas(transaction: &Transaction, state: &State) -> u64 {\n    let mut gas_used = 21_000; // Base cost\n    \n    // Add costs based on transaction type\n    if transaction.is_contract_creation() {\n        gas_used += 32_000;\n        gas_used += transaction.data.len() as u64 * 200; // Code size\n    }\n    \n    // Simulate execution to get accurate estimate\n    // ...\n    \n    gas_used\n}\n```",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": [
    "lesson-30-blocks-transactions",
    "lesson-49-building-blockchain"
  ],
  "codeExamples": [
    {
      "id": "ex-75-1-gas-calculation",
      "title": "Gas Calculation",
      "description": "Calculate transaction fees",
      "code": "struct Transaction {\n    gas_limit: u64,\n    gas_price: u64, // wei per gas\n    to: String,\n    value: u64,\n    data: Vec<u8>,\n}\n\nimpl Transaction {\n    fn calculate_fee(&self) -> u64 {\n        self.gas_limit * self.gas_price\n    }\n    \n    fn estimate_gas(&self) -> u64 {\n        let mut gas = 21_000; // Base transaction cost\n        \n        // Contract creation costs more\n        if self.to.is_empty() {\n            gas += 32_000;\n            gas += self.data.len() as u64 * 200; // Code deployment\n        }\n        \n        // Data costs gas\n        if !self.data.is_empty() {\n            gas += self.data.len() as u64 * 16; // Data cost\n        }\n        \n        gas\n    }\n}\n\nfn main() {\n    // Simple transfer\n    let simple_tx = Transaction {\n        gas_limit: 21_000,\n        gas_price: 20_000_000_000, // 20 gwei\n        to: String::from(\"0xBob\"),\n        value: 1_000_000_000_000_000_000, // 1 ETH\n        data: vec![],\n    };\n    \n    let fee = simple_tx.calculate_fee();\n    println!(\"Transaction fee: {} wei\", fee);\n    println!(\"Transaction fee: {} ETH\", fee as f64 / 1e18);\n    \n    // Contract creation\n    let contract_tx = Transaction {\n        gas_limit: 100_000,\n        gas_price: 20_000_000_000,\n        to: String::new(), // Empty = contract creation\n        value: 0,\n        data: vec![0; 1000], // Contract code\n    };\n    \n    let estimated = contract_tx.estimate_gas();\n    println!(\"Estimated gas: {}\", estimated);\n}",
      "explanation": "Gas calculation determines transaction fees. Simple transfers cost 21,000 gas. Contract creation costs more. The total fee is gas_limit * gas_price. This ensures users pay for the computational resources they use.",
      "language": "rust"
    },
    {
      "id": "ex-75-2-eip1559-fees",
      "title": "EIP-1559 Fee Structure",
      "description": "EIP-1559 fee calculation",
      "code": "struct EIP1559Tx {\n    max_fee_per_gas: u64,\n    max_priority_fee_per_gas: u64,\n    gas_limit: u64,\n}\n\nstruct Block {\n    base_fee: u64,\n    number: u64,\n}\n\nfn calculate_fees(tx: &EIP1559Tx, block: &Block) -> (u64, u64) {\n    // Effective gas price = min(max_fee, base_fee + priority_fee)\n    let effective_gas_price = tx.max_fee_per_gas.min(\n        block.base_fee + tx.max_priority_fee_per_gas\n    );\n    \n    // Total fee paid\n    let total_fee = effective_gas_price * tx.gas_limit;\n    \n    // Base fee portion (burned)\n    let base_fee_portion = block.base_fee.min(effective_gas_price) * tx.gas_limit;\n    \n    // Priority fee portion (to miner/validator)\n    let priority_fee_portion = total_fee - base_fee_portion;\n    \n    (base_fee_portion, priority_fee_portion)\n}\n\nfn adjust_base_fee(previous_base_fee: u64, block_fullness: f64) -> u64 {\n    // Target: 50% block fullness\n    let target = 0.5;\n    \n    if block_fullness > target {\n        // Increase by 12.5%\n        previous_base_fee + (previous_base_fee / 8)\n    } else if block_fullness < target {\n        // Decrease by 12.5%\n        previous_base_fee.saturating_sub(previous_base_fee / 8)\n    } else {\n        previous_base_fee\n    }\n}\n\nfn main() {\n    let mut block = Block {\n        base_fee: 20_000_000_000, // 20 gwei\n        number: 1,\n    };\n    \n    let tx = EIP1559Tx {\n        max_fee_per_gas: 50_000_000_000, // 50 gwei max\n        max_priority_fee_per_gas: 2_000_000_000, // 2 gwei priority\n        gas_limit: 21_000,\n    };\n    \n    let (base_fee_burned, priority_fee) = calculate_fees(&tx, &block);\n    \n    println!(\"Base fee burned: {} wei\", base_fee_burned);\n    println!(\"Priority fee to miner: {} wei\", priority_fee);\n    println!(\"Total fee: {} wei\", base_fee_burned + priority_fee);\n    \n    // Adjust base fee for next block\n    let new_base_fee = adjust_base_fee(block.base_fee, 0.75); // 75% full\n    println!(\"New base fee: {} wei\", new_base_fee);\n}",
      "explanation": "EIP-1559 splits fees into base fee (burned, adjusts per block) and priority fee (to miner). The base fee adjusts based on block fullness, making fees more predictable. Users set max_fee and max_priority_fee, and pay the minimum needed.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-75-1",
      "title": "Calculate Transaction Fee",
      "description": "Calculate the fee for a transaction!",
      "starterCode": "struct Transaction {\n    gas_limit: u64,\n    gas_price: u64,\n}\n\nfn main() {\n    let tx = Transaction {\n        gas_limit: 21_000,\n        gas_price: 20_000_000_000,\n    };\n    \n    // Calculate fee\n}",
      "solution": "struct Transaction {\n    gas_limit: u64,\n    gas_price: u64,\n}\n\nimpl Transaction {\n    fn calculate_fee(&self) -> u64 {\n        self.gas_limit * self.gas_price\n    }\n}\n\nfn main() {\n    let tx = Transaction {\n        gas_limit: 21_000,\n        gas_price: 20_000_000_000,\n    };\n    \n    let fee = tx.calculate_fee();\n    println!(\"Transaction fee: {} wei\", fee);\n    println!(\"Transaction fee: {} ETH\", fee as f64 / 1e18);\n}",
      "hints": [
        "Fee = gas_limit * gas_price",
        "Convert wei to ETH by dividing by 1e18"
      ],
      "difficulty": "easy"
    }
  ]
}

