{
  "id": "lesson-77-oracle-integration",
  "title": "Oracle Integration: Chainlink and Price Feeds",
  "description": "Integrating oracles for off-chain data: Chainlink price feeds, VRF, and custom oracle implementations.",
  "content": "# Oracle Integration: Chainlink and Price Feeds\n\n**Oracles** connect blockchains to external data sources.\n\n## Why Oracles?\n\nBlockchains are isolated - they can't access:\n\n- **Price Data**: Crypto, stock, commodity prices\n- **Random Numbers**: True randomness\n- **Weather Data**: For insurance contracts\n- **Sports Results**: For betting contracts\n- **API Data**: Any external API\n\n## Oracle Architecture\n\n### Components\n\n1. **Data Source**: External API, database, etc.\n2. **Oracle Node**: Fetches and signs data\n3. **Aggregator**: Combines multiple oracle responses\n4. **Smart Contract**: Consumes oracle data\n\n### Chainlink Architecture\n\n```rust\n// Simplified Chainlink price feed\nstruct PriceFeed {\n    aggregator: Address,\n    decimals: u8,\n    description: String,\n}\n\nstruct PriceData {\n    price: i128,\n    updated_at: u64,\n    round_id: u64,\n}\n\nimpl PriceFeed {\n    fn latest_round_data(&self) -> PriceData {\n        // Fetch from Chainlink aggregator\n        // Returns: price, timestamp, round_id\n    }\n    \n    fn get_price(&self) -> Result<u64, String> {\n        let data = self.latest_round_data();\n        \n        // Check staleness (price too old)\n        let current_time = current_timestamp();\n        if current_time - data.updated_at > 3600 {\n            return Err(String::from(\"Price data too stale\"));\n        }\n        \n        Ok(data.price as u64)\n    }\n}\n```\n\n## Chainlink Price Feeds\n\n### Supported Feeds\n\n- **Crypto**: BTC/USD, ETH/USD, etc.\n- **Forex**: EUR/USD, GBP/USD, etc.\n- **Commodities**: Gold, Oil, etc.\n- **Stocks**: S&P 500, etc.\n\n### Implementation\n\n```rust\n// Chainlink price feed consumer\nstruct PriceConsumer {\n    price_feed: PriceFeed,\n    min_update_interval: u64,\n    last_update: u64,\n    cached_price: Option<u64>,\n}\n\nimpl PriceConsumer {\n    fn new(price_feed: PriceFeed) -> Self {\n        PriceConsumer {\n            price_feed,\n            min_update_interval: 3600, // 1 hour\n            last_update: 0,\n            cached_price: None,\n        }\n    }\n    \n    fn get_latest_price(&mut self) -> Result<u64, String> {\n        let current_time = current_timestamp();\n        \n        // Use cache if recent\n        if let Some(price) = self.cached_price {\n            if current_time - self.last_update < self.min_update_interval {\n                return Ok(price);\n            }\n        }\n        \n        // Fetch new price\n        let price = self.price_feed.get_price()?;\n        self.cached_price = Some(price);\n        self.last_update = current_time;\n        \n        Ok(price)\n    }\n}\n```\n\n## Verifiable Random Function (VRF)\n\n**VRF** provides provably random numbers.\n\n### Use Cases\n\n- **Gaming**: Random outcomes\n- **NFTs**: Random traits\n- **Lotteries**: Fair selection\n- **Governance**: Random sampling\n\n### Implementation\n\n```rust\nstruct VRFRequest {\n    key_hash: Vec<u8>,\n    seed: u64,\n    callback_contract: Address,\n    callback_function: Vec<u8>,\n}\n\nstruct VRFResponse {\n    randomness: Vec<u8>,\n    proof: Vec<u8>,\n}\n\nimpl VRFRequest {\n    fn request_randomness(&self) -> Result<u64, String> {\n        // Request randomness from Chainlink VRF\n        // Returns request ID\n    }\n    \n    fn fulfill_randomness(&self, response: VRFResponse) -> Result<u64, String> {\n        // Verify proof\n        if !self.verify_proof(&response) {\n            return Err(String::from(\"Invalid VRF proof\"));\n        }\n        \n        // Extract random number\n        let random = u64::from_be_bytes(\n            response.randomness[..8].try_into().unwrap()\n        );\n        \n        Ok(random)\n    }\n    \n    fn verify_proof(&self, response: &VRFResponse) -> bool {\n        // Verify cryptographic proof\n        // In real implementation: use Chainlink's verification\n        true\n    }\n}\n```\n\n## Custom Oracle Implementation\n\n```rust\nstruct OracleNode {\n    node_id: String,\n    data_sources: Vec<String>,\n    reputation: u64,\n}\n\nstruct OracleAggregator {\n    nodes: Vec<OracleNode>,\n    min_confirmations: usize,\n}\n\nimpl OracleAggregator {\n    fn new(min_confirmations: usize) -> Self {\n        OracleAggregator {\n            nodes: Vec::new(),\n            min_confirmations,\n        }\n    }\n    \n    fn add_node(&mut self, node: OracleNode) {\n        self.nodes.push(node);\n    }\n    \n    fn get_price(&self, symbol: &str) -> Result<u64, String> {\n        // Collect responses from multiple nodes\n        let mut prices = Vec::new();\n        \n        for node in &self.nodes {\n            if let Ok(price) = node.fetch_price(symbol) {\n                prices.push(price);\n            }\n        }\n        \n        if prices.len() < self.min_confirmations {\n            return Err(String::from(\"Insufficient oracle responses\"));\n        }\n        \n        // Aggregate: median or weighted average\n        prices.sort();\n        let median = prices[prices.len() / 2];\n        \n        Ok(median)\n    }\n}\n```\n\n## Security Considerations\n\n### Oracle Manipulation\n\n- **Single Point of Failure**: One oracle can be wrong\n- **Solution**: Use multiple oracles, aggregate\n\n### Stale Data\n\n- **Problem**: Old prices can be exploited\n- **Solution**: Check timestamps, reject stale data\n\n### Price Deviation\n\n- **Problem**: One oracle reports wrong price\n- **Solution**: Compare with multiple sources, reject outliers\n\n## Best Practices\n\n1. **Multiple Sources**: Use multiple oracles\n2. **Aggregation**: Median or weighted average\n3. **Staleness Checks**: Reject old data\n4. **Outlier Detection**: Reject extreme values\n5. **Circuit Breakers**: Pause on anomalies\n\n## Real-World Examples\n\n- **Chainlink**: Most popular oracle network\n- **Band Protocol**: Alternative oracle solution\n- **UMA**: Optimistic oracle\n- **API3**: Decentralized APIs\n\n## Use Cases\n\n- **DeFi**: Price feeds for lending, AMMs\n- **Insurance**: Weather, flight data\n- **Gaming**: Random numbers\n- **Prediction Markets**: Event outcomes",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": [
    "lesson-41-smart-contract-structure",
    "lesson-70-defi-protocols"
  ],
  "codeExamples": [
    {
      "id": "ex-77-1-price-feed",
      "title": "Price Feed Consumer",
      "description": "Simple price feed implementation",
      "code": "use std::collections::HashMap;\n\nstruct PriceData {\n    price: u64,\n    updated_at: u64,\n    round_id: u64,\n}\n\nstruct PriceFeed {\n    prices: HashMap<String, PriceData>,\n    decimals: u8,\n}\n\nimpl PriceFeed {\n    fn new() -> Self {\n        PriceFeed {\n            prices: HashMap::new(),\n            decimals: 8,\n        }\n    }\n    \n    fn update_price(&mut self, symbol: String, price: u64, timestamp: u64) {\n        let round_id = self.prices.len() as u64 + 1;\n        self.prices.insert(symbol, PriceData {\n            price,\n            updated_at: timestamp,\n            round_id,\n        });\n    }\n    \n    fn get_latest_price(&self, symbol: &str) -> Result<u64, String> {\n        let data = self.prices.get(symbol)\n            .ok_or_else(|| format!(\"Price not found for {}\", symbol))?;\n        \n        // Check staleness (1 hour max)\n        let current_time = 1000000; // Simplified\n        if current_time - data.updated_at > 3600 {\n            return Err(String::from(\"Price data too stale\"));\n        }\n        \n        Ok(data.price)\n    }\n}\n\nstruct PriceConsumer {\n    price_feed: PriceFeed,\n    min_price_age: u64,\n}\n\nimpl PriceConsumer {\n    fn new(price_feed: PriceFeed) -> Self {\n        PriceConsumer {\n            price_feed,\n            min_price_age: 60, // 1 minute\n        }\n    }\n    \n    fn get_price(&self, symbol: &str) -> Result<u64, String> {\n        self.price_feed.get_latest_price(symbol)\n    }\n    \n    fn calculate_value(&self, symbol: &str, amount: u64) -> Result<u64, String> {\n        let price = self.get_price(symbol)?;\n        Ok((price as u128 * amount as u128 / 1e8 as u128) as u64)\n    }\n}\n\nfn main() {\n    let mut feed = PriceFeed::new();\n    \n    // Update prices\n    feed.update_price(String::from(\"ETH/USD\"), 2000_00000000, 1000000);\n    feed.update_price(String::from(\"BTC/USD\"), 40000_00000000, 1000000);\n    \n    let consumer = PriceConsumer::new(feed);\n    \n    // Get prices\n    match consumer.get_price(\"ETH/USD\") {\n        Ok(price) => println!(\"ETH/USD: ${}\", price as f64 / 1e8),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n    \n    // Calculate value\n    match consumer.calculate_value(\"ETH/USD\", 1_00000000) {\n        Ok(value) => println!(\"1 ETH = ${}\", value as f64 / 1e8),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "explanation": "Price feeds provide external data (like crypto prices) to smart contracts. The consumer checks for stale data and calculates values. In production, this would connect to Chainlink or another oracle network.",
      "language": "rust"
    },
    {
      "id": "ex-77-2-vrf-randomness",
      "title": "VRF Randomness",
      "description": "Verifiable Random Function implementation",
      "code": "// Simplified VRF concept\nstruct VRFRequest {\n    request_id: u64,\n    seed: u64,\n    callback: String,\n}\n\nstruct VRFResponse {\n    request_id: u64,\n    randomness: Vec<u8>,\n    proof: Vec<u8>,\n}\n\nstruct VRFConsumer {\n    pending_requests: std::collections::HashMap<u64, VRFRequest>,\n    fulfilled_randomness: std::collections::HashMap<u64, u64>,\n}\n\nimpl VRFConsumer {\n    fn new() -> Self {\n        VRFConsumer {\n            pending_requests: std::collections::HashMap::new(),\n            fulfilled_randomness: std::collections::HashMap::new(),\n        }\n    }\n    \n    fn request_randomness(&mut self, seed: u64, callback: String) -> u64 {\n        let request_id = self.pending_requests.len() as u64 + 1;\n        \n        self.pending_requests.insert(request_id, VRFRequest {\n            request_id,\n            seed,\n            callback,\n        });\n        \n        println!(\"Requested randomness, ID: {}\", request_id);\n        request_id\n    }\n    \n    fn fulfill_randomness(&mut self, response: VRFResponse) -> Result<u64, String> {\n        // Verify request exists\n        let request = self.pending_requests.get(&response.request_id)\n            .ok_or(\"Request not found\")?;\n        \n        // Verify proof (simplified - in real VRF, verify cryptographic proof)\n        if !self.verify_proof(&response, request) {\n            return Err(String::from(\"Invalid VRF proof\"));\n        }\n        \n        // Extract random number\n        let random = if response.randomness.len() >= 8 {\n            u64::from_be_bytes(\n                response.randomness[..8].try_into().unwrap()\n            )\n        } else {\n            return Err(String::from(\"Invalid randomness length\"));\n        };\n        \n        // Store fulfilled randomness\n        self.fulfilled_randomness.insert(response.request_id, random);\n        self.pending_requests.remove(&response.request_id);\n        \n        Ok(random)\n    }\n    \n    fn verify_proof(&self, _response: &VRFResponse, _request: &VRFRequest) -> bool {\n        // In real implementation: verify cryptographic proof\n        // This ensures randomness is truly random and not manipulated\n        true\n    }\n    \n    fn get_randomness(&self, request_id: u64) -> Option<u64> {\n        self.fulfilled_randomness.get(&request_id).copied()\n    }\n}\n\nfn main() {\n    let mut vrf = VRFConsumer::new();\n    \n    // Request randomness\n    let request_id = vrf.request_randomness(12345, String::from(\"callback\"));\n    \n    // Simulate VRF response (in real system, comes from Chainlink)\n    let response = VRFResponse {\n        request_id,\n        randomness: vec![1, 2, 3, 4, 5, 6, 7, 8],\n        proof: vec![],\n    };\n    \n    // Fulfill randomness\n    match vrf.fulfill_randomness(response) {\n        Ok(random) => {\n            println!(\"Random number: {}\", random);\n            println!(\"This number is provably random and verifiable!\");\n        }\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "explanation": "VRF provides provably random numbers. The randomness comes with a cryptographic proof that can be verified on-chain. This ensures the randomness is truly random and not manipulated by the oracle or anyone else.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-77-1",
      "title": "Price Feed with Staleness Check",
      "description": "Create a price feed that checks for stale data!",
      "starterCode": "struct PriceData {\n    price: u64,\n    timestamp: u64,\n}\n\nfn main() {\n    // Create price data\n    // Check if stale\n}",
      "solution": "struct PriceData {\n    price: u64,\n    timestamp: u64,\n}\n\nimpl PriceData {\n    fn is_stale(&self, current_time: u64, max_age: u64) -> bool {\n        current_time - self.timestamp > max_age\n    }\n    \n    fn get_price(&self, current_time: u64, max_age: u64) -> Result<u64, String> {\n        if self.is_stale(current_time, max_age) {\n            return Err(String::from(\"Price data too stale\"));\n        }\n        Ok(self.price)\n    }\n}\n\nfn main() {\n    let price_data = PriceData {\n        price: 2000,\n        timestamp: 1000,\n    };\n    \n    let current_time = 1500;\n    let max_age = 600; // 10 minutes\n    \n    match price_data.get_price(current_time, max_age) {\n        Ok(price) => println!(\"Price: {}\", price),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "hints": [
        "Check if timestamp is too old",
        "Return Result for error handling",
        "Compare current_time with timestamp"
      ],
      "difficulty": "medium"
    }
  ]
}

