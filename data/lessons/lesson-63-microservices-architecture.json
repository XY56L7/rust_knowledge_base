{
  "id": "lesson-63-microservices-architecture",
  "title": "Microservices Architecture",
  "description": "Building microservices with Rust for scalable distributed systems.",
  "content": "# Microservices Architecture\n\n**Microservices** break applications into small, independent services that communicate over networks.\n\n## Microservices vs Monolith\n\n### Monolith\n\n```\nSingle Application\n├── All features\n├── Shared database\n└── Single deployment\n```\n\n### Microservices\n\n```\nService 1 (User Service)\n├── Own database\n└── Independent deployment\n\nService 2 (Payment Service)\n├── Own database\n└── Independent deployment\n\nService 3 (Notification Service)\n├── Own database\n└── Independent deployment\n```\n\n## Rust Microservices Structure\n\n### Workspace Organization\n\n```\nworkspace/\n├── Cargo.toml              # Workspace manifest\n├── services/\n│   ├── user-service/       # User microservice\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   ├── payment-service/    # Payment microservice\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   └── notification-service/\n│       ├── Cargo.toml\n│       └── src/\n├── shared/                 # Shared code\n│   ├── common/             # Common utilities\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   └── proto/              # gRPC definitions\n│       ├── Cargo.toml\n│       └── src/\n└── gateway/                # API Gateway\n    ├── Cargo.toml\n    └── src/\n```\n\n## Service Communication\n\n### 1. REST API (HTTP)\n\n```rust\n// services/user-service/src/api.rs\nuse axum::{Router, routing::get, Json};\n\npub fn create_router() -> Router {\n    Router::new()\n        .route(\"/users/:id\", get(get_user))\n}\n\nasync fn get_user(Path(id): Path<u64>) -> Json<User> {\n    // Return user data\n}\n\n// In payment-service, call user-service\nuse reqwest::Client;\n\nasync fn verify_user(user_id: u64) -> Result<User, Error> {\n    let client = Client::new();\n    let response = client\n        .get(format!(\"http://user-service:3000/users/{}\", user_id))\n        .send()\n        .await?;\n    response.json().await\n}\n```\n\n### 2. gRPC (Recommended for Inter-Service)\n\n```toml\n# Cargo.toml\n[dependencies]\ntonic = \"0.10\"\nprost = \"0.12\"\n```\n\n```protobuf\n// proto/user.proto\nsyntax = \"proto3\";\n\nservice UserService {\n    rpc GetUser(GetUserRequest) returns (User);\n    rpc CreateUser(CreateUserRequest) returns (User);\n}\n\nmessage User {\n    uint64 id = 1;\n    string email = 2;\n}\n```\n\n```rust\n// services/user-service/src/grpc.rs\nuse tonic::{Request, Response, Status};\n\npub struct UserServiceImpl;\n\n#[tonic::async_trait]\nimpl UserService for UserServiceImpl {\n    async fn get_user(\n        &self,\n        request: Request<GetUserRequest>\n    ) -> Result<Response<User>, Status> {\n        let user = get_user_from_db(request.into_inner().id).await?;\n        Ok(Response::new(user))\n    }\n}\n```\n\n### 3. Message Queue (Async Communication)\n\n```toml\n[dependencies]\nlapin = \"2.0\"  # RabbitMQ client\nredis = \"0.24\"  # Redis client\n```\n\n```rust\n// Publisher (payment-service)\nuse lapin::{Connection, Channel, options::*};\n\nasync fn publish_payment_event(event: PaymentEvent) -> Result<(), Error> {\n    let conn = Connection::connect(\"amqp://localhost:5672\", ConnectionProperties::default()).await?;\n    let channel = conn.create_channel().await?;\n    \n    channel.basic_publish(\n        \"payments\",\n        \"payment.completed\",\n        BasicPublishOptions::default(),\n        &serde_json::to_vec(&event)?,\n        BasicProperties::default()\n    ).await?;\n    \n    Ok(())\n}\n\n// Consumer (notification-service)\nasync fn consume_payment_events() -> Result<(), Error> {\n    let conn = Connection::connect(\"amqp://localhost:5672\", ConnectionProperties::default()).await?;\n    let channel = conn.create_channel().await?;\n    \n    let mut consumer = channel.basic_consume(\n        \"payment.completed\",\n        \"notification-consumer\",\n        BasicConsumeOptions::default(),\n        FieldTable::default()\n    ).await?;\n    \n    while let Some(delivery) = consumer.next().await {\n        let event: PaymentEvent = serde_json::from_slice(&delivery.data)?;\n        send_notification(event).await?;\n    }\n    \n    Ok(())\n}\n```\n\n## API Gateway\n\n```rust\n// gateway/src/main.rs\nuse axum::{Router, routing::get, extract::Path};\n\n#[tokio::main]\nasync fn main() {\n    let app = Router::new()\n        .route(\"/api/users/*path\", proxy_to_user_service)\n        .route(\"/api/payments/*path\", proxy_to_payment_service);\n    \n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn proxy_to_user_service(Path(path): Path<String>) -> Response {\n    // Forward request to user-service\n    // Add authentication, rate limiting, etc.\n}\n```\n\n## Service Discovery\n\n```rust\n// shared/service-discovery/src/lib.rs\nuse std::collections::HashMap;\n\npub struct ServiceRegistry {\n    services: HashMap<String, String>,\n}\n\nimpl ServiceRegistry {\n    pub fn get_service_url(&self, service_name: &str) -> Option<&String> {\n        self.services.get(service_name)\n    }\n    \n    pub fn register_service(&mut self, name: String, url: String) {\n        self.services.insert(name, url);\n    }\n}\n```\n\n## Configuration Management\n\n```rust\n// Each service has its own config\n// config/user-service.toml\n[database]\nurl = \"postgres://localhost/user_db\"\n\n[server]\nport = 3001\n\n[services]\npayment_service_url = \"http://payment-service:3002\"\n```\n\n## Docker Compose for Development\n\n```yaml\nversion: '3.8'\nservices:\n  user-service:\n    build: ./services/user-service\n    ports:\n      - \"3001:3001\"\n    environment:\n      - DATABASE_URL=postgres://db:5432/user_db\n  \n  payment-service:\n    build: ./services/payment-service\n    ports:\n      - \"3002:3002\"\n    environment:\n      - DATABASE_URL=postgres://db:5432/payment_db\n  \n  api-gateway:\n    build: ./gateway\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - user-service\n      - payment-service\n  \n  rabbitmq:\n    image: rabbitmq:3-management\n    ports:\n      - \"5672:5672\"\n      - \"15672:15672\"\n```\n\n## Best Practices\n\n- **Database per service**: Each service has its own database\n- **API versioning**: Version your APIs\n- **Circuit breakers**: Handle service failures gracefully\n- **Distributed tracing**: Track requests across services\n- **Health checks**: Monitor service health\n- **Configuration externalization**: Use environment variables\n- **Stateless services**: Don't store session state\n- **Idempotency**: Make operations safe to retry",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": ["lesson-62-api-architecture"],
  "codeExamples": [
    {
      "id": "ex-63-1-microservice-structure",
      "title": "Microservice Structure",
      "description": "Organizing microservices in workspace",
      "code": "// Workspace structure for microservices\n\n// workspace/Cargo.toml\n// [workspace]\n// members = [\n//     \"services/user-service\",\n//     \"services/payment-service\",\n//     \"shared/common\",\n//     \"gateway\"\n// ]\n\n// services/user-service/src/main.rs\n// - Own API\n// - Own database\n// - Independent deployment\n\n// services/payment-service/src/main.rs\n// - Own API\n// - Own database\n// - Calls user-service\n\n// shared/common/src/lib.rs\n// - Shared types\n// - Common utilities\n\nfn main() {\n    println!(\"Microservices architecture:\");\n    println!(\"- Each service is independent\");\n    println!(\"- Own database per service\");\n    println!(\"- Communicate via HTTP/gRPC\");\n    println!(\"- Deploy independently\");\n}",
      "explanation": "Microservices are organized as separate crates in a workspace. Each service is independently deployable and has its own database.",
      "language": "rust"
    },
    {
      "id": "ex-63-2-service-communication",
      "title": "Service Communication",
      "description": "Services communicating via HTTP",
      "code": "// Service communication example\n\n// Payment service calling user service\nstruct PaymentService {\n    user_service_url: String,\n    client: reqwest::Client,\n}\n\nimpl PaymentService {\n    async fn verify_user(&self, user_id: u64) -> Result<User, Error> {\n        // HTTP call to user service\n        // let response = self.client\n        //     .get(format!(\"{}/users/{}\", self.user_service_url, user_id))\n        //     .send()\n        //     .await?;\n        // response.json().await\n        \n        // Simplified\n        Ok(User { id: user_id, name: String::from(\"User\") })\n    }\n}\n\nstruct User {\n    id: u64,\n    name: String,\n}\n\nfn main() {\n    println!(\"Service communication:\");\n    println!(\"- HTTP REST: Simple, widely supported\");\n    println!(\"- gRPC: Efficient, type-safe\");\n    println!(\"- Message Queue: Async, decoupled\");\n}",
      "explanation": "Microservices communicate via HTTP REST, gRPC, or message queues. Each method has trade-offs: REST is simple, gRPC is efficient, queues are async.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-63-1",
      "title": "Service Structure",
      "description": "Create a workspace with two services!",
      "starterCode": "// Create workspace structure:\n// workspace/Cargo.toml with members:\n// - services/service-a\n// - services/service-b\n\n// Each service should have:\n// - Cargo.toml\n// - src/main.rs with a simple function\n\nfn main() {\n    println!(\"Workspace created!\");\n}",
      "solution": "// workspace/Cargo.toml\n// [workspace]\n// members = [\"services/service-a\", \"services/service-b\"]\n// \n// services/service-a/Cargo.toml\n// [package]\n// name = \"service-a\"\n// \n// services/service-a/src/main.rs\n// fn main() {\n//     println!(\"Service A\");\n// }\n// \n// services/service-b/Cargo.toml\n// [package]\n// name = \"service-b\"\n// \n// services/service-b/src/main.rs\n// fn main() {\n//     println!(\"Service B\");\n// }\n\nfn main() {\n    println!(\"Workspace created!\");\n}",
      "hints": [
        "Use [workspace] in root Cargo.toml",
        "List members array"
      ],
      "difficulty": "medium"
    }
  ]
}

