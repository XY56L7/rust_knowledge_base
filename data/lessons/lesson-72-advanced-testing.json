{
  "id": "lesson-72-advanced-testing",
  "title": "Advanced Testing: Fuzzing and Property-Based Testing",
  "description": "Advanced testing techniques for blockchain: fuzzing, property-based testing, and security auditing.",
  "content": "# Advanced Testing: Fuzzing and Property-Based Testing\n\nAdvanced testing techniques are crucial for blockchain security and reliability.\n\n## Why Advanced Testing?\n\nBlockchain code handles value - bugs can lead to:\n\n- **Financial Loss**: Stolen or locked funds\n- **Network Disruption**: Consensus failures\n- **Reputation Damage**: Loss of trust\n\nTraditional unit tests aren't enough. We need:\n\n- **Fuzzing**: Random input testing\n- **Property-Based Testing**: Verify invariants\n- **Formal Verification**: Mathematical proofs\n- **Security Audits**: Expert review\n\n## Fuzzing\n\n**Fuzzing** generates random inputs to find edge cases and bugs.\n\n### Rust Fuzzing Tools\n\n- **cargo-fuzz**: Official Rust fuzzing tool\n- **honggfuzz**: Fast, efficient fuzzer\n- **AFL**: American Fuzzy Lop\n\n### Example: Fuzzing a Hash Function\n\n```rust\n#![no_main]\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target!(|data: &[u8]| {\n    // Test that hash function doesn't panic\n    let hash1 = hash(data);\n    \n    // Test determinism\n    let hash2 = hash(data);\n    assert_eq!(hash1, hash2);\n    \n    // Test collision resistance (simplified)\n    if data.len() > 0 {\n        let mut modified = data.to_vec();\n        modified[0] ^= 1;\n        let hash3 = hash(&modified);\n        assert_ne!(hash1, hash3);\n    }\n});\n```\n\n### Fuzzing Blockchain Components\n\n```rust\n// Fuzz transaction validation\nfuzz_target!(|tx_data: TransactionData| {\n    let mut blockchain = Blockchain::new();\n    \n    // Should never panic on any input\n    let result = blockchain.validate_transaction(&tx_data);\n    \n    // Result should be consistent\n    let result2 = blockchain.validate_transaction(&tx_data);\n    assert_eq!(result, result2);\n});\n\n// Fuzz block creation\nfuzz_target!(|transactions: Vec<Transaction>| {\n    let mut blockchain = Blockchain::new();\n    \n    // Should handle any number/type of transactions\n    match blockchain.create_block(transactions) {\n        Ok(block) => {\n            // Block should be valid\n            assert!(blockchain.validate_block(&block).is_ok());\n        }\n        Err(_) => {\n            // If creation fails, validation should also fail\n        }\n    }\n});\n```\n\n## Property-Based Testing\n\n**Property-based testing** verifies that properties (invariants) hold for all inputs.\n\n### Using Proptest\n\n```rust\nuse proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn test_balance_invariant(\n        transactions in prop::collection::vec(\n            (0u64..1000, 0u64..1000, 0u64..100),\n            0..100\n        )\n    ) {\n        let mut balances = HashMap::new();\n        let mut total = 0u64;\n        \n        for (from, to, amount) in transactions {\n            // Property: total supply never changes\n            let before_total: u64 = balances.values().sum();\n            \n            *balances.entry(from).or_insert(0) -= amount;\n            *balances.entry(to).or_insert(0) += amount;\n            \n            let after_total: u64 = balances.values().sum();\n            \n            // Total should remain constant (no minting/burning)\n            assert_eq!(before_total, after_total);\n        }\n    }\n}\n```\n\n### Blockchain Properties\n\n```rust\n// Property: Blockchain height always increases\nproptest! {\n    #[test]\n    fn height_monotonic(blocks in prop::collection::vec(block_strategy(), 0..50)) {\n        let mut blockchain = Blockchain::new();\n        let mut last_height = 0;\n        \n        for block in blocks {\n            if blockchain.add_block(block).is_ok() {\n                let height = blockchain.height();\n                assert!(height > last_height);\n                last_height = height;\n            }\n        }\n    }\n}\n\n// Property: Valid blocks are always accepted\nproptest! {\n    #[test]\n    fn valid_blocks_accepted(block in valid_block_strategy()) {\n        let mut blockchain = Blockchain::new();\n        assert!(blockchain.add_block(block).is_ok());\n    }\n}\n```\n\n## Security Testing\n\n### Reentrancy Testing\n\n```rust\n#[test]\nfn test_reentrancy_protection() {\n    let mut contract = VulnerableContract::new();\n    \n    // Try to reenter during withdrawal\n    let attacker = Attacker::new();\n    \n    // Should fail or be protected\n    assert!(contract.withdraw(&attacker).is_err());\n}\n```\n\n### Integer Overflow Testing\n\n```rust\n#[test]\nfn test_overflow_protection() {\n    let mut token = Token::new();\n    \n    // Try to cause overflow\n    let max_amount = u64::MAX;\n    \n    // Should use checked arithmetic\n    assert!(token.transfer(\"alice\", \"bob\", max_amount).is_err());\n}\n```\n\n## Test Coverage\n\n### Measuring Coverage\n\n```bash\n# Install cargo-tarpaulin\ncargo install cargo-tarpaulin\n\n# Generate coverage report\ncargo tarpaulin --out Html\n```\n\n### Coverage Goals\n\n- **Critical Paths**: 100% coverage\n- **Error Handling**: 90%+ coverage\n- **Overall**: 80%+ coverage\n\n## Best Practices\n\n1. **Start Early**: Write tests alongside code\n2. **Test Edge Cases**: Zero, max, negative values\n3. **Test Failures**: Ensure errors are handled\n4. **Property Tests**: Verify invariants\n5. **Fuzz Critical Code**: Hash functions, validators\n6. **Integration Tests**: Test full workflows\n7. **Performance Tests**: Ensure scalability\n\n## Real-World Example\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use proptest::prelude::*;\n    \n    #[test]\n    fn test_basic_transfer() {\n        // Unit test\n    }\n    \n    proptest! {\n        #[test]\n        fn test_transfer_properties(\n            amount in 0u64..1000000,\n            from_balance in amount..10000000\n        ) {\n            // Property: transfer never creates tokens\n            let mut token = Token::new();\            token.balance_of(\"alice\") = from_balance;\n            \n            let total_before: u64 = token.all_balances().sum();\n            token.transfer(\"alice\", \"bob\", amount).unwrap();\n            let total_after: u64 = token.all_balances().sum();\n            \n            prop_assert_eq!(total_before, total_after);\n        }\n    }\n    \n    #[test]\n    #[ignore] // Run manually with: cargo test -- --ignored\n    fn fuzz_transaction_validation() {\n        // Fuzzing test\n    }\n}\n```",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": [
    "lesson-42-contract-testing",
    "lesson-49-building-blockchain"
  ],
  "codeExamples": [
    {
      "id": "ex-72-1-property-test",
      "title": "Property-Based Test",
      "description": "Property-based testing for blockchain invariants",
      "code": "use std::collections::HashMap;\n\nstruct Token {\n    balances: HashMap<String, u64>,\n    total_supply: u64,\n}\n\nimpl Token {\n    fn new(initial_supply: u64) -> Self {\n        let mut balances = HashMap::new();\n        balances.insert(String::from(\"owner\"), initial_supply);\n        Token {\n            balances,\n            total_supply: initial_supply,\n        }\n    }\n    \n    fn transfer(&mut self, from: &str, to: &str, amount: u64) -> Result<(), String> {\n        let balance = *self.balances.get(from).unwrap_or(&0);\n        if balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        *self.balances.entry(from.to_string()).or_insert(0) -= amount;\n        *self.balances.entry(to.to_string()).or_insert(0) += amount;\n        \n        Ok(())\n    }\n    \n    fn total_balance(&self) -> u64 {\n        self.balances.values().sum()\n    }\n}\n\n// Property: Total supply never changes (no minting/burning)\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_total_supply_invariant() {\n        let mut token = Token::new(1000);\n        let initial_total = token.total_balance();\n        \n        // Perform multiple transfers\n        token.transfer(\"owner\", \"alice\", 100).unwrap();\n        token.transfer(\"alice\", \"bob\", 50).unwrap();\n        token.transfer(\"owner\", \"charlie\", 200).unwrap();\n        \n        // Property: total should remain constant\n        assert_eq!(initial_total, token.total_balance());\n        assert_eq!(token.total_supply, token.total_balance());\n    }\n    \n    #[test]\n    fn test_balance_consistency() {\n        let mut token = Token::new(1000);\n        \n        // Property: sum of all balances equals total supply\n        token.transfer(\"owner\", \"alice\", 300).unwrap();\n        token.transfer(\"owner\", \"bob\", 200).unwrap();\n        \n        let sum: u64 = token.balances.values().sum();\n        assert_eq!(sum, token.total_supply);\n    }\n    \n    #[test]\n    fn test_no_negative_balances() {\n        let mut token = Token::new(1000);\n        \n        // Property: balances never go negative\n        token.transfer(\"owner\", \"alice\", 500).unwrap();\n        \n        // Try to transfer more than balance\n        assert!(token.transfer(\"alice\", \"bob\", 600).is_err());\n        \n        // Verify balance is still positive\n        assert!(token.balances.get(\"alice\").unwrap_or(&0) > &0);\n    }\n}\n\nfn main() {\n    let mut token = Token::new(1000);\n    \n    println!(\"Initial total: {}\", token.total_balance());\n    \n    token.transfer(\"owner\", \"alice\", 100).unwrap();\n    token.transfer(\"alice\", \"bob\", 50).unwrap();\n    \n    println!(\"After transfers total: {}\", token.total_balance());\n    println!(\"Property: Total supply remains constant!\");\n}",
      "explanation": "Property-based tests verify invariants that should always hold. Key properties: total supply never changes, balances sum to total supply, no negative balances. These tests catch bugs that unit tests might miss.",
      "language": "rust"
    },
    {
      "id": "ex-72-2-fuzz-test-concept",
      "title": "Fuzzing Concept",
      "description": "Conceptual fuzzing test for transaction validation",
      "code": "struct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    fee: u64,\n}\n\nstruct Blockchain {\n    balances: std::collections::HashMap<String, u64>,\n}\n\nimpl Blockchain {\n    fn new() -> Self {\n        Blockchain {\n            balances: std::collections::HashMap::new(),\n        }\n    }\n    \n    fn validate_transaction(&self, tx: &Transaction) -> Result<(), String> {\n        // Should never panic on any input\n        \n        if tx.amount == 0 && tx.fee == 0 {\n            return Err(String::from(\"Zero amount transaction\"));\n        }\n        \n        // Check for overflow (simplified)\n        if tx.amount > u64::MAX / 2 || tx.fee > u64::MAX / 2 {\n            return Err(String::from(\"Amount too large\"));\n        }\n        \n        let balance = self.balances.get(&tx.from).copied().unwrap_or(0);\n        \n        if balance < tx.amount + tx.fee {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        Ok(())\n    }\n    \n    fn execute_transaction(&mut self, tx: &Transaction) -> Result<(), String> {\n        self.validate_transaction(tx)?;\n        \n        *self.balances.entry(tx.from.clone()).or_insert(0) -= tx.amount + tx.fee;\n        *self.balances.entry(tx.to.clone()).or_insert(0) += tx.amount;\n        \n        Ok(())\n    }\n}\n\n// Simulated fuzzing test\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn fuzz_transaction_validation() {\n        // Simulate fuzzer generating random transactions\n        let test_cases = vec![\n            Transaction { from: String::new(), to: String::new(), amount: 0, fee: 0 },\n            Transaction { from: String::from(\"a\"), to: String::from(\"b\"), amount: u64::MAX, fee: 0 },\n            Transaction { from: String::from(\"a\"), to: String::from(\"b\"), amount: 0, fee: u64::MAX },\n            Transaction { from: String::from(\"a\"), to: String::from(\"b\"), amount: 100, fee: 10 },\n        ];\n        \n        let blockchain = Blockchain::new();\n        \n        for tx in test_cases {\n            // Should never panic\n            let result = blockchain.validate_transaction(&tx);\n            \n            // Result should be consistent\n            let result2 = blockchain.validate_transaction(&tx);\n            assert_eq!(result.is_ok(), result2.is_ok());\n        }\n    }\n}\n\nfn main() {\n    let mut blockchain = Blockchain::new();\n    blockchain.balances.insert(String::from(\"alice\"), 1000);\n    \n    let tx = Transaction {\n        from: String::from(\"alice\"),\n        to: String::from(\"bob\"),\n        amount: 100,\n        fee: 10,\n    };\n    \n    match blockchain.validate_transaction(&tx) {\n        Ok(_) => println!(\"Transaction is valid\"),\n        Err(e) => println!(\"Transaction invalid: {}\", e),\n    }\n}",
      "explanation": "Fuzzing generates random inputs to find edge cases. The validator should never panic and should return consistent results. This catches bugs like integer overflow, underflow, and edge cases that manual testing might miss.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-72-1",
      "title": "Property Test",
      "description": "Create a property test for a simple function!",
      "starterCode": "fn add(a: u64, b: u64) -> u64 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_add_property() {\n        // Test that add is commutative: add(a, b) == add(b, a)\n    }\n}",
      "solution": "fn add(a: u64, b: u64) -> u64 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_add_property() {\n        // Property: addition is commutative\n        let test_cases = vec![\n            (0, 0),\n            (1, 2),\n            (100, 200),\n            (u64::MAX / 2, u64::MAX / 2),\n        ];\n        \n        for (a, b) in test_cases {\n            assert_eq!(add(a, b), add(b, a), \"Addition should be commutative\");\n        }\n    }\n    \n    #[test]\n    fn test_add_identity() {\n        // Property: adding zero doesn't change value\n        assert_eq!(add(5, 0), 5);\n        assert_eq!(add(0, 5), 5);\n    }\n}\n\nfn main() {\n    println!(\"5 + 3 = {}\", add(5, 3));\n}",
      "hints": [
        "Test mathematical properties",
        "Test edge cases (0, max values)",
        "Verify invariants hold for all inputs"
      ],
      "difficulty": "medium"
    }
  ]
}

