{
  "id": "lesson-39-consensus-implementation",
  "title": "Implementing Consensus",
  "description": "Building a complete consensus mechanism for a blockchain.",
  "content": "# Implementing Consensus\n\nConsensus ensures all nodes agree on the valid state of the blockchain. Let's implement a simple consensus mechanism.\n\n## Consensus Requirements\n\n1. **Agreement**: All honest nodes agree on valid blocks\n2. **Validity**: Only valid blocks are accepted\n3. **Termination**: Consensus eventually reaches agreement\n4. **Integrity**: Blocks cannot be tampered with\n\n## Block Validation\n\nBefore accepting a block, nodes must validate:\n\n```rust\nfn validate_block(block: &Block, previous_block: &Block) -> bool {\n    // Check index is sequential\n    if block.index != previous_block.index + 1 {\n        return false;\n    }\n    \n    // Check previous hash matches\n    if block.previous_hash != previous_block.hash {\n        return false;\n    }\n    \n    // Check block hash is valid\n    if block.hash != calculate_block_hash(block) {\n        return false;\n    }\n    \n    // Check transactions are valid\n    for tx in &block.transactions {\n        if !validate_transaction(tx) {\n            return false;\n        }\n    }\n    \n    true\n}\n```\n\n## Longest Chain Rule\n\nIn PoW blockchains, the longest valid chain wins:\n\n```rust\nfn select_best_chain(chains: Vec<Blockchain>) -> Blockchain {\n    chains.into_iter()\n        .max_by_key(|chain| chain.blocks.len())\n        .unwrap()\n}\n```\n\n## Fork Resolution\n\nWhen forks occur:\n\n1. **Temporary fork**: Two blocks at same height\n2. **Wait**: Wait for next block\n3. **Choose**: Longest chain becomes canonical\n4. **Reorganize**: Orphaned blocks are discarded\n\n## Finality\n\n- **PoW**: Probabilistic finality (more confirmations = more secure)\n- **PoS**: Faster finality, sometimes instant\n- **BFT**: Byzantine Fault Tolerance provides immediate finality\n\n## Consensus Implementation\n\n```rust\nstruct ConsensusEngine {\n    blockchain: Blockchain,\n    pending_blocks: Vec<Block>,\n}\n\nimpl ConsensusEngine {\n    fn add_block(&mut self, block: Block) -> Result<(), String> {\n        // Validate block\n        if !self.validate(&block) {\n            return Err(String::from(\"Invalid block\"));\n        }\n        \n        // Add to chain\n        self.blockchain.add_block(block);\n        Ok(())\n    }\n}\n```",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": ["lesson-38-proof-of-stake"],
  "codeExamples": [
    {
      "id": "ex-39-1-block-validation",
      "title": "Block Validation",
      "description": "Validating blocks before adding to chain",
      "code": "struct Block {\n    index: u64,\n    data: String,\n    previous_hash: String,\n    hash: String,\n}\n\nfn calculate_hash(block: &Block) -> String {\n    format!(\"hash_{}{}{}\", block.index, block.data, block.previous_hash)\n}\n\nfn validate_block(block: &Block, previous: &Block) -> bool {\n    // Check sequential index\n    if block.index != previous.index + 1 {\n        println!(\"Invalid index\");\n        return false;\n    }\n    \n    // Check previous hash link\n    if block.previous_hash != previous.hash {\n        println!(\"Invalid previous hash link\");\n        return false;\n    }\n    \n    // Check hash is correct\n    let calculated_hash = calculate_hash(block);\n    if block.hash != calculated_hash {\n        println!(\"Invalid hash\");\n        return false;\n    }\n    \n    true\n}\n\nfn main() {\n    let block0 = Block {\n        index: 0,\n        data: String::from(\"Genesis\"),\n        previous_hash: String::from(\"0\"),\n        hash: String::from(\"hash_0Genesis0\"),\n    };\n    \n    let block1 = Block {\n        index: 1,\n        data: String::from(\"Block1\"),\n        previous_hash: String::from(\"hash_0Genesis0\"),\n        hash: String::from(\"hash_1Block1hash_0Genesis0\"),\n    };\n    \n    println!(\"Block valid: {}\", validate_block(&block1, &block0));\n}",
      "explanation": "Block validation ensures only valid blocks are added to the chain. This maintains blockchain integrity and prevents invalid states.",
      "language": "rust"
    },
    {
      "id": "ex-39-2-chain-selection",
      "title": "Chain Selection",
      "description": "Selecting the best chain when forks occur",
      "code": "struct Blockchain {\n    blocks: Vec<Block>,\n}\n\nstruct Block {\n    index: u64,\n    hash: String,\n}\n\nimpl Blockchain {\n    fn length(&self) -> usize {\n        self.blocks.len()\n    }\n}\n\nfn select_longest_chain(chains: Vec<Blockchain>) -> Blockchain {\n    // Select chain with most blocks (longest chain rule)\n    chains.into_iter()\n        .max_by_key(|chain| chain.length())\n        .unwrap()\n}\n\nfn main() {\n    let chain1 = Blockchain {\n        blocks: vec![\n            Block { index: 0, hash: String::from(\"hash0\") },\n            Block { index: 1, hash: String::from(\"hash1\") },\n        ],\n    };\n    \n    let chain2 = Blockchain {\n        blocks: vec![\n            Block { index: 0, hash: String::from(\"hash0\") },\n            Block { index: 1, hash: String::from(\"hash1\") },\n            Block { index: 2, hash: String::from(\"hash2\") },\n        ],\n    };\n    \n    let best_chain = select_longest_chain(vec![chain1, chain2]);\n    println!(\"Best chain length: {}\", best_chain.length());\n}",
      "explanation": "When forks occur, the longest valid chain is selected. This ensures all nodes eventually agree on the canonical chain.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-39-1",
      "title": "Validate Block",
      "description": "Create a function that validates a block!",
      "starterCode": "struct Block {\n    index: u64,\n    previous_hash: String,\n    hash: String,\n}\n\n// Create validate_block function\n// Check: index is previous.index + 1\n// Check: previous_hash matches previous.hash\n// Return true if valid, false otherwise\n\nfn main() {\n    let prev = Block {\n        index: 0,\n        previous_hash: String::from(\"0\"),\n        hash: String::from(\"hash0\"),\n    };\n    \n    let block = Block {\n        index: 1,\n        previous_hash: String::from(\"hash0\"),\n        hash: String::from(\"hash1\"),\n    };\n    \n    // Validate and print result\n}",
      "solution": "struct Block {\n    index: u64,\n    previous_hash: String,\n    hash: String,\n}\n\nfn validate_block(block: &Block, previous: &Block) -> bool {\n    block.index == previous.index + 1 && \n    block.previous_hash == previous.hash\n}\n\nfn main() {\n    let prev = Block {\n        index: 0,\n        previous_hash: String::from(\"0\"),\n        hash: String::from(\"hash0\"),\n    };\n    \n    let block = Block {\n        index: 1,\n        previous_hash: String::from(\"hash0\"),\n        hash: String::from(\"hash1\"),\n    };\n    \n    println!(\"Valid: {}\", validate_block(&block, &prev));\n}",
      "hints": [
        "Check index is sequential",
        "Check previous_hash matches previous block's hash"
      ],
      "difficulty": "medium"
    }
  ]
}

