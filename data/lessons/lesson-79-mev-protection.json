{
  "id": "lesson-79-mev-protection",
  "title": "MEV: Maximal Extractable Value and Protection",
  "description": "Understanding MEV, its types, Flashbots, arbitrage mechanisms, and front-running prevention.",
  "content": "# MEV: Maximal Extractable Value and Protection\n\n**MEV** (Maximal Extractable Value) is profit extracted by reordering, including, or excluding transactions in blocks.\n\n## What is MEV?\n\nMEV represents the maximum value that can be extracted from block production by manipulating transaction order.\n\n### Sources of MEV\n\n1. **Arbitrage**: Price differences across DEXs\n2. **Liquidation**: Liquidating undercollateralized positions\n3. **Front-running**: Seeing pending transactions and executing first\n4. **Sandwich Attacks**: Placing orders before and after target transaction\n5. **Back-running**: Following profitable transactions\n\n## Types of MEV\n\n### 1. Arbitrage\n\n```rust\nstruct ArbitrageOpportunity {\n    dex_a: String,\n    dex_b: String,\n    token: String,\n    price_a: u64,\n    price_b: u64,\n    profit: u64,\n}\n\nstruct ArbitrageBot {\n    dexes: Vec<String>,\n    min_profit: u64,\n}\n\nimpl ArbitrageBot {\n    fn find_opportunity(&self, token: &str) -> Option<ArbitrageOpportunity> {\n        // Compare prices across DEXs\n        // Find profitable arbitrage\n        \n        // Example: Buy on DEX A, sell on DEX B\n        let price_a = self.get_price(\"dex_a\", token);\n        let price_b = self.get_price(\"dex_b\", token);\n        \n        if price_b > price_a {\n            let profit = price_b - price_a - self.calculate_fees(price_a);\n            if profit > self.min_profit {\n                return Some(ArbitrageOpportunity {\n                    dex_a: String::from(\"dex_a\"),\n                    dex_b: String::from(\"dex_b\"),\n                    token: token.to_string(),\n                    price_a,\n                    price_b,\n                    profit,\n                });\n            }\n        }\n        \n        None\n    }\n    \n    fn execute_arbitrage(&self, opportunity: &ArbitrageOpportunity) -> Result<u64, String> {\n        // Execute buy on DEX A\n        // Execute sell on DEX B\n        // Return profit\n        Ok(opportunity.profit)\n    }\n}\n```\n\n### 2. Front-Running\n\n```rust\n// Front-running: See pending transaction, execute similar one first\nstruct PendingTransaction {\n    hash: String,\n    from: String,\n    to: String,\n    data: Vec<u8>,\n    gas_price: u64,\n}\n\nstruct FrontRunner {\n    mempool: Vec<PendingTransaction>,\n}\n\nimpl FrontRunner {\n    fn detect_opportunity(&self, tx: &PendingTransaction) -> bool {\n        // Detect if transaction is profitable (e.g., large DEX swap)\n        // If yes, front-run it with higher gas price\n        \n        // Check if it's a DEX swap\n        if self.is_dex_swap(tx) {\n            // Estimate price impact\n            let impact = self.estimate_price_impact(tx);\n            return impact > self.min_profit_threshold;\n        }\n        \n        false\n    }\n    \n    fn front_run(&self, target_tx: &PendingTransaction) -> PendingTransaction {\n        // Create similar transaction with higher gas price\n        PendingTransaction {\n            hash: String::from(\"front_run_tx\"),\n            from: String::from(\"attacker\"),\n            to: target_tx.to.clone(),\n            data: self.modify_data(&target_tx.data),\n            gas_price: target_tx.gas_price + 1, // Higher gas to get included first\n        }\n    }\n}\n```\n\n### 3. Sandwich Attack\n\n```rust\nstruct SandwichAttack {\n    front_tx: PendingTransaction,\n    target_tx: PendingTransaction,\n    back_tx: PendingTransaction,\n}\n\nimpl SandwichAttack {\n    fn create_sandwich(&self, target: &PendingTransaction) -> SandwichAttack {\n        // Front-run: Buy before target\n        let front_tx = self.create_buy_tx(target);\n        \n        // Target transaction (victim's swap)\n        let target_tx = target.clone();\n        \n        // Back-run: Sell after target (at better price)\n        let back_tx = self.create_sell_tx(target);\n        \n        SandwichAttack {\n            front_tx,\n            target_tx,\n            back_tx,\n        }\n    }\n    \n    fn execute(&self) -> Result<u64, String> {\n        // Execute in order: front -> target -> back\n        // Profit from price manipulation\n        Ok(0)\n    }\n}\n```\n\n## MEV Protection\n\n### 1. Private Mempools (Flashbots)\n\n**Flashbots** provides a private mempool to prevent front-running:\n\n```rust\nstruct FlashbotsBundle {\n    transactions: Vec<PendingTransaction>,\n    block_number: u64,\n    min_timestamp: Option<u64>,\n    max_timestamp: Option<u64>,\n}\n\nstruct FlashbotsProtection {\n    bundles: Vec<FlashbotsBundle>,\n}\n\nimpl FlashbotsProtection {\n    fn create_bundle(&mut self, txs: Vec<PendingTransaction>) -> FlashbotsBundle {\n        FlashbotsBundle {\n            transactions: txs,\n            block_number: 0,\n            min_timestamp: None,\n            max_timestamp: None,\n        }\n    }\n    \n    fn submit_bundle(&self, bundle: &FlashbotsBundle) -> Result<(), String> {\n        // Submit to Flashbots relay\n        // Transactions are private until included in block\n        // Prevents front-running\n        Ok(())\n    }\n}\n```\n\n### 2. Commit-Reveal Scheme\n\n```rust\nstruct CommitReveal {\n    commitment: Vec<u8>, // hash(secret + transaction_data)\n    reveal_block: u64,\n}\n\nimpl CommitReveal {\n    fn commit(&self, secret: &[u8], tx_data: &[u8]) -> Vec<u8> {\n        // Hash secret + transaction data\n        // Submit commitment first\n        // Reveal later\n        vec![]\n    }\n    \n    fn reveal(&self, secret: &[u8], tx_data: &[u8], commitment: &[u8]) -> bool {\n        // Verify commitment matches\n        // Execute transaction if valid\n        true\n    }\n}\n```\n\n### 3. Time-Delayed Execution\n\n```rust\nstruct TimeDelayedTx {\n    transaction: PendingTransaction,\n    execute_after: u64, // Block number\n}\n\nimpl TimeDelayedTx {\n    fn create_delayed_tx(tx: PendingTransaction, delay: u64) -> Self {\n        TimeDelayedTx {\n            transaction: tx,\n            execute_after: current_block() + delay,\n        }\n    }\n    \n    fn can_execute(&self, current_block: u64) -> bool {\n        current_block >= self.execute_after\n    }\n}\n```\n\n### 4. Slippage Protection\n\n```rust\nstruct SwapWithSlippage {\n    amount_in: u64,\n    min_amount_out: u64, // Minimum acceptable output\n    max_slippage: u8,    // Percentage (e.g., 1 = 1%)\n}\n\nimpl SwapWithSlippage {\n    fn execute_swap(&self, pool: &AMMPool) -> Result<u64, String> {\n        let amount_out = pool.calculate_output(self.amount_in);\n        \n        // Check slippage\n        let expected_out = self.amount_in; // Simplified\n        let slippage = ((expected_out - amount_out) * 100) / expected_out;\n        \n        if slippage > self.max_slippage as u64 {\n            return Err(String::from(\"Slippage too high\"));\n        }\n        \n        if amount_out < self.min_amount_out {\n            return Err(String::from(\"Output below minimum\"));\n        }\n        \n        Ok(amount_out)\n    }\n}\n```\n\n## Real-World Examples\n\n- **Flashbots**: Private mempool, MEV protection\n- **CowSwap**: Batch auctions, MEV protection\n- **1inch**: DEX aggregator with MEV protection\n- **Uniswap V3**: Concentrated liquidity, reduced MEV\n\n## Best Practices\n\n1. **Use Private Mempools**: Flashbots for sensitive transactions\n2. **Set Slippage Limits**: Protect against sandwich attacks\n3. **Batch Transactions**: Reduce MEV opportunities\n4. **Time Delays**: Delay execution to prevent front-running\n5. **Commit-Reveal**: Hide transaction details until execution",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": [
    "lesson-70-defi-protocols",
    "lesson-49-building-blockchain"
  ],
  "codeExamples": [
    {
      "id": "ex-79-1-arbitrage",
      "title": "Arbitrage Detection",
      "description": "Simple arbitrage opportunity detection",
      "code": "struct DEXPrice {\n    dex: String,\n    price: u64,\n}\n\nstruct ArbitrageBot {\n    min_profit: u64,\n    fee_percentage: u8,\n}\n\nimpl ArbitrageBot {\n    fn new(min_profit: u64) -> Self {\n        ArbitrageBot {\n            min_profit,\n            fee_percentage: 3, // 0.3%\n        }\n    }\n    \n    fn find_arbitrage(&self, prices: &[DEXPrice]) -> Option<(String, String, u64)> {\n        if prices.len() < 2 {\n            return None;\n        }\n        \n        // Find best buy and sell prices\n        let mut best_buy: Option<&DEXPrice> = None;\n        let mut best_sell: Option<&DEXPrice> = None;\n        \n        for price in prices {\n            if best_buy.is_none() || price.price < best_buy.unwrap().price {\n                best_buy = Some(price);\n            }\n            if best_sell.is_none() || price.price > best_sell.unwrap().price {\n                best_sell = Some(price);\n            }\n        }\n        \n        if let (Some(buy), Some(sell)) = (best_buy, best_sell) {\n            if buy.dex == sell.dex {\n                return None; // Same DEX, no arbitrage\n            }\n            \n            // Calculate profit after fees\n            let price_diff = sell.price - buy.price;\n            let fees = (buy.price * self.fee_percentage as u64) / 1000 +\n                      (sell.price * self.fee_percentage as u64) / 1000;\n            let profit = price_diff.saturating_sub(fees);\n            \n            if profit > self.min_profit {\n                return Some((buy.dex.clone(), sell.dex.clone(), profit));\n            }\n        }\n        \n        None\n    }\n}\n\nfn main() {\n    let bot = ArbitrageBot::new(100); // Min profit: 100\n    \n    let prices = vec![\n        DEXPrice { dex: String::from(\"Uniswap\"), price: 2000 },\n        DEXPrice { dex: String::from(\"SushiSwap\"), price: 2010 },\n        DEXPrice { dex: String::from(\"Curve\"), price: 1995 },\n    ];\n    \n    if let Some((buy_dex, sell_dex, profit)) = bot.find_arbitrage(&prices) {\n        println!(\"Arbitrage opportunity found!\");\n        println!(\"Buy on: {}, Sell on: {}\", buy_dex, sell_dex);\n        println!(\"Expected profit: {}\", profit);\n    } else {\n        println!(\"No arbitrage opportunity\");\n    }\n}",
      "explanation": "Arbitrage bots find price differences across DEXs. They buy on the cheaper DEX and sell on the more expensive one, profiting from the difference. This is a legitimate form of MEV that helps keep prices consistent.",
      "language": "rust"
    },
    {
      "id": "ex-79-2-slippage-protection",
      "title": "Slippage Protection",
      "description": "Protect against MEV with slippage limits",
      "code": "struct SwapRequest {\n    amount_in: u64,\n    min_amount_out: u64,\n    max_slippage_percent: u8,\n}\n\nstruct AMMPool {\n    reserve_in: u64,\n    reserve_out: u64,\n}\n\nimpl AMMPool {\n    fn calculate_output(&self, amount_in: u64) -> u64 {\n        // Constant product formula: x * y = k\n        let k = self.reserve_in * self.reserve_out;\n        let new_reserve_in = self.reserve_in + amount_in;\n        let new_reserve_out = k / new_reserve_in;\n        self.reserve_out - new_reserve_out\n    }\n}\n\nimpl SwapRequest {\n    fn execute_swap(&self, pool: &AMMPool) -> Result<u64, String> {\n        let amount_out = pool.calculate_output(self.amount_in);\n        \n        // Calculate expected output (simplified: assume 1:1 ratio)\n        let expected_out = self.amount_in;\n        \n        // Calculate slippage percentage\n        if expected_out == 0 {\n            return Err(String::from(\"Invalid amount\"));\n        }\n        \n        let slippage = if amount_out < expected_out {\n            ((expected_out - amount_out) * 100) / expected_out\n        } else {\n            0\n        };\n        \n        // Check slippage limit\n        if slippage > self.max_slippage_percent as u64 {\n            return Err(format!(\"Slippage too high: {}% (max: {}%)\", \n                             slippage, self.max_slippage_percent));\n        }\n        \n        // Check minimum output\n        if amount_out < self.min_amount_out {\n            return Err(format!(\"Output {} below minimum {}\", \n                             amount_out, self.min_amount_out));\n        }\n        \n        Ok(amount_out)\n    }\n}\n\nfn main() {\n    let pool = AMMPool {\n        reserve_in: 1000000,\n        reserve_out: 2000000,\n    };\n    \n    let swap = SwapRequest {\n        amount_in: 10000,\n        min_amount_out: 19000, // Minimum acceptable\n        max_slippage_percent: 5, // Max 5% slippage\n    };\n    \n    match swap.execute_swap(&pool) {\n        Ok(amount_out) => {\n            println!(\"Swap successful! Output: {}\", amount_out);\n        }\n        Err(e) => {\n            println!(\"Swap failed: {}\", e);\n            println!(\"This protects against sandwich attacks!\");\n        }\n    }\n}",
      "explanation": "Slippage protection prevents MEV attacks by rejecting transactions if the price moves too much. Users set a maximum acceptable slippage percentage and minimum output amount. This protects against sandwich attacks.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-79-1",
      "title": "Arbitrage Detection",
      "description": "Create a function that detects arbitrage opportunities!",
      "starterCode": "struct Price {\n    dex: String,\n    price: u64,\n}\n\nfn find_arbitrage(prices: &[Price]) -> Option<(String, String)> {\n    // Find best buy and sell prices\n    // Return (buy_dex, sell_dex) if profitable\n}",
      "solution": "struct Price {\n    dex: String,\n    price: u64,\n}\n\nfn find_arbitrage(prices: &[Price]) -> Option<(String, String)> {\n    if prices.len() < 2 {\n        return None;\n    }\n    \n    let mut best_buy: Option<&Price> = None;\n    let mut best_sell: Option<&Price> = None;\n    \n    for price in prices {\n        if best_buy.is_none() || price.price < best_buy.unwrap().price {\n            best_buy = Some(price);\n        }\n        if best_sell.is_none() || price.price > best_sell.unwrap().price {\n            best_sell = Some(price);\n        }\n    }\n    \n    if let (Some(buy), Some(sell)) = (best_buy, best_sell) {\n        if buy.dex != sell.dex && sell.price > buy.price {\n            return Some((buy.dex.clone(), sell.dex.clone()));\n        }\n    }\n    \n    None\n}\n\nfn main() {\n    let prices = vec![\n        Price { dex: String::from(\"DEX1\"), price: 100 },\n        Price { dex: String::from(\"DEX2\"), price: 105 },\n    ];\n    \n    if let Some((buy, sell)) = find_arbitrage(&prices) {\n        println!(\"Arbitrage: Buy on {}, Sell on {}\", buy, sell);\n    }\n}",
      "hints": [
        "Find minimum price (best buy)",
        "Find maximum price (best sell)",
        "Check they're different DEXs",
        "Check sell price > buy price"
      ],
      "difficulty": "medium"
    }
  ]
}

