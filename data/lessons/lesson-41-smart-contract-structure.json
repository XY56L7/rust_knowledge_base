{
  "id": "lesson-41-smart-contract-structure",
  "title": "Smart Contract Structure",
  "description": "Building well-structured smart contracts in Rust.",
  "content": "# Smart Contract Structure\n\nSmart contracts need clear structure for maintainability and security. Let's build a token contract as an example.\n\n## Contract Components\n\n1. **State**: Contract storage\n2. **Events**: Log important actions\n3. **Functions**: Public and private methods\n4. **Initialization**: Contract setup\n\n## Token Contract Example\n\n```rust\nstruct TokenContract {\n    name: String,\n    symbol: String,\n    total_supply: u64,\n    balances: HashMap<String, u64>,\n    owner: String,\n}\n\nimpl TokenContract {\n    fn new(name: String, symbol: String, initial_supply: u64) -> Self {\n        let mut contract = TokenContract {\n            name,\n            symbol,\n            total_supply: initial_supply,\n            balances: HashMap::new(),\n            owner: String::from(\"deployer\"),\n        };\n        \n        // Give all tokens to deployer\n        contract.balances.insert(contract.owner.clone(), initial_supply);\n        contract\n    }\n    \n    fn transfer(&mut self, from: String, to: String, amount: u64) -> Result<(), String> {\n        // Check balance\n        let balance = self.balances.get(&from).copied().unwrap_or(0);\n        if balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        // Transfer\n        *self.balances.get_mut(&from).unwrap() -= amount;\n        *self.balances.entry(to).or_insert(0) += amount;\n        \n        Ok(())\n    }\n}\n```\n\n## Best Practices\n\n- **Access control**: Check permissions\n- **Input validation**: Validate all inputs\n- **Error handling**: Return clear errors\n- **Events**: Emit events for important actions\n- **Gas optimization**: Minimize storage operations\n\n## Security Considerations\n\n- **Reentrancy**: Prevent recursive calls\n- **Overflow**: Use checked arithmetic\n- **Access control**: Verify caller permissions\n- **Input validation**: Sanitize all inputs",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": [
    "lesson-40-wasm-basics"
  ],
  "codeExamples": [
    {
      "id": "ex-41-1-token-contract",
      "title": "Token Contract",
      "description": "Simple token contract implementation",
      "code": "use std::collections::HashMap;\nstruct TokenContract {\n    name: String,\n    symbol: String,\n    total_supply: u64,\n    balances: HashMap<String, u64>,\n}\nimpl TokenContract {\n    fn new(name: String, symbol: String, initial_supply: u64) -> Self {\n        let mut contract = TokenContract {\n            name,\n            symbol,\n            total_supply: initial_supply,\n            balances: HashMap::new(),\n        };\n        contract.balances.insert(String::from(\"deployer\"), initial_supply);\n        contract\n    }\n    fn balance_of(&self, address: &str) -> u64 {\n        self.balances.get(address).copied().unwrap_or(0)\n    }\n    fn transfer(&mut self, from: String, to: String, amount: u64) -> Result<(), String> {\n        let balance = self.balance_of(&from);\n        if balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        *self.balances.entry(from).or_insert(0) -= amount;\n        *self.balances.entry(to).or_insert(0) += amount;\n        Ok(())\n    }\n}\nfn main() {\n    let mut contract = TokenContract::new(\n        String::from(\"MyToken\"),\n        String::from(\"MTK\"),\n        1000,\n    );\n    println!(\"Deployer balance: {}\", contract.balance_of(\"deployer\"));\n    contract.transfer(\n        String::from(\"deployer\"),\n        String::from(\"alice\"),\n        100,\n    ).unwrap();\n    println!(\"Alice balance: {}\", contract.balance_of(\"alice\"));\n}",
      "explanation": "A token contract manages balances and allows transfers. It maintains a mapping of addresses to token balances and validates transfers.",
      "language": "rust"
    },
    {
      "id": "ex-41-2-access-control",
      "title": "Access Control",
      "description": "Implementing access control in contracts",
      "code": "struct Contract {\n    owner: String,\n    data: String,\n}\nimpl Contract {\n    fn new(owner: String) -> Self {\n        Contract {\n            owner,\n            data: String::from(\"initial\"),\n        }\n    }\n    fn set_data(&mut self, caller: &str, new_data: String) -> Result<(), String> {\n        if caller != self.owner {\n            return Err(String::from(\"Only owner can modify\"));\n        }\n        self.data = new_data;\n        Ok(())\n    }\n    fn get_data(&self) -> &str {\n        &self.data\n    }\n}\nfn main() {\n    let mut contract = Contract::new(String::from(\"owner\"));\n    contract.set_data(\"owner\", String::from(\"modified\")).unwrap();\n    println!(\"Data: {}\", contract.get_data());\n    match contract.set_data(\"hacker\", String::from(\"hacked\")) {\n        Ok(_) => println!(\"Modified\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "explanation": "Access control ensures only authorized addresses can perform certain actions. This is critical for contract security.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-41-1",
      "title": "Create Token Contract",
      "description": "Create a token contract with transfer functionality!",
      "starterCode": "use std::collections::HashMap;\nstruct TokenContract {\n    balances: HashMap<String, u64>,\n}\nfn main() {\n    let mut contract = TokenContract::new();\n    println!(\"Deployer balance: {}\", contract.balance_of(\"deployer\"));\n}",
      "solution": "use std::collections::HashMap;\nstruct TokenContract {\n    balances: HashMap<String, u64>,\n}\nimpl TokenContract {\n    fn new() -> Self {\n        let mut balances = HashMap::new();\n        balances.insert(String::from(\"deployer\"), 1000);\n        TokenContract { balances }\n    }\n    fn balance_of(&self, address: &str) -> u64 {\n        self.balances.get(address).copied().unwrap_or(0)\n    }\n    fn transfer(&mut self, from: String, to: String, amount: u64) -> Result<(), String> {\n        let balance = self.balance_of(&from);\n        if balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        *self.balances.entry(from).or_insert(0) -= amount;\n        *self.balances.entry(to).or_insert(0) += amount;\n        Ok(())\n    }\n}\nfn main() {\n    let mut contract = TokenContract::new();\n    println!(\"Deployer balance: {}\", contract.balance_of(\"deployer\"));\n}",
      "hints": [
        "Use HashMap to store balances",
        "Initialize deployer with 1000 tokens",
        "Check balance before transferring"
      ],
      "difficulty": "hard"
    }
  ]
}
