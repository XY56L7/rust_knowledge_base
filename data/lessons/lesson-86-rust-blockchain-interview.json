{
  "id": "lesson-86-rust-blockchain-interview",
  "title": "Rust Blockchain Interview Q&A",
  "description": "Common interview questions and answers for Rust blockchain developers at junior and medior levels.",
  "content": "# Rust Blockchain Interview Q&A\n\nThis guide covers common interview questions for Rust blockchain developers, organized by difficulty level.\n\n## Junior Level Questions\n\n### 1. Why is Rust used for blockchain development?\n\n**Answer:**\n\nRust is ideal for blockchain development because:\n\n- **Memory Safety**: Prevents common bugs (buffer overflows, use-after-free) that could lead to exploits\n- **Performance**: Zero-cost abstractions provide C/C++ level performance\n- **Concurrency**: Safe parallel processing essential for consensus mechanisms\n- **No Garbage Collector**: Predictable performance for real-time blockchain operations\n- **Type Safety**: Catches errors at compile time, preventing runtime failures\n- **Deterministic**: Same input always produces same output (critical for consensus)\n\n**Example:**\n```rust\n// Rust's ownership system prevents double-spending bugs\nfn transfer(balance: &mut u64, amount: u64) -> Result<(), String> {\n    if *balance < amount {\n        return Err(String::from(\"Insufficient balance\"));\n    }\n    *balance -= amount; // Compiler ensures this is safe\n    Ok(())\n}\n```\n\n### 2. What is ownership in Rust?\n\n**Answer:**\n\nOwnership is Rust's memory management system:\n\n- Each value has **one owner**\n- When owner goes out of scope, value is **automatically freed**\n- **No garbage collector** needed\n- Prevents **memory leaks** and **use-after-free** bugs\n\n**Example:**\n```rust\nfn main() {\n    let s = String::from(\"hello\"); // s owns the string\n    let s2 = s; // Ownership moves to s2\n    // println!(\"{}\", s); // ERROR: s no longer owns the value\n    println!(\"{}\", s2); // OK: s2 owns it\n} // s2 goes out of scope, memory is freed\n```\n\n### 3. What is the difference between `&str` and `String`?\n\n**Answer:**\n\n- **`&str`**: String slice, borrowed reference, immutable, fixed size\n- **`String`**: Owned string, heap-allocated, mutable, growable\n\n**Example:**\n```rust\nfn process_string(s: &str) { // Accepts both &str and &String\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let string = String::from(\"hello\"); // Owned\n    let slice = \"world\"; // &str\n    \n    process_string(&string); // &String coerces to &str\n    process_string(slice); // &str directly\n}\n```\n\n### 4. Explain `Result<T, E>` in Rust.\n\n**Answer:**\n\n`Result` is Rust's way of handling errors:\n\n- **`Ok(T)`**: Success case, contains value\n- **`Err(E)`**: Error case, contains error\n- Forces **explicit error handling**\n- No exceptions, all errors are **explicit**\n\n**Example:**\n```rust\nfn divide(a: f64, b: f64) -> Result<f64, String> {\n    if b == 0.0 {\n        Err(String::from(\"Division by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n\nfn main() {\n    match divide(10.0, 2.0) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\n### 5. What is a smart contract?\n\n**Answer:**\n\nA smart contract is:\n\n- **Self-executing code** deployed on blockchain\n- **Automatic execution** when conditions are met\n- **Immutable** once deployed (unless upgradeable)\n- **Transparent** - code visible to everyone\n- **Trustless** - no intermediaries needed\n\n**Example:**\n```rust\nstruct TokenContract {\n    balances: HashMap<String, u64>,\n}\n\nimpl TokenContract {\n    fn transfer(&mut self, from: &str, to: &str, amount: u64) -> Result<(), String> {\n        // Automatic execution when called\n        let balance = self.balances.get(from).copied().unwrap_or(0);\n        if balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        *self.balances.entry(from.to_string()).or_insert(0) -= amount;\n        *self.balances.entry(to.to_string()).or_insert(0) += amount;\n        Ok(())\n    }\n}\n```\n\n### 6. What is WebAssembly (WASM) in blockchain?\n\n**Answer:**\n\nWASM is a binary format for smart contracts:\n\n- **Near-native performance**\n- **Sandboxed execution** for security\n- **Language agnostic** (Rust, C++, etc.)\n- **Deterministic** execution\n- Used by: Polkadot, NEAR, Cosmos, Ethereum 2.0\n\n### 7. Explain borrowing in Rust.\n\n**Answer:**\n\nBorrowing allows using values without taking ownership:\n\n- **`&T`**: Immutable reference (read-only)\n- **`&mut T`**: Mutable reference (can modify)\n- **Rules**:\n  - Multiple immutable references OR one mutable reference\n  - References must be valid (no dangling pointers)\n\n**Example:**\n```rust\nfn calculate_length(s: &String) -> usize { // Borrows, doesn't own\n    s.len()\n}\n\nfn main() {\n    let s = String::from(\"hello\");\n    let len = calculate_length(&s); // Pass reference\n    println!(\"{}\", s); // s still valid!\n}\n```\n\n### 8. What is the difference between `Vec` and array?\n\n**Answer:**\n\n- **Array `[T; N]`**: Fixed size, stack-allocated, known at compile time\n- **Vec `Vec<T>`**: Dynamic size, heap-allocated, can grow/shrink\n\n**Example:**\n```rust\nlet array: [i32; 3] = [1, 2, 3]; // Fixed size\nlet mut vec = Vec::new(); // Dynamic\nvec.push(1);\nvec.push(2);\nvec.push(3);\n```\n\n### 9. What is a struct in Rust?\n\n**Answer:**\n\nA struct is a custom data type that groups related data:\n\n- **Named fields**: Each field has a name and type\n- **Methods**: Functions associated with the struct\n- **Perfect for blockchain**: Represent blocks, transactions, accounts\n\n**Example:**\n```rust\nstruct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    fee: u64,\n}\n\nimpl Transaction {\n    fn total_value(&self) -> u64 {\n        self.amount + self.fee\n    }\n}\n```\n\n### 10. How do you handle errors in Rust?\n\n**Answer:**\n\nRust uses `Result` and `Option` for error handling:\n\n- **`Result<T, E>`**: For recoverable errors\n- **`Option<T>`**: For optional values (Some/None)\n- **`?` operator**: Propagate errors\n- **`unwrap()`**: Panic on error (use carefully)\n- **`match`**: Pattern matching for error handling\n\n**Example:**\n```rust\nfn process_transaction(tx: Transaction) -> Result<(), String> {\n    validate_transaction(&tx)?; // ? propagates error\n    execute_transaction(tx)?;\n    Ok(())\n}\n```\n\n---\n\n## Medior Level Questions\n\n### 1. Explain the difference between `Box<T>`, `Rc<T>`, and `Arc<T>`.\n\n**Answer:**\n\n- **`Box<T>`**: Single ownership, heap allocation, no reference counting\n- **`Rc<T>`**: Reference counted, single-threaded, shared ownership\n- **`Arc<T>`**: Atomic reference counted, thread-safe, shared ownership\n\n**Use cases:**\n- `Box<T>`: When you need heap allocation, single owner\n- `Rc<T>`: Shared ownership in single thread (blockchain state)\n- `Arc<T>`: Shared ownership across threads (consensus, networking)\n\n**Example:**\n```rust\nuse std::sync::Arc;\nuse std::thread;\n\nstruct BlockchainState {\n    blocks: Vec<Block>,\n}\n\nfn main() {\n    let state = Arc::new(BlockchainState { blocks: Vec::new() });\n    \n    // Share state across threads\n    let state1 = Arc::clone(&state);\n    thread::spawn(move || {\n        // Use state1 in thread\n    });\n}\n```\n\n### 2. What is reentrancy and how do you prevent it?\n\n**Answer:**\n\n**Reentrancy** occurs when a contract calls an external contract that calls back before state is updated.\n\n**Prevention:**\n- **Checks-Effects-Interactions pattern**: Update state before external calls\n- **Reentrancy guard**: Lock mechanism\n- **Pull over push**: Let users withdraw instead of sending\n\n**Example:**\n```rust\nstruct ReentrancyGuard {\n    locked: bool,\n}\n\nimpl ReentrancyGuard {\n    fn lock(&mut self) -> Result<(), String> {\n        if self.locked {\n            return Err(String::from(\"Reentrancy detected\"));\n        }\n        self.locked = true;\n        Ok(())\n    }\n}\n\n// Checks-Effects-Interactions\nfn withdraw(&mut self, amount: u64) -> Result<(), String> {\n    // CHECK\n    if self.balance < amount {\n        return Err(String::from(\"Insufficient\"));\n    }\n    \n    // EFFECTS: Update state FIRST\n    self.balance -= amount;\n    \n    // INTERACTIONS: External call LAST\n    external_transfer(amount)?;\n    Ok(())\n}\n```\n\n### 3. Explain async/await in Rust for blockchain.\n\n**Answer:**\n\nAsync/await enables non-blocking I/O:\n\n- **`async fn`**: Returns a `Future`\n- **`.await`**: Waits for future to complete\n- **Tokio**: Popular async runtime\n- **Use cases**: Network I/O, multiple peer connections, transaction processing\n\n**Example:**\n```rust\nuse tokio;\n\nasync fn fetch_block_from_peer(peer: &str, height: u64) -> Result<Block, String> {\n    // Non-blocking network request\n    // ...\n    Ok(block)\n}\n\n#[tokio::main]\nasync fn main() {\n    let block = fetch_block_from_peer(\"peer1\", 100).await?;\n    println!(\"Block: {:?}\", block);\n}\n```\n\n### 4. How do you implement a Merkle tree in Rust?\n\n**Answer:**\n\nA Merkle tree is a binary tree of hashes:\n\n- **Leaves**: Hash of data\n- **Nodes**: Hash of children\n- **Root**: Single hash representing all data\n- **Use**: Efficient verification of large datasets\n\n**Example:**\n```rust\nuse sha2::{Sha256, Digest};\n\nfn hash(data: &[u8]) -> Vec<u8> {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    hasher.finalize().to_vec()\n}\n\nfn merkle_root(transactions: &[Transaction]) -> Vec<u8> {\n    if transactions.is_empty() {\n        return vec![0; 32];\n    }\n    \n    if transactions.len() == 1 {\n        return hash(&transactions[0].serialize());\n    }\n    \n    let mut hashes: Vec<Vec<u8>> = transactions\n        .iter()\n        .map(|tx| hash(&tx.serialize()))\n        .collect();\n    \n    while hashes.len() > 1 {\n        let mut next_level = Vec::new();\n        for chunk in hashes.chunks(2) {\n            if chunk.len() == 2 {\n                let combined = [chunk[0].as_slice(), chunk[1].as_slice()].concat();\n                next_level.push(hash(&combined));\n            } else {\n                next_level.push(chunk[0].clone());\n            }\n        }\n        hashes = next_level;\n    }\n    \n    hashes[0].clone()\n}\n```\n\n### 5. What is the difference between Proof of Work and Proof of Stake?\n\n**Answer:**\n\n**Proof of Work (PoW):**\n- Miners solve cryptographic puzzles\n- Requires computational power (energy intensive)\n- First to solve creates block\n- Example: Bitcoin\n\n**Proof of Stake (PoS):**\n- Validators stake tokens\n- Selected based on stake amount/age\n- More energy efficient\n- Example: Ethereum 2.0, Polkadot\n\n**Rust Implementation (PoS):**\n```rust\nstruct Validator {\n    address: String,\n    stake: u64,\n    staking_time: u64,\n}\n\nfn select_validator(validators: &[Validator]) -> &Validator {\n    // Weighted selection based on stake and time\n    validators.iter()\n        .max_by_key(|v| v.stake * v.staking_time)\n        .unwrap()\n}\n```\n\n### 6. How do you optimize gas in smart contracts?\n\n**Answer:**\n\nGas optimization techniques:\n\n- **Pack structs**: Order fields to minimize storage slots\n- **Use events**: Instead of storage for logs\n- **Batch operations**: Combine multiple operations\n- **Cache storage reads**: Read once, use multiple times\n- **Use libraries**: Reusable code\n- **Minimize loops**: Especially with storage operations\n\n**Example:**\n```rust\n// BAD: Multiple storage reads\nfn bad_function(&self) -> u64 {\n    self.balance + self.balance + self.balance // 3 reads\n}\n\n// GOOD: Cache the read\nfn good_function(&self) -> u64 {\n    let balance = self.balance; // 1 read\n    balance + balance + balance\n}\n```\n\n### 7. Explain trait objects vs generics.\n\n**Answer:**\n\n**Generics (Static Dispatch):**\n- Compile-time polymorphism\n- Zero runtime cost\n- Code duplication (monomorphization)\n- Faster execution\n\n**Trait Objects (Dynamic Dispatch):**\n- Runtime polymorphism\n- Uses vtable (virtual method table)\n- Single code, multiple types\n- Slight runtime overhead\n\n**Example:**\n```rust\n// Generics: Static dispatch\nfn process<T: Processable>(item: T) {\n    item.process(); // Inlined at compile time\n}\n\n// Trait objects: Dynamic dispatch\nfn process_dyn(item: Box<dyn Processable>) {\n    item.process(); // Lookup in vtable at runtime\n}\n```\n\n### 8. How do you implement a transaction pool?\n\n**Answer:**\n\nA transaction pool manages pending transactions:\n\n- **Add transactions**: Validate and store\n- **Remove transactions**: When included in block\n- **Prioritize**: By fee, age, etc.\n- **Evict**: Remove invalid/expired transactions\n\n**Example:**\n```rust\nuse std::collections::BTreeMap;\n\nstruct TransactionPool {\n    transactions: BTreeMap<u64, Transaction>, // Sorted by priority\n    by_sender: HashMap<String, Vec<u64>>,\n    max_size: usize,\n}\n\nimpl TransactionPool {\n    fn add(&mut self, tx: Transaction) -> Result<(), String> {\n        if self.transactions.len() >= self.max_size {\n            return Err(String::from(\"Pool full\"));\n        }\n        \n        // Validate\n        self.validate(&tx)?;\n        \n        // Add with priority (fee * age)\n        let priority = tx.fee * tx.age;\n        self.transactions.insert(priority, tx);\n        \n        Ok(())\n    }\n    \n    fn get_next(&mut self, count: usize) -> Vec<Transaction> {\n        self.transactions.values()\n            .take(count)\n            .cloned()\n            .collect()\n    }\n}\n```\n\n### 9. What is a zero-knowledge proof?\n\n**Answer:**\n\nZero-knowledge proofs allow proving knowledge without revealing the knowledge:\n\n- **Prover**: Has secret information\n- **Verifier**: Verifies proof without seeing secret\n- **Properties**: Completeness, soundness, zero-knowledge\n- **Use cases**: Privacy, scalability (zk-rollups)\n\n**Types:**\n- **zk-SNARKs**: Succinct, non-interactive\n- **zk-STARKs**: Transparent (no trusted setup)\n\n### 10. How do you test smart contracts?\n\n**Answer:**\n\nTesting strategies:\n\n- **Unit tests**: Test individual functions\n- **Integration tests**: Test contract interactions\n- **Property-based tests**: Test invariants\n- **Fuzz testing**: Random inputs\n- **Formal verification**: Mathematical proofs\n\n**Example:**\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_transfer() {\n        let mut contract = TokenContract::new(1000);\n        contract.transfer(\"alice\", \"bob\", 100).unwrap();\n        assert_eq!(contract.balance_of(\"bob\"), 100);\n    }\n    \n    #[test]\n    fn test_insufficient_balance() {\n        let mut contract = TokenContract::new(100);\n        assert!(contract.transfer(\"alice\", \"bob\", 200).is_err());\n    }\n    \n    #[test]\n    fn test_total_supply_invariant() {\n        let mut contract = TokenContract::new(1000);\n        let initial_total = contract.total_supply();\n        \n        contract.transfer(\"alice\", \"bob\", 100).unwrap();\n        \n        // Invariant: Total supply should never change\n        assert_eq!(contract.total_supply(), initial_total);\n    }\n}\n```\n\n---\n\n## Common Follow-up Questions\n\n### \"How would you design a DEX (Decentralized Exchange)?\"\n\n**Answer:**\n\nKey components:\n\n1. **Liquidity Pools**: AMM (Automated Market Maker)\n2. **Swap Function**: Constant product formula (x * y = k)\n3. **LP Tokens**: Represent liquidity provider shares\n4. **Fee Mechanism**: Trading fees to LPs\n\n**Example:**\n```rust\nstruct AMMPool {\n    token_a: u64,\n    token_b: u64,\n    lp_tokens: u64,\n}\n\nimpl AMMPool {\n    fn swap_a_for_b(&mut self, amount_a: u64) -> Result<u64, String> {\n        let k = self.token_a * self.token_b;\n        let new_token_a = self.token_a + amount_a;\n        let new_token_b = k / new_token_a;\n        let amount_b = self.token_b - new_token_b;\n        \n        self.token_a = new_token_a;\n        self.token_b = new_token_b;\n        \n        Ok(amount_b)\n    }\n}\n```\n\n### \"Explain how you would implement a lending protocol.\"\n\n**Answer:**\n\nComponents:\n\n1. **Liquidity Pools**: Users deposit assets\n2. **Interest Rates**: Algorithmic based on utilization\n3. **Collateralization**: Over-collateralized loans\n4. **Liquidation**: Under-collateralized positions\n\n**Example:**\n```rust\nstruct LendingPool {\n    total_supplied: u64,\n    total_borrowed: u64,\n    collateral_factor: u64, // e.g., 150% = 150\n}\n\nimpl LendingPool {\n    fn borrow(&mut self, amount: u64, collateral: u64) -> Result<(), String> {\n        // Check collateralization\n        let required_collateral = (amount * self.collateral_factor) / 100;\n        if collateral < required_collateral {\n            return Err(String::from(\"Insufficient collateral\"));\n        }\n        \n        self.total_borrowed += amount;\n        Ok(())\n    }\n}\n```\n\n---\n\n## Tips for Interview Success\n\n1. **Understand the basics**: Ownership, borrowing, error handling\n2. **Know blockchain concepts**: Smart contracts, consensus, cryptography\n3. **Practice coding**: Write code during interview, explain your thinking\n4. **Ask questions**: Clarify requirements before coding\n5. **Think about security**: Always consider edge cases and attacks\n6. **Explain trade-offs**: Discuss performance vs safety, gas optimization\n7. **Show experience**: Reference real projects if possible\n\n## Resources for Preparation\n\n- **Rust Book**: Official Rust documentation\n- **Blockchain Basics**: Understand consensus, hashing, Merkle trees\n- **Smart Contract Security**: Common vulnerabilities and patterns\n- **Practice Problems**: LeetCode, HackerRank with Rust\n- **Open Source**: Study real blockchain projects (Polkadot, NEAR)\n\n---\n\n## Summary\n\n**Junior Level Focus:**\n- Rust fundamentals (ownership, borrowing, types)\n- Basic blockchain concepts\n- Simple smart contract structure\n- Error handling\n\n**Medior Level Focus:**\n- Advanced Rust (traits, async, concurrency)\n- Security patterns (reentrancy, overflow)\n- Performance optimization\n- Complex blockchain systems (consensus, networking)\n- Architecture and design patterns",
  "difficulty": "intermediate",
  "estimatedTime": 90,
  "prerequisites": [
    "lesson-41-smart-contract-structure",
    "lesson-49-building-blockchain"
  ],
  "codeExamples": [
    {
      "id": "ex-86-1-ownership-explanation",
      "title": "Ownership in Interview Context",
      "description": "How to explain ownership during an interview",
      "code": "// Interview question: \"Explain ownership\"\n\n// Key points to mention:\n// 1. Each value has one owner\n// 2. Ownership moves when assigned\n// 3. Memory automatically freed when owner goes out of scope\n// 4. Prevents memory leaks and use-after-free\n\nfn demonstrate_ownership() {\n    let s1 = String::from(\"hello\"); // s1 owns the string\n    \n    // Ownership moves to s2\n    let s2 = s1;\n    \n    // println!(\"{}\", s1); // ERROR: s1 no longer owns\n    println!(\"{}\", s2); // OK: s2 owns it\n    \n    // When s2 goes out of scope, memory is automatically freed\n}\n\nfn demonstrate_borrowing() {\n    let s = String::from(\"hello\");\n    \n    // Borrow instead of move\n    let len = calculate_length(&s);\n    \n    // s still owns the value\n    println!(\"Length: {}, String: {}\", len, s);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len() // Borrows, doesn't take ownership\n}\n\nfn main() {\n    demonstrate_ownership();\n    demonstrate_borrowing();\n}",
      "explanation": "During interviews, explain ownership clearly: it's Rust's way of managing memory without a garbage collector. Show how it prevents common bugs and ensures memory safety.",
      "language": "rust"
    },
    {
      "id": "ex-86-2-reentrancy-prevention",
      "title": "Reentrancy Prevention Pattern",
      "description": "How to explain and implement reentrancy protection",
      "code": "// Interview question: \"How do you prevent reentrancy?\"\n\nstruct Bank {\n    balances: std::collections::HashMap<String, u64>,\n    locked: bool, // Simple reentrancy guard\n}\n\nimpl Bank {\n    fn withdraw(&mut self, user: &str, amount: u64) -> Result<(), String> {\n        // Reentrancy guard\n        if self.locked {\n            return Err(String::from(\"Reentrancy detected\"));\n        }\n        self.locked = true;\n        \n        // CHECKS: Validate\n        let balance = self.balances.get(user).copied().unwrap_or(0);\n        if balance < amount {\n            self.locked = false;\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        // EFFECTS: Update state FIRST\n        *self.balances.entry(user.to_string()).or_insert(0) -= amount;\n        \n        // Unlock before external call\n        self.locked = false;\n        \n        // INTERACTIONS: External call LAST\n        // external_transfer(user, amount)?;\n        \n        Ok(())\n    }\n}\n\nfn main() {\n    let mut bank = Bank {\n        balances: std::collections::HashMap::new(),\n        locked: false,\n    };\n    \n    bank.balances.insert(String::from(\"alice\"), 1000);\n    \n    match bank.withdraw(\"alice\", 500) {\n        Ok(_) => println!(\"Withdrawal successful\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "explanation": "Explain the Checks-Effects-Interactions pattern: always update state before making external calls. This prevents reentrancy attacks where external contracts call back before state is updated.",
      "language": "rust"
    },
    {
      "id": "ex-86-3-error-handling-patterns",
      "title": "Error Handling Patterns",
      "description": "Common error handling patterns in Rust blockchain development",
      "code": "// Interview question: \"How do you handle errors in smart contracts?\"\n\n// Pattern 1: Result for recoverable errors\nfn transfer(\n    balance: &mut u64,\n    amount: u64,\n) -> Result<(), String> {\n    if *balance < amount {\n        return Err(String::from(\"Insufficient balance\"));\n    }\n    *balance -= amount;\n    Ok(())\n}\n\n// Pattern 2: Option for optional values\nfn find_transaction(\n    transactions: &[Transaction],\n    tx_hash: &str,\n) -> Option<&Transaction> {\n    transactions.iter().find(|tx| tx.hash == tx_hash)\n}\n\n// Pattern 3: Error propagation with ?\nfn process_transaction(\n    tx: Transaction,\n) -> Result<(), String> {\n    validate_transaction(&tx)?; // Propagates error\n    execute_transaction(tx)?;   // Propagates error\n    Ok(())\n}\n\n// Pattern 4: Custom error types\n#[derive(Debug)]\nenum ContractError {\n    InsufficientBalance,\n    InvalidAddress,\n    Unauthorized,\n}\n\nfn secure_transfer(\n    balance: &mut u64,\n    amount: u64,\n) -> Result<(), ContractError> {\n    if *balance < amount {\n        return Err(ContractError::InsufficientBalance);\n    }\n    *balance -= amount;\n    Ok(())\n}\n\nfn main() {\n    let mut balance = 1000u64;\n    \n    // Pattern 1: Result\n    match transfer(&mut balance, 500) {\n        Ok(_) => println!(\"Transfer successful\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n    \n    // Pattern 4: Custom errors\n    match secure_transfer(&mut balance, 1000) {\n        Ok(_) => println!(\"Transfer successful\"),\n        Err(ContractError::InsufficientBalance) => {\n            println!(\"Insufficient balance\")\n        }\n        Err(e) => println!(\"Error: {:?}\", e),\n    }\n}",
      "explanation": "Show different error handling patterns: Result for recoverable errors, Option for optional values, ? for propagation, and custom error types for better error messages.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-86-1",
      "title": "Explain Ownership",
      "description": "Practice explaining ownership in your own words!",
      "starterCode": "// Write a function that demonstrates ownership\n// Explain what happens at each step\n\nfn main() {\n    // Your code here\n}",
      "solution": "// Ownership demonstration\n\nfn demonstrate_ownership() {\n    // Step 1: Create a String (heap-allocated)\n    let s1 = String::from(\"hello\");\n    println!(\"s1 owns: {}\", s1);\n    \n    // Step 2: Move ownership to s2\n    let s2 = s1; // Ownership moves, s1 is no longer valid\n    \n    // Step 3: Try to use s1 (ERROR - won't compile)\n    // println!(\"{}\", s1); // ERROR: value borrowed after move\n    \n    println!(\"s2 owns: {}\", s2);\n    \n    // Step 4: s2 goes out of scope, memory is freed automatically\n}\n\nfn demonstrate_copy() {\n    // Integers implement Copy trait\n    let x = 5;\n    let y = x; // Copy, not move\n    \n    println!(\"x: {}, y: {}\", x, y); // Both valid\n}\n\nfn main() {\n    demonstrate_ownership();\n    demonstrate_copy();\n}",
      "hints": [
        "Show ownership transfer",
        "Show Copy vs Move",
        "Explain what happens when variables go out of scope"
      ],
      "difficulty": "easy"
    },
    {
      "id": "exercise-86-2",
      "title": "Implement Reentrancy Protection",
      "description": "Implement a function with reentrancy protection!",
      "starterCode": "struct Contract {\n    balance: u64,\n    // Add reentrancy guard here\n}\n\nimpl Contract {\n    fn withdraw(&mut self, amount: u64) -> Result<(), String> {\n        // Implement checks-effects-interactions pattern\n        Ok(())\n    }\n}\n\nfn main() {\n    let mut contract = Contract { balance: 1000 };\n    contract.withdraw(500).unwrap();\n}",
      "solution": "struct Contract {\n    balance: u64,\n    locked: bool, // Reentrancy guard\n}\n\nimpl Contract {\n    fn withdraw(&mut self, amount: u64) -> Result<(), String> {\n        // Guard: Check if already locked\n        if self.locked {\n            return Err(String::from(\"Reentrancy detected\"));\n        }\n        self.locked = true;\n        \n        // CHECKS: Validate\n        if self.balance < amount {\n            self.locked = false;\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        // EFFECTS: Update state FIRST\n        self.balance -= amount;\n        \n        // Unlock\n        self.locked = false;\n        \n        // INTERACTIONS: External call would go here LAST\n        \n        Ok(())\n    }\n}\n\nfn main() {\n    let mut contract = Contract { \n        balance: 1000,\n        locked: false,\n    };\n    \n    match contract.withdraw(500) {\n        Ok(_) => println!(\"Withdrawal successful, balance: {}\", contract.balance),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "hints": [
        "Add a locked field",
        "Check locked before proceeding",
        "Update state before external calls",
        "Unlock after state update"
      ],
      "difficulty": "medium"
    }
  ],
  "projectIdeas": [
    {
      "id": "project-86-1",
      "title": "Interview Practice Platform",
      "description": "Build a platform with common Rust blockchain interview questions. Include code challenges, explanations, and mock interviews.",
      "difficulty": "medium",
      "estimatedTime": 10,
      "requirements": [
        "Store interview questions in structured format",
        "Code challenges with test cases",
        "Explanation sections",
        "Difficulty levels (junior/medior)",
        "Practice mode with hints",
        "Solution explanations"
      ],
      "hints": [
        "Use JSON for question storage",
        "Create different question categories",
        "Include code examples",
        "Add timer for practice"
      ],
      "extensions": [
        "Add video explanations",
        "Implement peer review",
        "Create interview simulator",
        "Add progress tracking",
        "Support multiple languages"
      ],
      "learningOutcomes": [
        "Master interview preparation",
        "Understand common questions",
        "Practice explaining concepts",
        "Build interview skills"
      ]
    },
    {
      "id": "project-86-2",
      "title": "Code Review Simulator",
      "description": "Create a tool that presents code with security issues and asks users to identify and fix them. Great for interview practice.",
      "difficulty": "hard",
      "estimatedTime": 12,
      "requirements": [
        "Code examples with vulnerabilities",
        "Multiple choice questions",
        "Explanation of issues",
        "Fix suggestions",
        "Difficulty levels",
        "Score tracking"
      ],
      "hints": [
        "Include common vulnerabilities",
        "Reentrancy, overflow, access control",
        "Provide hints",
        "Show correct solutions"
      ],
      "extensions": [
        "Add more vulnerability types",
        "Create custom scenarios",
        "Add time limits",
        "Implement leaderboard",
        "Support team challenges"
      ],
      "learningOutcomes": [
        "Identify security issues",
        "Understand vulnerabilities",
        "Learn secure coding",
        "Practice code review"
      ]
    }
  ]
}

