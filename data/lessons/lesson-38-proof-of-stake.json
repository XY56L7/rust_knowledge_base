{
  "id": "lesson-38-proof-of-stake",
  "title": "Proof of Stake (PoS)",
  "description": "Understanding Proof of Stake consensus mechanism used by modern blockchains.",
  "content": "# Proof of Stake (PoS)\n\n**Proof of Stake** is a consensus mechanism where validators are chosen based on the amount of cryptocurrency they \"stake\" (lock up) rather than computational work.\n\n## How PoS Works\n\n1. **Staking**: Validators lock up coins as stake\n2. **Selection**: Validator chosen based on stake amount and randomness\n3. **Validation**: Selected validator creates and validates block\n4. **Rewards**: Validator receives transaction fees\n5. **Slashing**: Malicious validators lose stake\n\n## Advantages over PoW\n\n- **Energy efficient**: No mining required\n- **Faster**: Blocks can be created quickly\n- **Scalable**: Higher transaction throughput\n- **Lower barriers**: No expensive mining hardware\n\n## Staking Structure\n\n```rust\nstruct Validator {\n    address: String,\n    stake: u64,  // Amount staked\n    is_active: bool,\n}\n\nstruct StakingPool {\n    validators: Vec<Validator>,\n    total_stake: u64,\n}\n```\n\n## Validator Selection\n\nValidators are typically selected based on:\n\n- **Stake amount**: More stake = higher chance\n- **Randomness**: Prevents predictability\n- **Age**: Some systems consider staking duration\n\n## Slashing\n\nValidators who misbehave lose their stake:\n\n- **Double signing**: Signing two conflicting blocks\n- **Downtime**: Being offline too often\n- **Malicious behavior**: Attempting attacks\n\n## PoS Variants\n\n- **Delegated PoS (DPoS)**: Stakeholders vote for delegates\n- **Liquid PoS**: Staked tokens remain liquid\n- **Hybrid PoS**: Combines PoS with other mechanisms\n\n## Ethereum 2.0\n\nEthereum moved from PoW to PoS:\n\n- 32 ETH minimum stake\n- Validators earn rewards\n- More energy efficient\n- Faster finality",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": [
    "lesson-37-proof-of-work"
  ],
  "codeExamples": [
    {
      "id": "ex-38-1-validator",
      "title": "Validator Structure",
      "description": "Creating validators and staking pool",
      "code": "struct Validator {\n    address: String,\n    stake: u64,\n    is_active: bool,\n}\nstruct StakingPool {\n    validators: Vec<Validator>,\n    total_stake: u64,\n}\nimpl StakingPool {\n    fn new() -> Self {\n        StakingPool {\n            validators: Vec::new(),\n            total_stake: 0,\n        }\n    }\n    fn add_validator(&mut self, validator: Validator) {\n        self.total_stake += validator.stake;\n        self.validators.push(validator);\n    }\n    fn select_validator(&self) -> Option<&Validator> {\n        self.validators.iter()\n            .filter(|v| v.is_active)\n            .max_by_key(|v| v.stake)\n    }\n}\nfn main() {\n    let mut pool = StakingPool::new();\n    pool.add_validator(Validator {\n        address: String::from(\"0xAlice\"),\n        stake: 1000,\n        is_active: true,\n    });\n    pool.add_validator(Validator {\n        address: String::from(\"0xBob\"),\n        stake: 2000,\n        is_active: true,\n    });\n    if let Some(validator) = pool.select_validator() {\n        println!(\"Selected validator: {} (stake: {})\",\n                validator.address, validator.stake);\n    }\n}",
      "explanation": "In PoS, validators are selected based on their stake. Higher stake typically means higher chance of being selected, but randomness is also important.",
      "language": "rust"
    },
    {
      "id": "ex-38-2-staking",
      "title": "Staking Mechanism",
      "description": "Staking and unstaking tokens",
      "code": "struct Validator {\n    address: String,\n    staked_amount: u64,\n    total_rewards: u64,\n}\nimpl Validator {\n    fn stake(&mut self, amount: u64) {\n        self.staked_amount += amount;\n        println!(\"Staked {} tokens. Total stake: {}\", amount, self.staked_amount);\n    }\n    fn unstake(&mut self, amount: u64) -> Result<(), String> {\n        if amount > self.staked_amount {\n            return Err(String::from(\"Cannot unstake more than staked\"));\n        }\n        self.staked_amount -= amount;\n        println!(\"Unstaked {} tokens. Remaining stake: {}\", amount, self.staked_amount);\n        Ok(())\n    }\n    fn add_reward(&mut self, reward: u64) {\n        self.total_rewards += reward;\n    }\n}\nfn main() {\n    let mut validator = Validator {\n        address: String::from(\"0xValidator1\"),\n        staked_amount: 0,\n        total_rewards: 0,\n    };\n    validator.stake(1000);\n    validator.stake(500);\n    validator.add_reward(10);\n    validator.unstake(300).unwrap();\n    println!(\"Final stake: {}, Total rewards: {}\",\n            validator.staked_amount, validator.total_rewards);\n}",
      "explanation": "Validators stake tokens to participate. They earn rewards for validating blocks and can unstake (after a waiting period in real systems).",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-38-1",
      "title": "Create Validator",
      "description": "Create a validator and implement staking!",
      "starterCode": "struct Validator {\n    address: String,\n    stake: u64,\n}\nfn main() {\n    let mut validator = Validator {\n        address: String::from(\"0xMyValidator\"),\n        stake: 0,\n    };\n}",
      "solution": "struct Validator {\n    address: String,\n    stake: u64,\n}\nimpl Validator {\n    fn stake(&mut self, amount: u64) {\n        self.stake += amount;\n    }\n    fn get_stake(&self) -> u64 {\n        self.stake\n    }\n}\nfn main() {\n    let mut validator = Validator {\n        address: String::from(\"0xMyValidator\"),\n        stake: 0,\n    };\n    validator.stake(1000);\n    println!(\"Stake: {}\", validator.get_stake());\n}",
      "hints": [
        "Use &mut self for methods that modify stake",
        "Add amount to existing stake"
      ],
      "difficulty": "medium"
    }
  ]
}
