{
  "id": "lesson-25-async-await",
  "title": "Async/Await",
  "description": "Asynchronous programming with async/await syntax.",
  "content": "# Async/Await\n\n**async/await** allows us to write asynchronous code that uses system resources more efficiently.\n\n## Async Function\n\n```rust\nasync fn hello() -> String {\n    String::from(\"Hello\")\n}\n```\n\n## Using Await\n\n```rust\nasync fn main() {\n    let result = hello().await;\n    println!(\"{}\", result);\n}\n```\n\n## Future Trait\n\nAsync functions return types that implement the `Future` trait.\n\n## Tokio Runtime\n\n```rust\nuse tokio;\n\n#[tokio::main]\nasync fn main() {\n    println!(\"Hello from async!\");\n}\n```\n\n## Multiple Async Operations\n\n```rust\nasync fn fetch_data() -> String {\n    // Simulated network request\n    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;\n    String::from(\"Data\")\n}\n\n#[tokio::main]\nasync fn main() {\n    let data1 = fetch_data().await;\n    let data2 = fetch_data().await;\n    println!(\"{}, {}\", data1, data2);\n}\n```\n\n## Parallel Execution\n\n```rust\nuse tokio;\n\n#[tokio::main]\nasync fn main() {\n    let handle1 = tokio::spawn(async {\n        fetch_data().await\n    });\n    \n    let handle2 = tokio::spawn(async {\n        fetch_data().await\n    });\n    \n    let (result1, result2) = tokio::join!(handle1, handle2);\n}\n```",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": [
    "lesson-24-channels"
  ],
  "codeExamples": [
    {
      "id": "ex-25-1-basic-async",
      "title": "Basic Async",
      "description": "Using async function",
      "code": "use tokio;\nasync fn hello() -> String {\n    String::from(\"Hello, async!\")\n}\n#[tokio::main]\nasync fn main() {\n    let result = hello().await;\n    println!(\"{}\", result);\n}",
      "explanation": "The async keyword creates an async function. The await keyword waits for the Future to complete. The #[tokio::main] macro creates an async main function.",
      "language": "rust"
    },
    {
      "id": "ex-25-2-multiple-async",
      "title": "Multiple Async Operations",
      "description": "Calling multiple async functions",
      "code": "use tokio;\nuse tokio::time::{sleep, Duration};\nasync fn fetch_data(id: i32) -> String {\n    sleep(Duration::from_secs(1)).await;\n    format!(\"Data {}\", id)\n}\n#[tokio::main]\nasync fn main() {\n    let data1 = fetch_data(1).await;\n    let data2 = fetch_data(2).await;\n    println!(\"{}, {}\", data1, data2);\n}",
      "explanation": "await blocks the current async function until the Future completes. Operations run sequentially.",
      "language": "rust"
    },
    {
      "id": "ex-25-3-parallel",
      "title": "Parallel Execution",
      "description": "Running multiple async operations in parallel",
      "code": "use tokio;\nuse tokio::time::{sleep, Duration};\nasync fn fetch_data(id: i32) -> String {\n    sleep(Duration::from_secs(1)).await;\n    format!(\"Data {}\", id)\n}\n#[tokio::main]\nasync fn main() {\n    let handle1 = tokio::spawn(async {\n        fetch_data(1).await\n    });\n    let handle2 = tokio::spawn(async {\n        fetch_data(2).await\n    });\n    let (result1, result2) = tokio::join!(handle1, handle2);\n    println!(\"{}, {}\", result1.unwrap(), result2.unwrap());\n}",
      "explanation": "tokio::spawn() runs async blocks in parallel. tokio::join!() waits for both operations to complete. This is faster than sequential await.",
      "language": "rust"
    },
    {
      "id": "ex-25-4-blockchain-node",
      "title": "Blockchain: Async Node Operations",
      "description": "Using async/await for blockchain node operations",
      "code": "struct BlockchainNode;\nimpl BlockchainNode {\n    async fn fetch_block_from_peer(peer_id: &str, block_height: u64) -> String {\n        format!(\"Block {} from {}\", block_height, peer_id)\n    }\n    async fn sync_from_peers(peers: Vec<&str>, start_height: u64) -> Vec<String> {\n        let mut handles = Vec::new();\n        for peer in peers {\n        }\n        vec![String::from(\"block1\"), String::from(\"block2\")]\n    }\n}\nfn main() {\n    println!(\"Blockchain nodes use async/await for:\");\n    println!(\"- Parallel block downloads from multiple peers\");\n    println!(\"- Concurrent transaction processing\");\n    println!(\"- Non-blocking network I/O\");\n    println!(\"- Efficient resource usage\");\n}",
      "explanation": "Blockchain nodes use async/await extensively for network operations. They can fetch blocks from multiple peers in parallel, process transactions concurrently, and handle network I/O without blocking.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-25-1",
      "title": "Async Function",
      "description": "Create an async function that returns a value after a delay!",
      "starterCode": "use tokio;\nuse tokio::time::{sleep, Duration};\n#[tokio::main]\nasync fn main() {\n}",
      "solution": "use tokio;\nuse tokio::time::{sleep, Duration};\nasync fn delay() -> String {\n    sleep(Duration::from_secs(2)).await;\n    String::from(\"Ready!\")\n}\n#[tokio::main]\nasync fn main() {\n    let result = delay().await;\n    println!(\"{}\", result);\n}",
      "hints": [
        "Use the async keyword for the function",
        "sleep().await delays execution",
        "The await keyword waits for completion"
      ],
      "difficulty": "medium"
    }
  ],
  "projectIdeas": [
    {
      "id": "project-25-1",
      "title": "Async Blockchain Node",
      "description": "Build an async blockchain node that can handle multiple network operations concurrently. Fetch blocks from multiple peers, process transactions, and sync state all asynchronously.",
      "difficulty": "hard",
      "estimatedTime": 15,
      "requirements": [
        "Async block fetching from multiple peers",
        "Concurrent transaction processing",
        "Async state synchronization",
        "Non-blocking network I/O",
        "Handle multiple connections simultaneously",
        "Async error handling"
      ],
      "hints": [
        "Use tokio for async runtime",
        "Use tokio::spawn for concurrent tasks",
        "Use channels for async communication",
        "Use tokio::join! for parallel operations"
      ],
      "extensions": [
        "Add WebSocket support",
        "Implement async RPC server",
        "Add connection pooling",
        "Support async database operations",
        "Add metrics and monitoring",
        "Implement rate limiting"
      ],
      "learningOutcomes": [
        "Master async/await patterns",
        "Understand async I/O",
        "Learn concurrent network programming",
        "Practice with Tokio runtime"
      ]
    },
    {
      "id": "project-25-2",
      "title": "Async Transaction Pool Manager",
      "description": "Create an async transaction pool that can add, remove, and process transactions concurrently. Use async channels for communication.",
      "difficulty": "medium",
      "estimatedTime": 8,
      "requirements": [
        "Async transaction addition",
        "Concurrent transaction validation",
        "Async transaction broadcasting",
        "Non-blocking pool operations",
        "Handle multiple operations simultaneously",
        "Async state updates"
      ],
      "hints": [
        "Use tokio channels for async communication",
        "Use async mutexes for shared state",
        "Spawn tasks for concurrent operations",
        "Use select! for multiple async operations"
      ],
      "extensions": [
        "Add transaction prioritization",
        "Implement async filtering",
        "Add rate limiting",
        "Support transaction batching",
        "Add async metrics collection"
      ],
      "learningOutcomes": [
        "Understand async state management",
        "Learn async channels",
        "Practice with concurrent operations",
        "Master async patterns"
      ]
    },
    {
      "id": "project-25-3",
      "title": "Async Price Aggregator",
      "description": "Build an async price aggregator that fetches prices from multiple exchanges simultaneously. Aggregate and calculate average prices.",
      "difficulty": "medium",
      "estimatedTime": 6,
      "requirements": [
        "Fetch prices from multiple sources concurrently",
        "Use async HTTP requests",
        "Aggregate results asynchronously",
        "Handle timeouts and errors",
        "Calculate statistics (average, median)",
        "Display results"
      ],
      "hints": [
        "Use reqwest for async HTTP",
        "Use tokio::join! for parallel requests",
        "Handle errors with Result",
        "Use async timeouts"
      ],
      "extensions": [
        "Add caching with TTL",
        "Implement price change detection",
        "Add WebSocket for real-time updates",
        "Support multiple cryptocurrencies",
        "Create price history"
      ],
      "learningOutcomes": [
        "Master async HTTP requests",
        "Learn parallel async operations",
        "Understand error handling in async",
        "Practice with real-world async patterns"
      ]
    }
  ]
}
