{
  "id": "lesson-67-layer2-solutions",
  "title": "Layer 2 Scaling Solutions",
  "description": "Building Layer 2 solutions: Rollups, State Channels, and Sidechains for blockchain scaling.",
  "content": "# Layer 2 Scaling Solutions\n\nLayer 2 solutions scale blockchains by processing transactions off-chain while maintaining security through the main chain.\n\n## The Scaling Problem\n\nBlockchains face a **scalability trilemma**:\n\n1. **Decentralization**: Many nodes\n2. **Security**: Strong guarantees\n3. **Scalability**: High throughput\n\nYou can optimize for two, but not all three.\n\n## Layer 2 Solutions\n\n### Rollups\n\n**Rollups** bundle many transactions and submit a summary (with proof) to the main chain.\n\n#### Optimistic Rollups\n\n- Assume transactions are valid\n- Use fraud proofs to challenge invalid transactions\n- Examples: Arbitrum, Optimism\n\n#### Zero-Knowledge Rollups (ZK-Rollups)\n\n- Use ZK proofs to verify transaction validity\n- No challenge period needed\n- Examples: zkSync, StarkNet, Polygon zkEVM\n\n### State Channels\n\n**State Channels** allow parties to transact off-chain, only settling on-chain when needed.\n\n- Open channel: On-chain transaction\n- Multiple transactions: Off-chain (fast, cheap)\n- Close channel: Final state on-chain\n\nExamples: Lightning Network (Bitcoin), Raiden (Ethereum)\n\n### Sidechains\n\n**Sidechains** are separate blockchains connected to the main chain.\n\n- Independent consensus mechanism\n- Assets can move between chains\n- Examples: Polygon PoS, xDai\n\n## Rollup Implementation\n\n```rust\nstruct RollupBatch {\n    transactions: Vec<Transaction>,\n    state_root: String,\n    proof: Vec<u8>, // ZK proof or fraud proof\n    timestamp: u64,\n}\n\nstruct RollupContract {\n    batches: Vec<RollupBatch>,\n    state_root: String,\n}\n\nimpl RollupContract {\n    fn submit_batch(&mut self, batch: RollupBatch) -> Result<(), String> {\n        // Verify proof\n        if !self.verify_batch(&batch) {\n            return Err(String::from(\"Invalid batch\"));\n        }\n        \n        // Update state root\n        self.state_root = batch.state_root.clone();\n        self.batches.push(batch);\n        \n        Ok(())\n    }\n    \n    fn verify_batch(&self, batch: &RollupBatch) -> bool {\n        // Verify ZK proof or check fraud proof\n        true\n    }\n}\n```\n\n## State Channel Implementation\n\n```rust\nstruct ChannelState {\n    alice_balance: u64,\n    bob_balance: u64,\n    sequence_number: u64,\n}\n\nstruct StateChannel {\n    participants: (String, String),\n    state: ChannelState,\n    is_open: bool,\n}\n\nimpl StateChannel {\n    fn update_state(&mut self, new_state: ChannelState) {\n        // Both parties sign the new state\n        // State is valid if properly signed\n        self.state = new_state;\n    }\n    \n    fn close(&self) -> ChannelState {\n        // Final state submitted to main chain\n        self.state.clone()\n    }\n}\n```\n\n## Benefits\n\n- **Throughput**: Process thousands of transactions per second\n- **Cost**: Lower fees (amortized across batch)\n- **Speed**: Near-instant confirmation\n- **Security**: Inherits main chain security\n\n## Trade-offs\n\n- **Complexity**: More complex than Layer 1\n- **Liquidity**: Some solutions require locked funds\n- **Centralization Risk**: Some operators needed\n- **Withdrawal Delays**: Time to withdraw to main chain\n\n## Real-World Usage\n\n- **Ethereum**: Most L2 activity (Arbitrum, Optimism, zkSync)\n- **Bitcoin**: Lightning Network for payments\n- **Polygon**: Multiple L2 solutions\n\n## Choosing a Solution\n\n- **High volume, low value**: Rollups\n- **Frequent transactions between same parties**: State channels\n- **Independent needs**: Sidechains",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": [
    "lesson-49-building-blockchain",
    "lesson-66-zero-knowledge-proofs"
  ],
  "codeExamples": [
    {
      "id": "ex-67-1-rollup-batch",
      "title": "Rollup Batch",
      "description": "Implementing a rollup batch system",
      "code": "struct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n}\n\nstruct RollupBatch {\n    transactions: Vec<Transaction>,\n    state_root: String,\n    proof: String, // Simplified proof\n    batch_number: u64,\n}\n\nstruct RollupContract {\n    batches: Vec<RollupBatch>,\n    current_state_root: String,\n}\n\nimpl RollupContract {\n    fn new() -> Self {\n        RollupContract {\n            batches: Vec::new(),\n            current_state_root: String::from(\"genesis\"),\n        }\n    }\n    \n    fn submit_batch(&mut self, batch: RollupBatch) -> Result<(), String> {\n        // Verify batch proof (simplified)\n        if batch.proof != \"valid_proof\" {\n            return Err(String::from(\"Invalid proof\"));\n        }\n        \n        // Verify state transition\n        if !self.verify_state_transition(&batch) {\n            return Err(String::from(\"Invalid state transition\"));\n        }\n        \n        // Update state\n        self.current_state_root = batch.state_root.clone();\n        self.batches.push(batch);\n        \n        Ok(())\n    }\n    \n    fn verify_state_transition(&self, batch: &RollupBatch) -> bool {\n        // In real implementation: verify ZK proof or check fraud proof\n        // Here simplified: check that state root is different\n        batch.state_root != self.current_state_root\n    }\n    \n    fn get_batch_count(&self) -> usize {\n        self.batches.len()\n    }\n    \n    fn get_total_transactions(&self) -> usize {\n        self.batches.iter().map(|b| b.transactions.len()).sum()\n    }\n}\n\nfn main() {\n    let mut rollup = RollupContract::new();\n    \n    // Create a batch with multiple transactions\n    let batch = RollupBatch {\n        transactions: vec![\n            Transaction { from: String::from(\"0xAlice\"), to: String::from(\"0xBob\"), amount: 100 },\n            Transaction { from: String::from(\"0xBob\"), to: String::from(\"0xCharlie\"), amount: 50 },\n            Transaction { from: String::from(\"0xCharlie\"), to: String::from(\"0xAlice\"), amount: 25 },\n        ],\n        state_root: String::from(\"new_state_root\"),\n        proof: String::from(\"valid_proof\"),\n        batch_number: 1,\n    };\n    \n    match rollup.submit_batch(batch) {\n        Ok(_) => {\n            println!(\"Batch submitted successfully!\");\n            println!(\"Total batches: {}\", rollup.get_batch_count());\n            println!(\"Total transactions: {}\", rollup.get_total_transactions());\n            println!(\"Current state root: {}\", rollup.current_state_root);\n        }\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "explanation": "Rollups bundle many transactions into a single batch. The batch includes a proof (ZK or fraud proof) and a new state root. The main chain only needs to verify the proof, not process each transaction individually, dramatically improving throughput.",
      "language": "rust"
    },
    {
      "id": "ex-67-2-state-channel",
      "title": "State Channel",
      "description": "Implementing a state channel for off-chain transactions",
      "code": "use std::collections::HashMap;\n\nstruct ChannelState {\n    balances: HashMap<String, u64>,\n    sequence: u64,\n    is_final: bool,\n}\n\nstruct StateChannel {\n    participants: Vec<String>,\n    state: ChannelState,\n    is_open: bool,\n}\n\nimpl StateChannel {\n    fn open(participants: Vec<String>, initial_balances: HashMap<String, u64>) -> Self {\n        StateChannel {\n            participants: participants.clone(),\n            state: ChannelState {\n                balances: initial_balances,\n                sequence: 0,\n                is_final: false,\n            },\n            is_open: true,\n        }\n    }\n    \n    fn update_balance(&mut self, from: &str, to: &str, amount: u64) -> Result<(), String> {\n        if !self.is_open {\n            return Err(String::from(\"Channel is closed\"));\n        }\n        \n        let from_balance = self.state.balances.get(from).copied().unwrap_or(0);\n        if from_balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        // Update balances off-chain (no main chain transaction needed!)\n        *self.state.balances.entry(from.to_string()).or_insert(0) -= amount;\n        *self.state.balances.entry(to.to_string()).or_insert(0) += amount;\n        self.state.sequence += 1;\n        \n        Ok(())\n    }\n    \n    fn close(&mut self) -> ChannelState {\n        self.is_open = false;\n        self.state.is_final = true;\n        self.state.clone()\n    }\n}\n\nfn main() {\n    let mut balances = HashMap::new();\n    balances.insert(String::from(\"Alice\"), 1000);\n    balances.insert(String::from(\"Bob\"), 500);\n    \n    let mut channel = StateChannel::open(\n        vec![String::from(\"Alice\"), String::from(\"Bob\")],\n        balances,\n    );\n    \n    println!(\"Channel opened\");\n    \n    // Multiple off-chain transactions (fast, free!)\n    channel.update_balance(\"Alice\", \"Bob\", 100).unwrap();\n    channel.update_balance(\"Bob\", \"Alice\", 50).unwrap();\n    channel.update_balance(\"Alice\", \"Bob\", 25).unwrap();\n    \n    println!(\"Performed 3 transactions off-chain\");\n    println!(\"Sequence number: {}\", channel.state.sequence);\n    \n    // Close channel and settle on-chain\n    let final_state = channel.close();\n    println!(\"Channel closed. Final balances:\");\n    for (participant, balance) in &final_state.balances {\n        println!(\"  {}: {}\", participant, balance);\n    }\n}",
      "explanation": "State channels allow parties to transact off-chain many times, only settling the final state on-chain. This enables instant, free transactions between the same parties while maintaining security through the main chain.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-67-1",
      "title": "Simple Rollup",
      "description": "Create a simple rollup that batches transactions!",
      "starterCode": "struct Transaction {\n    amount: u64,\n}\n\nstruct RollupBatch {\n    transactions: Vec<Transaction>,\n}\n\nfn main() {\n    // Create a batch with multiple transactions\n    // Submit the batch\n}",
      "solution": "struct Transaction {\n    amount: u64,\n}\n\nstruct RollupBatch {\n    transactions: Vec<Transaction>,\n    batch_id: u64,\n}\n\nstruct Rollup {\n    batches: Vec<RollupBatch>,\n}\n\nimpl Rollup {\n    fn new() -> Self {\n        Rollup { batches: Vec::new() }\n    }\n    \n    fn submit_batch(&mut self, batch: RollupBatch) {\n        self.batches.push(batch);\n    }\n    \n    fn total_transactions(&self) -> usize {\n        self.batches.iter().map(|b| b.transactions.len()).sum()\n    }\n}\n\nfn main() {\n    let mut rollup = Rollup::new();\n    \n    let batch = RollupBatch {\n        transactions: vec![\n            Transaction { amount: 100 },\n            Transaction { amount: 200 },\n            Transaction { amount: 300 },\n        ],\n        batch_id: 1,\n    };\n    \n    rollup.submit_batch(batch);\n    println!(\"Total transactions in rollup: {}\", rollup.total_transactions());\n}",
      "hints": [
        "Create a Rollup struct to store batches",
        "Use Vec to store multiple batches",
        "Calculate total transactions across all batches"
      ],
      "difficulty": "medium"
    }
  ]
}

