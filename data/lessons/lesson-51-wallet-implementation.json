{
  "id": "lesson-51-wallet-implementation",
  "title": "Wallet Implementation",
  "description": "Building a complete cryptocurrency wallet in Rust.",
  "content": "# Wallet Implementation\n\nA **wallet** manages private keys, signs transactions, and tracks balances. Let's build a complete wallet.\n\n## Wallet Structure\n\n```rust\nstruct Wallet {\n    keypair: KeyPair,\n    address: String,\n    balance: u64,\n    nonce: u64,\n    transactions: Vec<Transaction>,\n}\n\nstruct KeyPair {\n    private_key: String,  // In production: use proper crypto types\n    public_key: String,\n}\n```\n\n## Wallet Operations\n\n### Creating a Wallet\n\n```rust\nimpl Wallet {\n    fn new() -> Self {\n        let keypair = generate_keypair();\n        let address = derive_address(&keypair.public_key);\n        \n        Wallet {\n            keypair,\n            address,\n            balance: 0,\n            nonce: 0,\n            transactions: Vec::new(),\n        }\n    }\n}\n```\n\n### Creating Transactions\n\n```rust\nfn create_transaction(&mut self, to: String, amount: u64, fee: u64) -> Result<Transaction, String> {\n    if self.balance < amount + fee {\n        return Err(String::from(\"Insufficient balance\"));\n    }\n    \n    let tx = Transaction {\n        from: self.address.clone(),\n        to,\n        amount,\n        fee,\n        nonce: self.nonce,\n        signature: None,\n    };\n    \n    // Sign transaction\n    let signed_tx = self.sign_transaction(tx)?;\n    self.nonce += 1;\n    \n    Ok(signed_tx)\n}\n```\n\n### Signing Transactions\n\n```rust\nfn sign_transaction(&self, mut tx: Transaction) -> Result<Transaction, String> {\n    // Create message to sign\n    let message = format!(\"{}{}{}{}\", tx.from, tx.to, tx.amount, tx.nonce);\n    \n    // Sign with private key (simplified)\n    tx.signature = Some(format!(\"sig_{}\", message));\n    \n    Ok(tx)\n}\n```\n\n## Wallet Features\n\n- **Key Management**: Generate and store keys securely\n- **Transaction Creation**: Build and sign transactions\n- **Balance Tracking**: Monitor account balance\n- **Transaction History**: Keep record of all transactions\n- **Nonce Management**: Track transaction nonces\n\n## Security Considerations\n\n- **Private Key Storage**: Must be encrypted\n- **Key Derivation**: Use proper key derivation functions\n- **Secure Random**: Use cryptographically secure RNG\n- **Backup**: Provide key backup/recovery\n\n## HD Wallets\n\nHierarchical Deterministic (HD) wallets:\n\n- **BIP32**: Key derivation\n- **BIP39**: Mnemonic phrases\n- **BIP44**: Multi-account structure\n\n## Implementation Example\n\n```rust\nstruct Wallet {\n    address: String,\n    balance: u64,\n    nonce: u64,\n}\n\nimpl Wallet {\n    fn new() -> Self {\n        Wallet {\n            address: String::from(\"0xWallet123\"),\n            balance: 0,\n            nonce: 0,\n        }\n    }\n    \n    fn send(&mut self, to: String, amount: u64) -> Result<(), String> {\n        if self.balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        self.balance -= amount;\n        self.nonce += 1;\n        Ok(())\n    }\n}\n```",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": [
    "lesson-35-public-key-crypto"
  ],
  "codeExamples": [
    {
      "id": "ex-51-1-wallet-structure",
      "title": "Wallet Structure",
      "description": "Complete wallet implementation",
      "code": "struct KeyPair {\n    private_key: String,\n    public_key: String,\n    address: String,\n}\nstruct Wallet {\n    keypair: KeyPair,\n    balance: u64,\n    nonce: u64,\n}\nimpl Wallet {\n    fn new() -> Self {\n        let keypair = KeyPair {\n            private_key: String::from(\"private_key_secret\"),\n            public_key: String::from(\"public_key_abc123\"),\n            address: String::from(\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"),\n        };\n        Wallet {\n            keypair,\n            balance: 0,\n            nonce: 0,\n        }\n    }\n    fn address(&self) -> &str {\n        &self.keypair.address\n    }\n    fn get_balance(&self) -> u64 {\n        self.balance\n    }\n    fn update_balance(&mut self, new_balance: u64) {\n        self.balance = new_balance;\n    }\n    fn increment_nonce(&mut self) {\n        self.nonce += 1;\n    }\n}\nfn main() {\n    let mut wallet = Wallet::new();\n    println!(\"Wallet address: {}\", wallet.address());\n    println!(\"Initial balance: {}\", wallet.get_balance());\n    wallet.update_balance(1000);\n    wallet.increment_nonce();\n    println!(\"Updated balance: {}\", wallet.get_balance());\n    println!(\"Nonce: {}\", wallet.nonce);\n}",
      "explanation": "A wallet manages keys, balance, and nonce. It provides methods to access wallet information and update state. In production, private keys must be stored securely (encrypted).",
      "language": "rust"
    },
    {
      "id": "ex-51-2-transaction-creation",
      "title": "Transaction Creation",
      "description": "Creating and signing transactions",
      "code": "struct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    fee: u64,\n    nonce: u64,\n    signature: Option<String>,\n}\nstruct Wallet {\n    address: String,\n    balance: u64,\n    nonce: u64,\n}\nimpl Wallet {\n    fn create_transaction(&mut self, to: String, amount: u64, fee: u64) -> Result<Transaction, String> {\n        if self.balance < amount + fee {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        let tx = Transaction {\n            from: self.address.clone(),\n            to,\n            amount,\n            fee,\n            nonce: self.nonce,\n            signature: None,\n        };\n        let signed_tx = self.sign(tx)?;\n        self.nonce += 1;\n        Ok(signed_tx)\n    }\n    fn sign(&self, mut tx: Transaction) -> Result<Transaction, String> {\n        let message = format!(\"{}{}{}{}\", tx.from, tx.to, tx.amount, tx.nonce);\n        tx.signature = Some(format!(\"sig_{}\", message));\n        Ok(tx)\n    }\n}\nfn main() {\n    let mut wallet = Wallet {\n        address: String::from(\"0xAlice\"),\n        balance: 1000,\n        nonce: 0,\n    };\n    match wallet.create_transaction(String::from(\"0xBob\"), 200, 10) {\n        Ok(tx) => {\n            println!(\"Transaction created!\");\n            println!(\"From: {}, To: {}, Amount: {}\", tx.from, tx.to, tx.amount);\n            println!(\"Nonce: {}, Signed: {}\", tx.nonce, tx.signature.is_some());\n        },\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "explanation": "Wallets create and sign transactions. The nonce increments with each transaction to prevent replay attacks. Signatures prove transaction authorization.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-51-1",
      "title": "Create Wallet",
      "description": "Create a wallet that can track balance and nonce!",
      "starterCode": "struct Wallet {\n    address: String,\n    balance: u64,\n    nonce: u64,\n}\nfn main() {\n    let mut wallet = Wallet::new();\n    wallet.balance = 1000;\n    wallet.send(200);\n    println!(\"Balance: {}, Nonce: {}\", wallet.get_balance(), wallet.nonce);\n}",
      "solution": "struct Wallet {\n    address: String,\n    balance: u64,\n    nonce: u64,\n}\nimpl Wallet {\n    fn new() -> Self {\n        Wallet {\n            address: String::from(\"0xWallet\"),\n            balance: 0,\n            nonce: 0,\n        }\n    }\n    fn get_balance(&self) -> u64 {\n        self.balance\n    }\n    fn send(&mut self, amount: u64) -> Result<(), String> {\n        if self.balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        self.balance -= amount;\n        self.nonce += 1;\n        Ok(())\n    }\n}\nfn main() {\n    let mut wallet = Wallet::new();\n    wallet.balance = 1000;\n    wallet.send(200).unwrap();\n    println!(\"Balance: {}, Nonce: {}\", wallet.get_balance(), wallet.nonce);\n}",
      "hints": [
        "Check balance before sending",
        "Increment nonce after successful send",
        "Return Result for error handling"
      ],
      "difficulty": "medium"
    }
  ]
}
