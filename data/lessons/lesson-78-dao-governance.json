{
  "id": "lesson-78-dao-governance",
  "title": "DAO Governance: Voting, Proposals, and Treasury",
  "description": "Implementing Decentralized Autonomous Organizations with voting mechanisms, proposals, and treasury management.",
  "content": "# DAO Governance: Voting, Proposals, and Treasury\n\n**DAOs** (Decentralized Autonomous Organizations) enable decentralized decision-making.\n\n## What is a DAO?\n\nA DAO is an organization governed by smart contracts:\n\n- **No Central Authority**: Decisions made by token holders\n- **Transparent**: All proposals and votes on-chain\n- **Automated**: Executes decisions automatically\n- **Democratic**: One token = one vote (or weighted)\n\n## Core Components\n\n### 1. Governance Token\n\n```rust\nstruct GovernanceToken {\n    name: String,\n    symbol: String,\n    total_supply: u64,\n    balances: HashMap<String, u64>,\n}\n\nimpl GovernanceToken {\n    fn voting_power(&self, holder: &str) -> u64 {\n        self.balances.get(holder).copied().unwrap_or(0)\n    }\n}\n```\n\n### 2. Proposals\n\n```rust\nenum ProposalStatus {\n    Pending,\n    Active,\n    Succeeded,\n    Defeated,\n    Executed,\n    Cancelled,\n}\n\nstruct Proposal {\n    id: u64,\n    proposer: String,\n    description: String,\n    target: String,        // Contract to call\n    calldata: Vec<u8>,     // Function call data\n    start_block: u64,\n    end_block: u64,\n    status: ProposalStatus,\n    for_votes: u64,\n    against_votes: u64,\n    abstain_votes: u64,\n}\n```\n\n### 3. Voting\n\n```rust\nenum VoteType {\n    Against,\n    For,\n    Abstain,\n}\n\nstruct Vote {\n    proposal_id: u64,\n    voter: String,\n    support: VoteType,\n    weight: u64,\n}\n\nstruct DAO {\n    proposals: HashMap<u64, Proposal>,\n    votes: HashMap<(u64, String), Vote>,\n    governance_token: GovernanceToken,\n    quorum: u64,           // Minimum votes needed\n    voting_period: u64,   // Blocks\n    execution_delay: u64, // Blocks before execution\n}\n```\n\n## Voting Mechanisms\n\n### Simple Majority\n\n```rust\nimpl DAO {\n    fn vote(&mut self, proposal_id: u64, voter: &str, support: VoteType) -> Result<(), String> {\n        let proposal = self.proposals.get_mut(&proposal_id)\n            .ok_or(\"Proposal not found\")?;\n        \n        if proposal.status != ProposalStatus::Active {\n            return Err(String::from(\"Proposal not active\"));\n        }\n        \n        // Check if already voted\n        if self.votes.contains_key(&(proposal_id, voter.to_string())) {\n            return Err(String::from(\"Already voted\"));\n        }\n        \n        let voting_power = self.governance_token.voting_power(voter);\n        \n        match support {\n            VoteType::For => proposal.for_votes += voting_power,\n            VoteType::Against => proposal.against_votes += voting_power,\n            VoteType::Abstain => proposal.abstain_votes += voting_power,\n        }\n        \n        self.votes.insert(\n            (proposal_id, voter.to_string()),\n            Vote {\n                proposal_id,\n                voter: voter.to_string(),\n                support,\n                weight: voting_power,\n            }\n        );\n        \n        Ok(())\n    }\n}\n```\n\n### Quadratic Voting\n\n```rust\n// Quadratic voting: voting power = sqrt(tokens)\nfn quadratic_voting_power(tokens: u64) -> u64 {\n    (tokens as f64).sqrt() as u64\n}\n\nimpl DAO {\n    fn vote_quadratic(&mut self, proposal_id: u64, voter: &str, support: VoteType) -> Result<(), String> {\n        let tokens = self.governance_token.voting_power(voter);\n        let voting_power = quadratic_voting_power(tokens);\n        \n        // Use quadratic voting power instead of linear\n        // ...\n    }\n}\n```\n\n### Delegation\n\n```rust\nstruct Delegation {\n    delegator: String,\n    delegate: String,\n    amount: u64,\n}\n\nimpl DAO {\n    fn delegate(&mut self, delegator: &str, delegate: &str, amount: u64) -> Result<(), String> {\n        let balance = self.governance_token.voting_power(delegator);\n        \n        if balance < amount {\n            return Err(String::from(\"Insufficient balance\"));\n        }\n        \n        // Transfer voting power\n        // In real implementation: track delegations\n        \n        Ok(())\n    }\n    \n    fn get_voting_power(&self, voter: &str) -> u64 {\n        // Own tokens + delegated tokens\n        self.governance_token.voting_power(voter)\n    }\n}\n```\n\n## Proposal Lifecycle\n\n```rust\nimpl DAO {\n    fn create_proposal(\n        &mut self,\n        proposer: &str,\n        description: String,\n        target: String,\n        calldata: Vec<u8>,\n    ) -> Result<u64, String> {\n        // Check proposer has enough tokens\n        let min_proposal_threshold = 1_000_000; // 1M tokens\n        if self.governance_token.voting_power(proposer) < min_proposal_threshold {\n            return Err(String::from(\"Insufficient voting power to propose\"));\n        }\n        \n        let proposal_id = self.proposals.len() as u64 + 1;\n        let current_block = 1000; // Simplified\n        \n        let proposal = Proposal {\n            id: proposal_id,\n            proposer: proposer.to_string(),\n            description,\n            target,\n            calldata,\n            start_block: current_block,\n            end_block: current_block + self.voting_period,\n            status: ProposalStatus::Active,\n            for_votes: 0,\n            against_votes: 0,\n            abstain_votes: 0,\n        };\n        \n        self.proposals.insert(proposal_id, proposal);\n        Ok(proposal_id)\n    }\n    \n    fn execute_proposal(&mut self, proposal_id: u64) -> Result<(), String> {\n        let proposal = self.proposals.get_mut(&proposal_id)\n            .ok_or(\"Proposal not found\")?;\n        \n        // Check status\n        if proposal.status != ProposalStatus::Succeeded {\n            return Err(String::from(\"Proposal not succeeded\"));\n        }\n        \n        // Check quorum\n        let total_votes = proposal.for_votes + proposal.against_votes + proposal.abstain_votes;\n        if total_votes < self.quorum {\n            return Err(String::from(\"Quorum not met\"));\n        }\n        \n        // Check majority\n        if proposal.for_votes <= proposal.against_votes {\n            return Err(String::from(\"Proposal defeated\"));\n        }\n        \n        // Execute proposal (call target contract)\n        // In real implementation: call external contract\n        proposal.status = ProposalStatus::Executed;\n        \n        Ok(())\n    }\n    \n    fn update_proposal_status(&mut self, proposal_id: u64, current_block: u64) {\n        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {\n            if proposal.status == ProposalStatus::Active && current_block > proposal.end_block {\n                let total_votes = proposal.for_votes + proposal.against_votes;\n                \n                if total_votes >= self.quorum && proposal.for_votes > proposal.against_votes {\n                    proposal.status = ProposalStatus::Succeeded;\n                } else {\n                    proposal.status = ProposalStatus::Defeated;\n                }\n            }\n        }\n    }\n}\n```\n\n## Treasury Management\n\n```rust\nstruct Treasury {\n    balance: u64,\n    token: String,\n    authorized_spenders: HashSet<String>,\n}\n\nimpl Treasury {\n    fn new(token: String) -> Self {\n        Treasury {\n            balance: 0,\n            token,\n            authorized_spenders: HashSet::new(),\n        }\n    }\n    \n    fn deposit(&mut self, amount: u64) {\n        self.balance += amount;\n    }\n    \n    fn withdraw(&mut self, amount: u64, recipient: &str, proposal_id: u64) -> Result<(), String> {\n        // Only authorized by proposal\n        if !self.is_authorized_by_proposal(proposal_id) {\n            return Err(String::from(\"Not authorized by proposal\"));\n        }\n        \n        if self.balance < amount {\n            return Err(String::from(\"Insufficient treasury balance\"));\n        }\n        \n        self.balance -= amount;\n        // Transfer to recipient\n        \n        Ok(())\n    }\n    \n    fn is_authorized_by_proposal(&self, proposal_id: u64) -> bool {\n        // Check if proposal was executed and authorized this withdrawal\n        // Simplified\n        true\n    }\n}\n```\n\n## Real-World Examples\n\n- **Uniswap DAO**: Governs Uniswap protocol\n- **MakerDAO**: Governs DAI stablecoin\n- **Compound**: Lending protocol governance\n- **Aragon**: DAO framework\n\n## Best Practices\n\n1. **Quorum**: Require minimum participation\n2. **Timelock**: Delay execution for security\n3. **Multisig**: Require multiple signatures for critical operations\n4. **Proposal Threshold**: Minimum tokens to propose\n5. **Voting Period**: Sufficient time for discussion\n\n## Security Considerations\n\n- **Flash Loan Attacks**: Prevent voting manipulation\n- **Proposal Spam**: Require tokens to propose\n- **Timelock**: Prevent immediate execution\n- **Multisig**: Critical operations need multiple approvals",
  "difficulty": "advanced",
  "estimatedTime": 60,
  "prerequisites": [
    "lesson-69-token-standards",
    "lesson-70-defi-protocols"
  ],
  "codeExamples": [
    {
      "id": "ex-78-1-dao-voting",
      "title": "DAO Voting System",
      "description": "Basic DAO voting implementation",
      "code": "use std::collections::{HashMap, HashSet};\n\nenum ProposalStatus {\n    Active,\n    Succeeded,\n    Defeated,\n}\n\nenum VoteType {\n    For,\n    Against,\n}\n\nstruct Proposal {\n    id: u64,\n    description: String,\n    for_votes: u64,\n    against_votes: u64,\n    status: ProposalStatus,\n    end_block: u64,\n}\n\nstruct Vote {\n    proposal_id: u64,\n    voter: String,\n    vote_type: VoteType,\n    weight: u64,\n}\n\nstruct DAO {\n    proposals: HashMap<u64, Proposal>,\n    votes: HashMap<(u64, String), Vote>,\n    token_balances: HashMap<String, u64>,\n    quorum: u64,\n}\n\nimpl DAO {\n    fn new(quorum: u64) -> Self {\n        DAO {\n            proposals: HashMap::new(),\n            votes: HashMap::new(),\n            token_balances: HashMap::new(),\n            quorum,\n        }\n    }\n    \n    fn create_proposal(&mut self, id: u64, description: String, end_block: u64) {\n        self.proposals.insert(id, Proposal {\n            id,\n            description,\n            for_votes: 0,\n            against_votes: 0,\n            status: ProposalStatus::Active,\n            end_block,\n        });\n    }\n    \n    fn vote(&mut self, proposal_id: u64, voter: &str, vote_type: VoteType) -> Result<(), String> {\n        let proposal = self.proposals.get_mut(&proposal_id)\n            .ok_or(\"Proposal not found\")?;\n        \n        if matches!(proposal.status, ProposalStatus::Succeeded | ProposalStatus::Defeated) {\n            return Err(String::from(\"Proposal not active\"));\n        }\n        \n        // Check if already voted\n        if self.votes.contains_key(&(proposal_id, voter.to_string())) {\n            return Err(String::from(\"Already voted\"));\n        }\n        \n        let voting_power = self.token_balances.get(voter).copied().unwrap_or(0);\n        \n        match vote_type {\n            VoteType::For => proposal.for_votes += voting_power,\n            VoteType::Against => proposal.against_votes += voting_power,\n        }\n        \n        self.votes.insert(\n            (proposal_id, voter.to_string()),\n            Vote {\n                proposal_id,\n                voter: voter.to_string(),\n                vote_type,\n                weight: voting_power,\n            }\n        );\n        \n        Ok(())\n    }\n    \n    fn finalize_proposal(&mut self, proposal_id: u64, current_block: u64) -> Result<(), String> {\n        let proposal = self.proposals.get_mut(&proposal_id)\n            .ok_or(\"Proposal not found\")?;\n        \n        if current_block < proposal.end_block {\n            return Err(String::from(\"Voting period not ended\"));\n        }\n        \n        let total_votes = proposal.for_votes + proposal.against_votes;\n        \n        if total_votes < self.quorum {\n            proposal.status = ProposalStatus::Defeated;\n            return Ok(());\n        }\n        \n        if proposal.for_votes > proposal.against_votes {\n            proposal.status = ProposalStatus::Succeeded;\n        } else {\n            proposal.status = ProposalStatus::Defeated;\n        }\n        \n        Ok(())\n    }\n}\n\nfn main() {\n    let mut dao = DAO::new(1000); // Quorum: 1000 tokens\n    \n    // Set token balances\n    dao.token_balances.insert(String::from(\"alice\"), 500);\n    dao.token_balances.insert(String::from(\"bob\"), 300);\n    dao.token_balances.insert(String::from(\"charlie\"), 400);\n    \n    // Create proposal\n    dao.create_proposal(1, String::from(\"Increase treasury funding\"), 1000);\n    \n    // Vote\n    dao.vote(1, \"alice\", VoteType::For).unwrap();\n    dao.vote(1, \"bob\", VoteType::For).unwrap();\n    dao.vote(1, \"charlie\", VoteType::Against).unwrap();\n    \n    // Finalize\n    dao.finalize_proposal(1, 1001).unwrap();\n    \n    let proposal = dao.proposals.get(&1).unwrap();\n    println!(\"Proposal status: {:?}\", proposal.status);\n    println!(\"For: {}, Against: {}\", proposal.for_votes, proposal.against_votes);\n}",
      "explanation": "DAOs enable decentralized governance. Token holders vote on proposals. Proposals need to meet quorum and have majority support to pass. Once passed, they can be executed to modify the protocol.",
      "language": "rust"
    },
    {
      "id": "ex-78-2-treasury",
      "title": "Treasury Management",
      "description": "DAO treasury with proposal-based withdrawals",
      "code": "use std::collections::HashMap;\n\nstruct Treasury {\n    balance: u64,\n    authorized_proposals: HashMap<u64, u64>, // proposal_id -> amount\n}\n\nimpl Treasury {\n    fn new() -> Self {\n        Treasury {\n            balance: 0,\n            authorized_proposals: HashMap::new(),\n        }\n    }\n    \n    fn deposit(&mut self, amount: u64) {\n        self.balance += amount;\n    }\n    \n    fn authorize_withdrawal(&mut self, proposal_id: u64, amount: u64) -> Result<(), String> {\n        // Only called after proposal succeeds\n        self.authorized_proposals.insert(proposal_id, amount);\n        Ok(())\n    }\n    \n    fn withdraw(&mut self, proposal_id: u64, recipient: &str) -> Result<u64, String> {\n        let amount = self.authorized_proposals.get(&proposal_id)\n            .copied()\n            .ok_or(\"Withdrawal not authorized\")?;\n        \n        if self.balance < amount {\n            return Err(String::from(\"Insufficient treasury balance\"));\n        }\n        \n        self.balance -= amount;\n        self.authorized_proposals.remove(&proposal_id);\n        \n        println!(\"Withdrew {} to {}\", amount, recipient);\n        Ok(amount)\n    }\n    \n    fn get_balance(&self) -> u64 {\n        self.balance\n    }\n}\n\nfn main() {\n    let mut treasury = Treasury::new();\n    \n    // Deposit funds\n    treasury.deposit(10_000_000);\n    println!(\"Treasury balance: {}\", treasury.get_balance());\n    \n    // Authorize withdrawal (after proposal passes)\n    treasury.authorize_withdrawal(1, 1_000_000).unwrap();\n    \n    // Execute withdrawal\n    treasury.withdraw(1, \"0xRecipient\").unwrap();\n    \n    println!(\"Remaining balance: {}\", treasury.get_balance());\n}",
      "explanation": "DAO treasuries hold funds that can only be spent through governance proposals. Proposals must pass voting, then withdrawals are authorized. This ensures transparent and democratic fund management.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-78-1",
      "title": "Simple Voting",
      "description": "Create a simple voting system!",
      "starterCode": "struct Proposal {\n    for_votes: u64,\n    against_votes: u64,\n}\n\nfn main() {\n    // Create proposal\n    // Add votes\n    // Check result\n}",
      "solution": "struct Proposal {\n    for_votes: u64,\n    against_votes: u64,\n}\n\nimpl Proposal {\n    fn new() -> Self {\n        Proposal {\n            for_votes: 0,\n            against_votes: 0,\n        }\n    }\n    \n    fn vote_for(&mut self, weight: u64) {\n        self.for_votes += weight;\n    }\n    \n    fn vote_against(&mut self, weight: u64) {\n        self.against_votes += weight;\n    }\n    \n    fn is_passed(&self) -> bool {\n        self.for_votes > self.against_votes\n    }\n}\n\nfn main() {\n    let mut proposal = Proposal::new();\n    \n    proposal.vote_for(100);\n    proposal.vote_against(50);\n    proposal.vote_for(75);\n    \n    println!(\"For: {}, Against: {}\", proposal.for_votes, proposal.against_votes);\n    println!(\"Passed: {}\", proposal.is_passed());\n}",
      "hints": [
        "Track for and against votes",
        "Compare votes to determine if passed",
        "Use methods to add votes"
      ],
      "difficulty": "easy"
    }
  ]
}

