{
  "id": "lesson-47-transaction-pool",
  "title": "Transaction Pool (Mempool)",
  "description": "Managing pending transactions before they're included in blocks.",
  "content": "# Transaction Pool (Mempool)\n\nThe **transaction pool** (mempool) stores pending transactions waiting to be included in blocks. It's critical for blockchain performance.\n\n## Pool Structure\n\n```rust\nstruct TransactionPool {\n    pending: Vec<Transaction>,\n    by_sender: HashMap<String, Vec<Transaction>>,\n    by_fee: BTreeMap<u64, Vec<Transaction>>,  // Sorted by fee\n    max_size: usize,\n}\n```\n\n## Pool Operations\n\n### Adding Transactions\n\n```rust\nfn add_transaction(&mut self, tx: Transaction) -> Result<(), String> {\n    // Validate transaction\n    if !self.validate(&tx) {\n        return Err(String::from(\"Invalid transaction\"));\n    }\n    \n    // Check nonce ordering\n    if !self.check_nonce(&tx) {\n        return Err(String::from(\"Invalid nonce\"));\n    }\n    \n    // Add to pool\n    self.pending.push(tx);\n    Ok(())\n}\n```\n\n### Selecting Transactions\n\n```rust\nfn select_for_block(&mut self, max_gas: u64) -> Vec<Transaction> {\n    // Select transactions with highest fees\n    // Respect gas limits\n    // Maintain nonce ordering\n    // Return selected transactions\n}\n```\n\n## Transaction Ordering\n\n- **Fee priority**: Higher fee = higher priority\n- **Nonce ordering**: Must process in order per sender\n- **Gas limits**: Respect block gas limit\n\n## Pool Management\n\n- **Eviction**: Remove old/low-fee transactions\n- **Replacement**: Replace with higher fee (same nonce)\n- **Cleanup**: Remove included transactions\n- **Validation**: Re-validate on state changes\n\n## Nonce Management\n\n```rust\nstruct NonceTracker {\n    current_nonces: HashMap<String, u64>,\n    pending_nonces: HashMap<String, HashSet<u64>>,\n}\n\nimpl NonceTracker {\n    fn can_add(&self, sender: &str, nonce: u64) -> bool {\n        let current = self.current_nonces.get(sender).copied().unwrap_or(0);\n        nonce == current || self.pending_nonces.get(sender)\n            .map(|set| set.contains(&(nonce - 1)))\n            .unwrap_or(false)\n    }\n}\n```\n\n## Performance Considerations\n\n- **Indexing**: Fast lookups by sender, fee, etc.\n- **Sorting**: Keep transactions sorted by priority\n- **Memory limits**: Prevent pool from growing too large\n- **Concurrent access**: Thread-safe operations",
  "difficulty": "advanced",
  "estimatedTime": 50,
  "prerequisites": [
    "lesson-30-blocks-transactions"
  ],
  "codeExamples": [
    {
      "id": "ex-47-1-transaction-pool",
      "title": "Transaction Pool",
      "description": "Basic transaction pool implementation",
      "code": "use std::collections::HashMap;\nstruct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    fee: u64,\n    nonce: u64,\n}\nstruct TransactionPool {\n    pending: Vec<Transaction>,\n    max_size: usize,\n}\nimpl TransactionPool {\n    fn new(max_size: usize) -> Self {\n        TransactionPool {\n            pending: Vec::new(),\n            max_size,\n        }\n    }\n    fn add(&mut self, tx: Transaction) -> Result<(), String> {\n        if self.pending.len() >= self.max_size {\n            return Err(String::from(\"Pool is full\"));\n        }\n        self.pending.push(tx);\n        Ok(())\n    }\n    fn select_best(&mut self, count: usize) -> Vec<Transaction> {\n        self.pending.sort_by(|a, b| b.fee.cmp(&a.fee));\n        self.pending.drain(..count.min(self.pending.len())).collect()\n    }\n    fn size(&self) -> usize {\n        self.pending.len()\n    }\n}\nfn main() {\n    let mut pool = TransactionPool::new(100);\n    pool.add(Transaction {\n        from: String::from(\"Alice\"),\n        to: String::from(\"Bob\"),\n        amount: 100,\n        fee: 10,\n        nonce: 1,\n    }).unwrap();\n    pool.add(Transaction {\n        from: String::from(\"Charlie\"),\n        to: String::from(\"Dave\"),\n        amount: 200,\n        fee: 20,\n        nonce: 1,\n    }).unwrap();\n    println!(\"Pool size: {}\", pool.size());\n    let selected = pool.select_best(1);\n    println!(\"Selected transaction with fee: {}\", selected[0].fee);\n}",
      "explanation": "A transaction pool stores pending transactions. It selects transactions based on priority (typically fee) for inclusion in blocks.",
      "language": "rust"
    },
    {
      "id": "ex-47-2-fee-priority",
      "title": "Fee Priority",
      "description": "Selecting transactions by fee",
      "code": "struct Transaction {\n    id: String,\n    fee: u64,\n}\nfn select_by_fee(transactions: &mut Vec<Transaction>, max_count: usize) -> Vec<Transaction> {\n    transactions.sort_by(|a, b| b.fee.cmp(&a.fee));\n    transactions.iter()\n        .take(max_count)\n        .cloned()\n        .collect()\n}\nfn main() {\n    let mut txs = vec![\n        Transaction { id: String::from(\"tx1\"), fee: 5 },\n        Transaction { id: String::from(\"tx2\"), fee: 20 },\n        Transaction { id: String::from(\"tx3\"), fee: 10 },\n        Transaction { id: String::from(\"tx4\"), fee: 15 },\n    ];\n    let selected = select_by_fee(&mut txs, 2);\n    for tx in selected {\n        println!(\"Selected: {} (fee: {})\", tx.id, tx.fee);\n    }\n}",
      "explanation": "Transactions are typically selected by fee priority. Higher fee transactions are included first, incentivizing users to pay higher fees for faster inclusion.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-47-1",
      "title": "Transaction Pool",
      "description": "Create a transaction pool that selects highest fee transactions!",
      "starterCode": "struct Transaction {\n    fee: u64,\n    data: String,\n}\nstruct Pool {\n    transactions: Vec<Transaction>,\n}\nfn main() {\n    let mut pool = Pool::new();\n    pool.add(Transaction { fee: 10, data: String::from(\"tx1\") });\n    pool.add(Transaction { fee: 30, data: String::from(\"tx2\") });\n    pool.add(Transaction { fee: 20, data: String::from(\"tx3\") });\n    let top = pool.select_top(2);\n    println!(\"Selected {} transactions\", top.len());\n}",
      "solution": "struct Transaction {\n    fee: u64,\n    data: String,\n}\nstruct Pool {\n    transactions: Vec<Transaction>,\n}\nimpl Pool {\n    fn new() -> Self {\n        Pool { transactions: Vec::new() }\n    }\n    fn add(&mut self, tx: Transaction) {\n        self.transactions.push(tx);\n    }\n    fn select_top(&mut self, count: usize) -> Vec<Transaction> {\n        self.transactions.sort_by(|a, b| b.fee.cmp(&a.fee));\n        self.transactions.drain(..count.min(self.transactions.len())).collect()\n    }\n}\nfn main() {\n    let mut pool = Pool::new();\n    pool.add(Transaction { fee: 10, data: String::from(\"tx1\") });\n    pool.add(Transaction { fee: 30, data: String::from(\"tx2\") });\n    pool.add(Transaction { fee: 20, data: String::from(\"tx3\") });\n    let top = pool.select_top(2);\n    println!(\"Selected {} transactions\", top.len());\n}",
      "hints": [
        "Sort transactions by fee in descending order",
        "Use drain() to remove and return top N"
      ],
      "difficulty": "medium"
    }
  ]
}
