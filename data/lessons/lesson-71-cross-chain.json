{
  "id": "lesson-71-cross-chain",
  "title": "Cross-Chain Interoperability and Bridges",
  "description": "Building cross-chain bridges and implementing interoperability protocols between different blockchains.",
  "content": "# Cross-Chain Interoperability and Bridges\n\nCross-chain solutions enable communication and value transfer between different blockchains.\n\n## The Interoperability Problem\n\nBlockchains are isolated - they can't natively communicate with each other. This creates:\n\n- **Liquidity Fragmentation**: Assets locked on different chains\n- **User Friction**: Multiple wallets, different experiences\n- **Limited Composability**: Can't combine features across chains\n\n## Bridge Types\n\n### 1. Lock and Mint\n\n- Lock assets on source chain\n- Mint wrapped tokens on destination chain\n- Burn wrapped tokens to unlock originals\n\n### 2. Burn and Mint\n\n- Burn tokens on source chain\n- Mint equivalent on destination chain\n- Reverse process for return\n\n### 3. Atomic Swaps\n\n- Direct peer-to-peer swaps\n- No intermediary needed\n- Uses hash time-locked contracts (HTLC)\n\n### 4. Relays\n\n- Validators monitor both chains\n- Relay state and messages\n- More complex but more flexible\n\n## Bridge Architecture\n\n```rust\nstruct Bridge {\n    source_chain: String,\n    target_chain: String,\n    validators: Vec<String>,\n    deposits: HashMap<String, DepositInfo>,\n    withdrawals: HashMap<String, WithdrawalInfo>,\n}\n\nstruct DepositInfo {\n    amount: u64,\n    recipient: String,\n    source_tx_hash: String,\n    status: BridgeStatus,\n}\n\nenum BridgeStatus {\n    Pending,\n    Confirmed,\n    Processed,\n    Failed,\n}\n\nimpl Bridge {\n    fn deposit(&mut self, amount: u64, recipient: &str, tx_hash: &str) -> String {\n        let deposit_id = generate_id();\n        \n        self.deposits.insert(deposit_id.clone(), DepositInfo {\n            amount,\n            recipient: recipient.to_string(),\n            source_tx_hash: tx_hash.to_string(),\n            status: BridgeStatus::Pending,\n        });\n        \n        deposit_id\n    }\n    \n    fn confirm_deposit(&mut self, deposit_id: &str, validator: &str) -> Result<(), String> {\n        if !self.validators.contains(&validator.to_string()) {\n            return Err(String::from(\"Invalid validator\"));\n        }\n        \n        let deposit = self.deposits.get_mut(deposit_id)\n            .ok_or(String::from(\"Deposit not found\"))?;\n        \n        // In real implementation: verify validator signatures\n        deposit.status = BridgeStatus::Confirmed;\n        \n        Ok(())\n    }\n    \n    fn process_withdrawal(&mut self, deposit_id: &str) -> Result<WithdrawalInfo, String> {\n        let deposit = self.deposits.get(deposit_id)\n            .ok_or(String::from(\"Deposit not found\"))?;\n        \n        if deposit.status != BridgeStatus::Confirmed {\n            return Err(String::from(\"Deposit not confirmed\"));\n        }\n        \n        // Check validator consensus (simplified)\n        // In real implementation: require 2/3+ validator signatures\n        \n        let withdrawal = WithdrawalInfo {\n            amount: deposit.amount,\n            recipient: deposit.recipient.clone(),\n            target_tx_hash: String::new(), // Will be set when processed\n        };\n        \n        self.withdrawals.insert(deposit_id.to_string(), withdrawal.clone());\n        \n        Ok(withdrawal)\n    }\n}\n```\n\n## Hash Time-Locked Contracts (HTLC)\n\nHTLCs enable atomic swaps without trusted intermediaries.\n\n```rust\nstruct HTLC {\n    hash_lock: Vec<u8>, // Hash of secret\n    time_lock: u64, // Expiration time\n    sender: String,\n    receiver: String,\n    amount: u64,\n    secret: Option<Vec<u8>>, // Revealed when claimed\n}\n\nimpl HTLC {\n    fn new(hash_lock: Vec<u8>, time_lock: u64, sender: &str, receiver: &str, amount: u64) -> Self {\n        HTLC {\n            hash_lock,\n            time_lock,\n            sender: sender.to_string(),\n            receiver: receiver.to_string(),\n            amount,\n            secret: None,\n        }\n    }\n    \n    fn claim(&mut self, secret: Vec<u8>) -> Result<(), String> {\n        // Verify secret matches hash\n        if hash(&secret) != self.hash_lock {\n            return Err(String::from(\"Invalid secret\"));\n        }\n        \n        self.secret = Some(secret);\n        Ok(())\n    }\n    \n    fn refund(&self, current_time: u64) -> Result<(), String> {\n        if current_time < self.time_lock {\n            return Err(String::from(\"Time lock not expired\"));\n        }\n        \n        if self.secret.is_some() {\n            return Err(String::from(\"Already claimed\"));\n        }\n        \n        Ok(())\n    }\n}\n```\n\n## Security Considerations\n\n### Validator Risks\n\n- **Collusion**: Validators could steal funds\n- **Single Point of Failure**: If validators go offline\n- **Solution**: Use many validators, require high threshold\n\n### Replay Attacks\n\n- **Problem**: Same transaction executed on both chains\n- **Solution**: Nonces, chain-specific identifiers\n\n### Double Spending\n\n- **Problem**: Spending same asset on both chains\n- **Solution**: Lock mechanism, proper state tracking\n\n## Real-World Examples\n\n- **Polygon Bridge**: Lock and mint between Ethereum and Polygon\n- **Wormhole**: Multi-chain bridge with validators\n- **Chainlink CCIP**: Cross-chain messaging protocol\n- **Cosmos IBC**: Inter-Blockchain Communication protocol\n\n## Best Practices\n\n- **Multi-Signature**: Require multiple validator signatures\n- **Time Locks**: Allow users to challenge suspicious transactions\n- **Rate Limiting**: Prevent large-scale attacks\n- **Monitoring**: Alert on unusual activity\n- **Upgradability**: Ability to fix bugs and add features",
  "difficulty": "advanced",
  "estimatedTime": 55,
  "prerequisites": [
    "lesson-49-building-blockchain",
    "lesson-68-advanced-consensus"
  ],
  "codeExamples": [
    {
      "id": "ex-71-1-bridge-implementation",
      "title": "Cross-Chain Bridge",
      "description": "Basic bridge implementation for asset transfer",
      "code": "use std::collections::HashMap;\n\nenum BridgeStatus {\n    Pending,\n    Confirmed,\n    Processed,\n}\n\nstruct Deposit {\n    amount: u64,\n    recipient: String,\n    source_tx: String,\n    status: BridgeStatus,\n    confirmations: usize,\n}\n\nstruct Bridge {\n    deposits: HashMap<String, Deposit>,\n    validators: Vec<String>,\n    required_confirmations: usize,\n}\n\nimpl Bridge {\n    fn new(validators: Vec<String>) -> Self {\n        let required = (validators.len() * 2) / 3 + 1; // 2/3+1\n        Bridge {\n            deposits: HashMap::new(),\n            validators,\n            required_confirmations: required,\n        }\n    }\n    \n    fn deposit(&mut self, deposit_id: String, amount: u64, recipient: String, source_tx: String) {\n        self.deposits.insert(deposit_id, Deposit {\n            amount,\n            recipient,\n            source_tx,\n            status: BridgeStatus::Pending,\n            confirmations: 0,\n        });\n    }\n    \n    fn confirm(&mut self, deposit_id: &str, validator: &str) -> Result<bool, String> {\n        if !self.validators.contains(&validator.to_string()) {\n            return Err(String::from(\"Invalid validator\"));\n        }\n        \n        let deposit = self.deposits.get_mut(deposit_id)\n            .ok_or(String::from(\"Deposit not found\"))?;\n        \n        deposit.confirmations += 1;\n        \n        if deposit.confirmations >= self.required_confirmations {\n            deposit.status = BridgeStatus::Confirmed;\n            Ok(true) // Ready to process\n        } else {\n            Ok(false) // Need more confirmations\n        }\n    }\n    \n    fn process_withdrawal(&mut self, deposit_id: &str) -> Result<u64, String> {\n        let deposit = self.deposits.get_mut(deposit_id)\n            .ok_or(String::from(\"Deposit not found\"))?;\n        \n        match deposit.status {\n            BridgeStatus::Confirmed => {\n                deposit.status = BridgeStatus::Processed;\n                Ok(deposit.amount)\n            }\n            _ => Err(String::from(\"Deposit not confirmed\")),\n        }\n    }\n}\n\nfn main() {\n    let validators = vec![\n        String::from(\"validator1\"),\n        String::from(\"validator2\"),\n        String::from(\"validator3\"),\n        String::from(\"validator4\"),\n    ];\n    \n    let mut bridge = Bridge::new(validators);\n    \n    // User deposits on source chain\n    bridge.deposit(\n        String::from(\"deposit1\"),\n        1000,\n        String::from(\"0xAlice\"),\n        String::from(\"0xtx123\"),\n    );\n    \n    // Validators confirm\n    bridge.confirm(\"deposit1\", \"validator1\").unwrap();\n    bridge.confirm(\"deposit1\", \"validator2\").unwrap();\n    bridge.confirm(\"deposit1\", \"validator3\").unwrap();\n    \n    // Process withdrawal on target chain\n    match bridge.process_withdrawal(\"deposit1\") {\n        Ok(amount) => {\n            println!(\"Withdrawal processed: {} tokens to 0xAlice\", amount);\n        }\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "explanation": "Bridges lock assets on the source chain and mint equivalent assets on the target chain. Validators monitor both chains and confirm deposits. Once enough validators confirm (2/3+), the withdrawal can be processed. This enables cross-chain asset transfers.",
      "language": "rust"
    },
    {
      "id": "ex-71-2-htlc-atomic-swap",
      "title": "HTLC Atomic Swap",
      "description": "Hash Time-Locked Contract for atomic swaps",
      "code": "use std::collections::HashMap;\n\nfn hash(data: &[u8]) -> Vec<u8> {\n    // Simplified hash function\n    // In real implementation: use SHA256 or similar\n    data.iter().map(|b| b.wrapping_add(1)).collect()\n}\n\nstruct HTLC {\n    hash_lock: Vec<u8>,\n    time_lock: u64,\n    sender: String,\n    receiver: String,\n    amount: u64,\n    secret: Option<Vec<u8>>,\n    claimed: bool,\n}\n\nimpl HTLC {\n    fn new(\n        secret_preimage: Vec<u8>,\n        time_lock: u64,\n        sender: &str,\n        receiver: &str,\n        amount: u64,\n    ) -> Self {\n        let hash_lock = hash(&secret_preimage);\n        \n        HTLC {\n            hash_lock,\n            time_lock,\n            sender: sender.to_string(),\n            receiver: receiver.to_string(),\n            amount,\n            secret: None,\n            claimed: false,\n        }\n    }\n    \n    fn claim(&mut self, secret: Vec<u8>, current_time: u64) -> Result<(), String> {\n        if self.claimed {\n            return Err(String::from(\"Already claimed\"));\n        }\n        \n        if current_time >= self.time_lock {\n            return Err(String::from(\"Time lock expired\"));\n        }\n        \n        if hash(&secret) != self.hash_lock {\n            return Err(String::from(\"Invalid secret\"));\n        }\n        \n        self.secret = Some(secret);\n        self.claimed = true;\n        Ok(())\n    }\n    \n    fn refund(&self, current_time: u64) -> Result<(), String> {\n        if self.claimed {\n            return Err(String::from(\"Already claimed\"));\n        }\n        \n        if current_time < self.time_lock {\n            return Err(String::from(\"Time lock not expired\"));\n        }\n        \n        Ok(())\n    }\n}\n\nfn main() {\n    // Alice wants to swap with Bob\n    let secret = vec![1, 2, 3, 4, 5];\n    \n    // Alice creates HTLC on chain A\n    let mut htlc_a = HTLC::new(\n        secret.clone(),\n        1000, // Expires at block 1000\n        \"alice\",\n        \"bob\",\n        100,\n    );\n    \n    println!(\"HTLC created on chain A\");\n    \n    // Bob sees the hash, creates HTLC on chain B\n    // Bob reveals secret to claim on chain A\n    match htlc_a.claim(secret, 500) {\n        Ok(_) => {\n            println!(\"Bob claimed HTLC on chain A\");\n            println!(\"Secret revealed: {:?}\", htlc_a.secret);\n            println!(\"Alice can now use secret to claim on chain B\");\n        }\n        Err(e) => println!(\"Claim failed: {}\", e),\n    }\n}",
      "explanation": "HTLCs enable atomic swaps: Alice locks funds with a hash, Bob locks funds on another chain, Bob claims Alice's funds revealing the secret, then Alice uses the same secret to claim Bob's funds. If either party doesn't cooperate, funds can be refunded after the time lock expires.",
      "language": "rust"
    }
  ],
  "exercises": [
    {
      "id": "exercise-71-1",
      "title": "Simple Bridge",
      "description": "Create a simple bridge deposit and withdrawal system!",
      "starterCode": "use std::collections::HashMap;\n\nstruct Bridge {\n    deposits: HashMap<String, u64>,\n}\n\nfn main() {\n    // Create bridge\n    // Deposit assets\n    // Process withdrawal\n}",
      "solution": "use std::collections::HashMap;\n\nstruct Bridge {\n    deposits: HashMap<String, u64>,\n    processed: HashMap<String, bool>,\n}\n\nimpl Bridge {\n    fn new() -> Self {\n        Bridge {\n            deposits: HashMap::new(),\n            processed: HashMap::new(),\n        }\n    }\n    \n    fn deposit(&mut self, deposit_id: String, amount: u64) {\n        self.deposits.insert(deposit_id, amount);\n    }\n    \n    fn withdraw(&mut self, deposit_id: &str) -> Result<u64, String> {\n        if self.processed.get(deposit_id).copied().unwrap_or(false) {\n            return Err(String::from(\"Already processed\"));\n        }\n        \n        let amount = self.deposits.get(deposit_id)\n            .copied()\n            .ok_or(String::from(\"Deposit not found\"))?;\n        \n        self.processed.insert(deposit_id.to_string(), true);\n        Ok(amount)\n    }\n}\n\nfn main() {\n    let mut bridge = Bridge::new();\n    \n    bridge.deposit(String::from(\"deposit1\"), 1000);\n    \n    match bridge.withdraw(\"deposit1\") {\n        Ok(amount) => println!(\"Withdrew {} tokens\", amount),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
      "hints": [
        "Track deposits with HashMap",
        "Prevent double withdrawals",
        "Return amount on successful withdrawal"
      ],
      "difficulty": "medium"
    }
  ]
}

